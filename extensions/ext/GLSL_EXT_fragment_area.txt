Name

    EXT_fragment_area

Name Strings

    GL_EXT_fragment_area

Contact

    Daniel Koch, NVIDIA Corporation (dkoch 'at' nvidia.com)

Contributors

    Pat Brown, NVIDIA
    Matthew Netsch, Qualcomm
    Jan-Harald Fredriksen, Arm
    Mark Kilgard, NVIDIA

Status

    Draft

Version

    Last Modified:      October 20, 2018
    Revision:           1

Dependencies

    This extension can be applied to OpenGL GLSL versions 4.50
    (#version 450) and higher.

    This extension can be applied to OpenGL ES ESSL versions 3.20
    (#version 320) and higher.

    This extension is written against the OpenGL Shading Language
    Specification, version 4.60, dated July 23, 2017.

Overview

    This extension provides OpenGL Shading Language (GLSL) support for the API
    extensions "NV_shading_rate_image" and "EXT_fragment_density_map". In
    those extensions, applications can use a texture to control the number of
    fragment shader invocations that will be spawned for a particular
    neighborhood of covered pixels.  We refer to the density of fragment
    shader invocations as the "shading rate". Implementations may support
    shading rates that run one invocation for multiple pixels as well as
    rates that run multiple invocations for a single pixel.

    This extension provides GLSL built-in variables that allow the fragment
    shader to determine the shading rate used for a particular invocation.
    When using a shading rate where a single invocation covers multiple
    pixels, the built-in gl_FragAreaEXT indicates the size of the rectangle
    of pixels used for that invocation.  When using a shading rate where
    multiple invocations can be spawned for each pixel, the built-in
    gl_FragInvocationCountEXT indicates the number of invocations that will be
    spawned for a fully covered pixel.

    Mapping to SPIR-V
    -----------------

    For informational purposes (non-normative), the following is an
    expected way for an implementation to map GLSL constructs to SPIR-V
    constructs supported by the SPV_NV_shading_rate extension:

    - gl_FragAreaEXT -> FragAreaEXT decorated variable
    - gl_FragInvocationCountEXT -> FragInvocationCountEXT decorated variable

Modifications to the OpenGL Shading Language Specification, Version 4.60

    Including the following line in a shader can be used to control the
    language features described in this extension:

      #extension GL_EXT_fragment_area : <behavior>

    where <behavior> is as specified in section 3.3.

    New preprocessor #defines are added to the OpenGL Shading Language:

      #define GL_EXT_fragment_area          1

    Modify Section 7.1, Built-In Language Variables, p. 122

    (add to the list of fragment language variables, middle of p. 124)

      in ivec2 gl_FragAreaEXT;
      in int   gl_FragInvocationCountEXT;

    (add documentation of the new built-in variables, before
     gl_HelperInvocation discussion at the bottom of p.128)

    The input variable gl_FragAreaEXT represents the size of a rectangle of
    pixels corresponding to this fragment shader invocation.  The first
    component is the width of the rectangle (in pixels); the second component
    is the height (in pixels).  When a shading rate image or fragment density
    map is not used, or when running multiple fragment shader invocations per
    pixel (multisampling), both components will be one.  When using a shading
    rate image or fragment density map, either or both components may be
    greater than one.  When the fragment size is greater than a single pixel,
    the outputs of the shader invocation will be broadcast to all covered
    pixels/samples in the rectangle.

    The input variable gl_FragInvocationCountEXT represents the maximum number
    of fragment shader invocations executed for each pixel, as derived from
    the effective shading rate for the fragment.  If a primitive does not
    fully cover a pixel, the number of fragment shader invocations for its
    covered pixels may be less than the value of gl_FragInvocationCountEXT.
    When a shading rate image or fragment density map is not used, this value
    is a function of the framebuffer sample counts and the sample shading
    fraction programmed in the OpenGL API via MinSampleShading or the Vulkan
    API via minSampleShading. When using a shading rate image or fragment
    density map, this value will also be affected by the contents of the
    texture and may depend on the location of the pixel in the framebuffer.
    If multisampling is disabled, or if the fragment shader invocation covers
    multiple pixels, the value of this input will be one.

    Modify Section 8.13.1, Derivative Functions, p. 184

    (add a new paragraph before the last paragraph "It is typical to consider
    a 2x2 square", p. 184)

    When using a shading rate where each fragment covers multiple columns
    and/or rows of pixels, the values of dx and/or dy in equations 1b and 2b
    above will be greater than 1.0.  However, we recommend that
    implementations approximate derivatives in this case using dx = dy = 1.0.

Issues

    (1) How should we name this extension and the builtins?

      RESOLVED:  We are calling this extension "EXT_fragment_area", based
      on the name we chose for the primary builtin added in this extension.

      We considered using the terms Size and Area for the builtin. Both had
      merits, and Size would have matched with gl_FragmentSizeNV from the
      original extension, but Size doesn't really match the API extension's
      terminology. Area has the advantage that it matches the Vulkan glossary
      name. One drawback of Area might be that it tends imply a scalar value
      that would be the width x height of a fragment, however Vulkan does also
      have the concept of renderArea which is a rectangle. In the end, Area
      won out.  We also chose to use the "Frag" prefix instead of "Fragment"
      as there are a number of GLSL built-ins that use "Frag" as a prefix
      (gl_FragCoord, gl_FragDepth, gl_FragColor, gl_FragData) and none that
      use "Fragment".

      We also decided to pick a new name for InvocationsPerPixelNV as
      a fragment may actually represent more than a single pixel in cases
      where the shading rate image or fragment density maps results in
      coarse shading. We settled on the name gl_FragInvocationCountEXT
      to indicate how many invocations are being executed per fragment.

    (2) How do derivatives work for dFdx and texture LOD calculations when a
        single fragment shader invocation covers multiple pixels?

      RESOLVED:  In the NVIDIA implementation of this extension, derivatives
      will be computed by differencing, where the "neighboring" fragment
      shader invocation also covers the same number of pixels.  Differencing
      can be used to approximate derivatives at a given (x,y) by evaluating
      equations like the following:

        df/dx(x,y) = (f(x2,y) - f(x1,y)) / (x2 - x1)

      where <x1> and <x2> are X coordinates of for the two fragment shader
      invocations used for differencing.  <x> is typically either <x1> or
      <x2>.  For normal fragment shader invocations, where each fragment
      typically covers a pixel, we assume that x2-x1 is always 1.0 and reduce
      the approximation to:

        df/dx(x,y) = f(x2,y) - f(x1,y)

      We end up using this equation in this extension, even when fragments
      cover multiple pixels and x2-x1 is greater than 1.0.  If a given
      fragment shader invocation covers a 2x2 region, this approach means that
      dFdx and dFdy will return values approximately twice as large as
      the real derivatives.

      We could adjust computed derivatives to compensate, but choose not to
      because using raw differences without adjustment is preferable for
      texture LOD handling.  Derivatives in LOD calculations are used to
      approximate the set of texels covered by the pixel being processed.  If
      that pixel covers many texels in a full-resolution image, we use a
      lower-resolution mipmap level to reduce noise.  When a fragment shader
      invocation covers multiple pixels, its footprint in texture space is
      larger than it would be if it covered a single pixel.  In this case, our
      "mathematically too large" derivatives provide a better approximation of
      the set of texels involved in the lookup.

      If a shader using this feature does need mathematically accurate
      derivatives, it can adjust by dividing through by the X and Y
      components of gl_FragAreaEXT.

    (3) How is this extension different from GL_NV_shading_rate_image?

      RESOLVED: In this extension we use the term gl_FragAreaEXT instead
      of gl_FragmentSizeNV and gl_FragInvocationCountEXT instead of
      gl_InvocationsPerPixelNV, but these are otherwise functionally
      equivalent. This shading language extension is not tightly coupled
      with any specific API extension and can be used with
      GL_NV_shading_rate_image in OpenGL and with VK_NV_shading_rate_image
      or VK_EXT_fragment_density_map in Vulkan but it doesn't require
      any of them as it provides useful functionality on it's own.

      This extension also doesn't include interactions with
      ARB_fragment_shader_interlock.


Revision History

    Revision 1, 2018/10/20 (dgkoch)
    - Initial version based on NV_shading_rate_image.
