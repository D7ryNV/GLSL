// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0

[[built-in-functions]]
= Built-In Functions

The {slname} defines an assortment of built-in convenience functions for
scalar and vector operations.
Many of these built-in functions can be used in more than one type of
shader, but some are intended to provide a direct mapping to hardware and so
are available only for a specific type of shader.

The built-in functions basically fall into three categories:

  * They expose some necessary hardware functionality in a convenient way
    such as accessing a texture map.
    There is no way in the language for these functions to be emulated by a
    shader.
  * They represent a trivial operation (clamp, mix, etc.) that is very
    simple for the user to write, but they are very common and may have
    direct hardware support.
    It is a very hard problem for the compiler to map expressions to complex
    assembler instructions.
  * They represent an operation graphics hardware is likely to accelerate at
    some point.
    The trigonometry functions fall into this category.

Many of the functions are similar to the same named ones in common C
libraries, but they support vector input as well as the more traditional
scalar input.

Applications should be encouraged to use the built-in functions rather than
do the equivalent computations in their own shader code since the built-in
functions are assumed to be optimal (e.g. perhaps supported directly in
hardware).

ifdef::GLSL[]
User code can replace built-in functions with their own if they choose, by
simply redeclaring and defining the same name and argument list.
Because built-in functions are in a more outer scope than user built-in
functions, doing this will hide all built-in functions with the same name as
the redeclared function.
endif::GLSL[]

When the built-in functions are specified below, where the input arguments
(and corresponding output) can be *float*, *vec2*, *vec3*, or *vec4*,
_genFType_ is used as the argument.
Where the input arguments (and corresponding output) can be *int*, *ivec2*,
*ivec3*, or *ivec4*, _genIType_ is used as the argument.
Where the input arguments (and corresponding output) can be *uint*, *uvec2*,
*uvec3*, or *uvec4*, _genUType_ is used as the argument.
Where the input arguments (or corresponding output) can be *bool*, *bvec2*,
*bvec3*, or *bvec4*, _genBType_ is used as the argument.
ifdef::GLSL[]
Where the input arguments (and corresponding output) can be *double*,
*dvec2*, *dvec3*, *dvec4*, _genDType_ is used as the argument.
endif::GLSL[]
For any specific use of a function, the actual types substituted for
_genFType_, _genIType_, _genUType_, or _genBType_ have to have the same
number of components for all arguments and for the return type.
Similarly, _mat_ is used for any matrix basic
ifdef::ESSL[type.]
ifdef::GLSL[]
type with single-precision
components and _dmat_ is used for any matrix basic type with
double-precision components.
endif::GLSL[]

Built-in functions have an effective precision qualification.
This qualification cannot be set explicitly and may be different from the
precision qualification of the result.

ifdef::GLSL[]
NOTE: In general, as has been noted, precision qualification is ignored
unless targeting Vulkan.
endif::GLSL[]

The precision qualification of the operation of a built-in function is based
on the precision qualification of its formal parameters and actual
parameters (input arguments): When a formal parameter specifies a precision
qualifier, that is used, otherwise, the precision qualification of the
actual (calling) argument is used.
The highest precision of these will be the precision of the operation of the
built-in function.
Generally, this is applied across all arguments to a built-in function, with
the exceptions being:

  * *bitfieldExtract* and *bitfieldInsert* ignore the _offset_ and _bits_
    arguments.
  * *interpolateAt* functions only look at the _interpolant_ argument.

The precision qualification of the result of a built-in function is
determined in one of the following ways:

For the texture sampling and image load functions, the
precision of the return type matches the precision of the
image or texture-combined sampler type:

[source,glsl]
----
uniform lowp sampler2D texSampler;
highp vec2 coord;
...
lowp vec4 col = texture (texSampler, coord); // texture() returns lowp
----

Otherwise:

  * For prototypes that do not specify a resulting precision qualifier, the
    precision will be the same as the precision of the operation (as defined
    earlier).
  * For prototypes that do specify a resulting precision qualifier, the
    specified precision qualifier is the precision qualification of the
    result.

Where the built-in functions in the following sections specify an equation,
the entire equation will be evaluated at the operation's precision.
This may lead to underflow or overflow in the result, even when the correct
result could be represented in the operation precision.


[[angle-and-trigonometry-functions]]
== Angle and Trigonometry Functions

Function parameters specified as _angle_ are assumed to be in units of
radians.
In no case will any of these functions result in a divide by zero error.
If the divisor of a ratio is 0, then results will be undefined.

These all operate component-wise.
The description is per component.

=== Radians
[source,glsl]
----
genFType radians(genFType degrees)
----

Converts _degrees_ to radians, i.e., [eq]#({pi} / 180) {cdot} degrees#.

=== Degrees
[source,glsl]
----
genFType degrees(genFType radians)
----

Converts _radians_ to degrees, i.e., [eq]#(180 / {pi}) {cdot} radians#.

=== Sin
[source,glsl]
----
genFType sin(genFType angle)
----

The standard trigonometric sine function.

=== Cos
[source,glsl]
----
genFType cos(genFType angle)
----

The standard trigonometric cosine function.

=== Tan
[source,glsl]
----
genFType tan(genFType angle)
----

The standard trigonometric tangent.

=== Asin
[source,glsl]
----
genFType asin(genFType x)
----

Arc sine. Returns an angle whose sine is _x_.

The range of values returned by this function is [eq]#[-{pi} / 2, {pi} / 2]#.
Results are undefined if [eq]#{vert}x{vert} > 1#.

=== Acos
[source,glsl]
----
genFType acos(genFType x)
----

Arc cosine. Returns an angle whose cosine is _x_.

The range of values returned by this function is [eq]#[0,{pi}]#.
Results are undefined if [eq]#{vert}x{vert} > 1#.

=== Atan
[source,glsl]
----
genFType atan(genFType y, genFType x)
----

Arc tangent. Returns an angle whose tangent is [eq]#y / x#.

The signs of _x_ and _y_ are used to determine what quadrant the angle is in.
The range of values returned by this function is [eq]#[-{pi}, {pi}]#.
Results are undefined if _x_ and _y_ are both 0.

[source,glsl]
----
genFType atan(genFType y_over_x)
----

Arc tangent. Returns an angle whose tangent is _y_over_x_.

The range of values returned by this function is [eq]#[-{pi} / 2, {pi} / 2]#.

=== Sinh
[source,glsl]
----
genFType sinh(genFType x)
----

Returns the hyperbolic sine function [eq]#(e^x^ - e^-x^) / 2#.

=== Cosh
[source,glsl]
----
genFType cosh(genFType x)
----

Returns the hyperbolic cosine function [eq]#(e^x^ + e^-x^) / 2#.

=== Tanh
[source,glsl]
----
genFType tanh(genFType x)
----

Returns the hyperbolic tangent function [eq]#sinh(x) / cosh(x)#.

=== Asinh
[source,glsl]
----
genFType asinh(genFType x)
----

Arc hyperbolic sine; returns the inverse of *sinh*.

=== Acosh
[source,glsl]
----
genFType acosh(genFType x)
----

Arc hyperbolic cosine. Returns the non-negative inverse of *cosh*.

Results are undefined if [eq]#x < 1#.

=== Atanh
[source,glsl]
----
genFType atanh(genFType x)
----

Arc hyperbolic tangent. Returns the inverse of *tanh*.

Results are undefined if [eq]#{vert}x{vert} {geq} 1#.


[[exponential-functions]]
== Exponential Functions

These all operate component-wise.
The description is per component.

=== Pow
[source,glsl]
----
genFType pow(genFType x, genFType y)
----

Returns _x_ raised to the _y_ power, i.e., [eq]#x^y^#.

Results are undefined if [eq]#x < 0#.
Results are undefined if [eq]#x = 0# and [eq]#y {leq} 0#.

=== Exp
[source,glsl]
----
genFType exp(genFType x)
----

Returns the natural exponentiation of _x_, i.e., [eq]#e^x^#.

=== Log
[source,glsl]
----
genFType log(genFType x)
----

Returns the natural logarithm of _x_, i.e., returns the value _y_
which satisfies the equation [eq]#x = e^y^#.

Results are undefined if [eq]#x {leq} 0#.

=== Exp2
[source,glsl]
----
genFType exp2(genFType x)
----

Returns 2 raised to the _x_ power, i.e., [eq]#2^x^#.

=== Log2
[source,glsl]
----
genFType log2(genFType x)
----

Returns the base 2 logarithm of _x_, i.e., returns the value _y_ which
satisfies the equation [eq]#x = 2^y^#.

Results are undefined if [eq]#x {leq} 0#.

=== Sqrt
[source,glsl]
----
genFType sqrt(genFType x)
ifdef::GLSL[]
genDType sqrt(genDType x)
endif::GLSL[]
----

Returns [eq]#sqrt(x)#.

Results are undefined if [eq]#x < 0#.

=== Inverse Sqrt
[source,glsl]
----
genFType inversesqrt(genFType x)
ifdef::GLSL[]
genDType inversesqrt(genDType x)
endif::GLSL[]
----

Returns [eq]#1 / sqrt(x)#.

Results are undefined if [eq]#x {leq} 0#.


[[common-functions]]
== Common Functions

These all operate component-wise.
The description is per component.

=== Abs
[source,glsl]
----
genFType abs(genFType x)
ifdef::GLSL[]
genIType abs(genIType x)
genDType abs(genDType x)
endif::GLSL[]
ifdef::ESSL[]
genIType abs(genIType x)
endif::ESSL[]
----

Returns _x_ if [eq]#x {geq} 0#; otherwise it returns -_x_.

=== Sign
[source,glsl]
----
genFType sign(genFType x)
ifdef::GLSL[]
genIType sign(genIType x)
genDType sign(genDType x)
endif::GLSL[]
ifdef::ESSL[]
genIType sign(genIType x)
endif::ESSL[]
----

Returns 1.0 if _x_ > 0, 0.0 if _x_ = 0, or -1.0 if _x_ < 0.

=== Floor
[source,glsl]
----
ifdef::GLSL[]
genFType floor(genFType x)
genDType floor(genDType x)
endif::GLSL[]
ifdef::ESSL[]
genFType floor(genFType x)
endif::ESSL[]
----

Returns a value equal to the nearest integer that is less than or equal to _x_.

=== Trunc
[source,glsl]
----
ifdef::GLSL[]
genFType trunc(genFType x)
genDType trunc(genDType x)
endif::GLSL[]
ifdef::ESSL[]
genFType trunc(genFType x)
endif::ESSL[]
----

Returns a value equal to the nearest integer to _x_ whose absolute
value is not larger than the absolute value of _x_.

=== Round
[source,glsl]
----
ifdef::GLSL[]
genFType round(genFType x)
genDType round(genDType x)
endif::GLSL[]
ifdef::ESSL[]
genFType round(genFType x)
endif::ESSL[]
----

Returns a value equal to the nearest integer to _x_.

The fraction 0.5 will round in a direction chosen by the
implementation, presumably the direction that is fastest.
This includes the possibility that *round*(_x_) returns the same value
as *roundEven*(_x_) for all values of _x_.

=== Round Even
[source,glsl]
----
ifdef::GLSL[]
genFType roundEven(genFType x)
genDType roundEven(genDType x)
endif::GLSL[]
ifdef::ESSL[]
genFType roundEven(genFType x)
endif::ESSL[]
----

Returns a value equal to the nearest integer to _x_.

A fractional part of 0.5 will round toward the nearest even integer.
(Both 3.5 and 4.5 for x will return 4.0.)

=== Ceil
[source,glsl]
----
ifdef::GLSL[]
genFType ceil(genFType x)
genDType ceil(genDType x)
endif::GLSL[]
ifdef::ESSL[]
genFType ceil(genFType x)
endif::ESSL[]
----

Returns a value equal to the nearest integer that is greater than or equal to _x_.

=== Fract
[source,glsl]
----
ifdef::GLSL[]
genFType fract(genFType x)
genDType fract(genDType x)
endif::GLSL[]
ifdef::ESSL[]
genFType fract(genFType x)
endif::ESSL[]
----

Returns _x_ - *floor*(_x_).

=== Mod
[source,glsl]
----
genFType mod(genFType x, float y)
ifdef::GLSL[]
genFType mod(genFType x, genFType y)
genDType mod(genDType x, double y)
genDType mod(genDType x, genDType y)
endif::GLSL[]
ifdef::ESSL[]
genFType mod(genFType x, genFType y)
endif::ESSL[]
----

Modulus. Returns [eq]#x - y {cdot} *floor*(x / y)#.

Note that implementations may use a cheap approximation to the remainder,
and the error can be large due to the discontinuity in *floor*. This can
produce mathematically unexpected results in some cases, such as
*mod*(_x_,_x_) computing _x_ rather than 0, and can also cause the result
to have a different sign than the infinitely precise result.

=== Modf
[source,glsl]
----
ifdef::GLSL[]
genFType modf(genFType x, out genFType i)
genDType modf(genDType x, out genDType i)
endif::GLSL[]
ifdef::ESSL[]
genFType modf(genFType x, out genFType i)
endif::ESSL[]
----

Returns the fractional part of _x_ and sets _i_ to the integer part (as
a whole number floating-point value).

Both the return value and the output parameter will have the same sign as _x_.
ifdef::ESSL[]
      If _x_ has the value +/- Inf, the return value should be NaN and must
      be either NaN or 0.0.
      For *highp* non-constant expressions, the value returned must be
      consistent.
endif::ESSL[]

=== Min
[source,glsl]
----
genFType min(genFType x, genFType y)
genFType min(genFType x, float y)
ifdef::GLSL[]
genDType min(genDType x, genDType y)
genDType min(genDType x, double y)
endif::GLSL[]
genIType min(genIType x, genIType y)
genIType min(genIType x, int y)
genUType min(genUType x, genUType y)
genUType min(genUType x, uint y)
----

Returns _y_ if _y_ < _x;_ otherwise it returns _x_.

Which operand is the result is undefined if one of the operands is a NaN.

=== Max
[source,glsl]
----
genFType max(genFType x, genFType y)
genFType max(genFType x, float y)
ifdef::GLSL[]
genDType max(genDType x, genDType y)
genDType max(genDType x, double y)
endif::GLSL[]
genIType max(genIType x, genIType y)
genIType max(genIType x, int y)
genUType max(genUType x, genUType y)
genUType max(genUType x, uint y)
----

Returns _y_ if _x_ < _y;_ otherwise it returns _x_.

Which operand is the result is undefined if one of the operands is a NaN.

=== Clamp
[source,glsl]
----
genFType clamp(genFType x, genFType minVal, genFType maxVal)
genFType clamp(genFType x, float minVal, float maxVal)
ifdef::GLSL[]
genDType clamp(genDType x, genDType minVal, genDType maxVal)
genDType clamp(genDType x, double minVal, double maxVal)
endif::GLSL[]
genIType clamp(genIType x, genIType minVal, genIType maxVal)
genIType clamp(genIType x, int minVal, int maxVal)
genUType clamp(genUType x, genUType minVal, genUType maxVal)
genUType clamp(genUType x, uint minVal, uint maxVal)
----

Returns *min*(*max*(_x_, _minVal_), _maxVal_).

Results are undefined if _minVal_ > _maxVal_.

=== Mix
[source,glsl]
----
genFType mix(genFType x, genFType y, genFType a)
genFType mix(genFType x, genFType y, float a)
ifdef::GLSL[]
genDType mix(genDType x, genDType y, genDType a)
genDType mix(genDType x, genDType y, double a)
endif::GLSL[]
----

Returns the linear blend of _x_ and _y_, i.e., [eq]#x {cdot} (1 - a) + y {cdot} a#.

[source,glsl]
----
genFType mix(genFType x, genFType y, genBType a)
ifdef::GLSL[]
genDType mix(genDType x, genDType y, genBType a)
endif::GLSL[]
genIType mix(genIType x, genIType y, genBType a)
genUType mix(genUType x, genUType y, genBType a)
genBType mix(genBType x, genBType y, genBType a)
----

Selects which vector each returned component comes from.

For a component of _a_ that is *false*, the corresponding component of _x_ is returned.

For a component of _a_ that is *true*, the corresponding component of _y_ is returned.

Components of _x_ and _y_ that are not selected are allowed to be
invalid floating-point values and will have no effect on the results.
Thus, this provides different functionality than, for example, +
genFType *mix*(genFType _x_, genFType _y_, genFType(_a_)) +
where _a_ is a Boolean vector.

=== Step
[source,glsl]
----
genFType step(genFType edge, genFType x)
ifdef::GLSL[]
genFType step(float edge, genFType x)
genDType step(genDType edge, genDType x)
genDType step(double edge, genDType x)
endif::GLSL[]
ifdef::ESSL[]
genFType step(float edge, genFType x)
endif::ESSL[]
----

Returns 0.0 if _x_ < _edge;_ otherwise it returns 1.0.

=== Smoothstep
[source,glsl]
----
genFType smoothstep(genFType edge0, genFType edge1, genFType x)
genFType smoothstep(float edge0, float edge1, genFType x)
ifdef::GLSL[]
genDType smoothstep(genDType edge0, genDType edge1, genDType x)
genDType smoothstep(double edge0, double edge1, genDType x)
endif::GLSL[]
----

Returns 0.0 if [eq]#x {leq} edge0# and 1.0 if [eq]#x {geq} edge1#, and
performs smooth Hermite interpolation between 0 and 1 when [eq]#edge0 < x < edge1#.

This is useful in cases where you would want a threshold function with a smooth transition.

This is equivalent to:
--
[source,glsl]
----
genFType t;
t = clamp ((x - edge0) / (edge1 - edge0), 0, 1);
return t * t * (3 - 2 * t);
----

(And similarly for doubles.) Results are undefined if [eq]#edge0 {geq} edge1#.
--

=== Is NaN
[source,glsl]
----
ifdef::GLSL[]
genBType isnan(genFType x)
genBType isnan(genDType x)
endif::GLSL[]
ifdef::ESSL[]
genBType isnan(genFType x)
endif::ESSL[]
----

Returns *true* if _x_ holds a NaN. Returns *false* otherwise.

Always returns *false* if NaNs are not implemented.

=== Is Inf
[source,glsl]
----
ifdef::GLSL[]
genBType isinf(genFType x)
genBType isinf(genDType x)
endif::GLSL[]
ifdef::ESSL[]
genBType isinf(genFType x)
endif::ESSL[]
----

Returns *true* if _x_ holds a positive infinity or negative infinity. Returns *false* otherwise.

=== Float Bits to Int
[source,glsl]
----
genIType floatBitsToInt(highp genFType value)
genUType floatBitsToUint(highp genFType value)
----

Returns a signed or unsigned integer value representing the encoding of a floating-point value.

The *float* value's bit-level representation is preserved.

=== Int Bits to Float
[source,glsl]
----
genFType intBitsToFloat(highp genIType value)
genFType uintBitsToFloat(highp genUType value)
----

Returns a floating-point value corresponding to a signed or unsigned integer encoding of a
floating-point value.

ifdef::GLSL[]
If a NaN is passed in, it will not signal, and the resulting value is unspecified.

If an Inf is passed in, the resulting value is the corresponding Inf.
endif::GLSL[]
ifdef::ESSL[]
If an Inf or NaN is passed in, it will not signal, and the resulting floating-point value is
unspecified.
endif::ESSL[]

If a subnormal number is passed in, the result might be flushed to 0.
Otherwise, the bit-level representation is preserved.

=== Fma
[source,glsl]
----
genFType fma(genFType a, genFType b, genFType c)
ifdef::GLSL[]
genDType fma(genDType a, genDType b, genDType c)
endif::GLSL[]
----

Computes and returns `a * b + c`.

In uses where the return value is eventually consumed by a variable declared as *precise*:

--
  * *fma*() is considered a single operation, whereas the expression `a * b
    + c` consumed by a variable declared *precise* is considered two
    operations.
  * The precision of *fma*() can differ from the precision of the expression
    `a * b + c`.
  * *fma*() will be computed with the same precision as any other *fma*()
    consumed by a precise variable, giving invariant results for the same
    input values of _a_, _b_, and _c_.

Otherwise, in the absence of *precise* consumption, there are no special
constraints on the number of operations or difference in precision between
*fma*() and the expression `a * b + c`.
--

=== Frexp
[source,glsl]
----
genFType frexp(highp genFType x, out highp genIType exp)
ifdef::GLSL[]
genDType frexp(genDType x, out genIType exp)
endif::GLSL[]
----

Splits _x_ into a floating-point significand in the range
[eq]#[0.5,1.0]#, and an integral exponent of two, such that

[eq]#x = significand {cdot} 2^exponent^#

The significand is returned by the function and the exponent is
returned in the parameter _exp_. For a floating-point value of zero, the
significand and exponent are both zero.

If an implementation supports signed zero, an input value of minus
zero should return a significand of minus zero. For a floating-point value that
is an infinity or is not a number, the results are undefined.

If the input _x_ is a vector, this operation is performed in a
component-wise manner; the value returned by the function and the
value written to _exp_ are vectors with the same number of components as _x_.

=== Ldexp
[source,glsl]
----
genFType ldexp(highp genFType x, highp genIType exp)
ifdef::GLSL[]
genDType ldexp(genDType x, genIType exp)
endif::GLSL[]
----

Builds a floating-point number from _x_ and the corresponding integral
exponent of two in _exp_, returning:

[eq]#significand {cdot} 2^exponent^#

If this product is too large to be represented in the floating-point
type, the result is undefined.

ifdef::GLSL[]
If _exp_ is greater than +128 (single-precision) or +1024
(double-precision), the value returned is undefined.

If _exp_ is less than -126 (single-precision) or -1022
(double-precision), the value returned may be flushed to zero.
endif::GLSL[]
ifdef::ESSL[]
If _exp_ is greater than +128, the value returned is undefined.
If _exp_ is less than -126, the value returned may be flushed to zero.
endif::ESSL[]

Additionally, splitting the value into a significand and exponent
using *frexp*() and then reconstructing a floating-point value using
*ldexp*() should yield the original input for zero and all finite
non-subnormal values.

If the input _x_ is a vector, this operation is performed in a
component-wise manner; the value passed in _exp_ and returned by the
function are vectors with the same number of components as _x_.


[[floating-point-pack-and-unpack-functions]]
== Floating-Point Pack and Unpack Functions

These functions do not operate component-wise, rather, as described in each
case.

=== Pack Unorm
[source,glsl]
----
highp uint packUnorm2x16(vec2 v)
highp uint packSnorm2x16(vec2 v)
ifdef::GLSL[]
uint packUnorm4x8(vec4 v)
uint packSnorm4x8(vec4 v)
endif::GLSL[]
ifdef::ESSL[]
highp uint packUnorm4x8(vec4 v)
highp uint packSnorm4x8(vec4 v)
endif::ESSL[]
----

First, converts each component of the normalized floating-point value
_v_ into 16-bit (*2x16*) or 8-bit (*4x8*) integer values.

Then, the results are packed into the returned 32-bit unsigned
integer.

The conversion for component _c_ of _v_ to fixed point is done as
follows:

*packUnorm2x16*: `round(clamp(c, 0, +1) * 65535.0)` +
*packSnorm2x16:* `round(clamp(c, -1, +1) * 32767.0)` +
*packUnorm4x8*: `round(clamp(c, 0, +1) * 255.0)` +
*packSnorm4x8*: `round(clamp(c, -1, +1) * 127.0)`

The first component of the vector will be written to the least
significant bits of the output; the last component will be written to
the most significant bits.

=== Unpack Unorm
[source,glsl]
----
ifdef::GLSL[]
vec2 unpackUnorm2x16(highp uint p)
vec2 unpackSnorm2x16(highp uint p)
vec4 unpackUnorm4x8(highp uint p)
vec4 unpackSnorm4x8(highp uint p)
endif::GLSL[]
ifdef::ESSL[]
highp vec2 unpackUnorm2x16(highp uint p)
highp vec2 unpackSnorm2x16(highp uint p)
mediump vec4 unpackUnorm4x8(highp uint p)
mediump vec4 unpackSnorm4x8(highp uint p)
endif::ESSL[]
----

First, unpacks a single 32-bit unsigned integer _p_ into a pair of
16-bit unsigned integers, a pair of 16-bit signed integers, four 8-bit
unsigned integers, or four 8-bit signed integers, respectively.

Then, each component is converted to a normalized floating-point value
to generate the returned two- or four-component vector.

The conversion for unpacked fixed-point value _f_ to floating-point is
done as follows:

*unpackUnorm2x16*: `_f_ / 65535.0` +
*unpackSnorm2x16*: `clamp(_f_ / 32767.0, -1, +1)` +
*unpackUnorm4x8*: `_f_ / 255.0` +
*unpackSnorm4x8*: `clamp(_f_ / 127.0, -1, +1)`

The first component of the returned vector will be extracted from the
least significant bits of the input; the last component will be
extracted from the most significant bits.

=== Pack Half 2x16
[source,glsl]
----
ifdef::GLSL[]
uint packHalf2x16(vec2 v)
endif::GLSL[]
ifdef::ESSL[]
highp uint packHalf2x16(mediump vec2 v)
endif::ESSL[]
----

Returns an unsigned integer obtained by converting the components of a
two-component floating-point vector to the 16-bit floating-point
representation of the <<references, API>>, and
then packing these two 16-bit integers into a 32-bit unsigned integer.

The first vector component specifies the 16 least-significant bits of
the result; the second component specifies the 16 most-significant
bits.

=== Unpack Half 2x16
[source,glsl]
----
ifdef::GLSL[]
vec2 unpackHalf2x16(uint v)
endif::GLSL[]
ifdef::ESSL[]
mediump vec2 unpackHalf2x16(highp uint v)
endif::ESSL[]
----

Returns a two-component floating-point vector with components obtained
by unpacking a 32-bit unsigned integer into a pair of 16-bit values,
interpreting those values as 16-bit floating-point numbers according
to the <<references, API>>, and converting them to
32-bit floating-point values.

The first component of the vector is obtained from the 16
least-significant bits of _v_; the second component is obtained from
the 16 most-significant bits of _v_.

ifdef::GLSL[]
=== Pack Double 2x32
[source,glsl]
----
double packDouble2x32(uvec2 v)
----

Returns a double-precision value obtained by packing the components of
_v_ into a 64-bit value.

If an IEEE 754 Inf or NaN is created, it will not signal, and the
resulting floating-point value is unspecified.

Otherwise, the bit-level representation of _v_ is preserved.
The first vector component specifies the 32 least significant bits;
the second component specifies the 32 most significant bits.

=== Unpack Double 2x32
[source,glsl]
----
uvec2 unpackDouble2x32(double v)
----

Returns a two-component unsigned integer vector representation of _v_.

The bit-level representation of _v_ is preserved.

The first component of the vector contains the 32 least significant
bits of the double; the second component consists of the 32 most
significant bits.
endif::GLSL[]


[[geometric-functions]]
== Geometric Functions

These operate on vectors as vectors, not component-wise.

=== Length
[source,glsl]
----
ifdef::GLSL[]
float length(genFType x)
double length(genDType x)
endif::GLSL[]
ifdef::ESSL[]
float length(genFType x)
endif::ESSL[]
----

Returns the length of vector _x_, i.e., [eq]#sqrt( x~0~^2^ + x~1~^2^ + ... )#.

=== Distance
[source,glsl]
----
ifdef::GLSL[]
float distance(genFType p0, genFType p1)
double distance(genDType p0, genDType p1)
endif::GLSL[]
ifdef::ESSL[]
float distance(genFType p0, genFType p1)
endif::ESSL[]
----

Returns the distance between _p0_ and _p1_, i.e., *length*(_p0_ - _p1_)

=== Dot
[source,glsl]
----
float dot(genFType x, genFType y)
ifdef::GLSL[]
double dot(genDType x, genDType y)
endif::GLSL[]
----

Returns the dot product of _x_ and _y_, i.e., [eq]#x~0~ {cdot} y~0~ + x~1~ {cdot} y~1~ + ...#

=== Cross
[source,glsl]
----
vec3 cross(vec3 x, vec3 y)
ifdef::GLSL[]
dvec3 cross(dvec3 x, dvec3 y)
endif::GLSL[]
----

Returns the cross product of _x_ and _y_, i.e.,
      [eq]#(x~1~ {cdot} y~2~ - y~1~ {cdot} x~2~,
            x~2~ {cdot} y~0~ - y~2~ {cdot} x~0~,
            x~0~ {cdot} y~1~ - y~0~ {cdot} x~1~)#.

=== Normalize
[source,glsl]
----
genFType normalize(genFType x)
ifdef::GLSL[]
genDType normalize(genDType x)
endif::GLSL[]
----

Returns a vector in the same direction as _x_ but with a length of 1, i.e. _x_ / *length*(x).

ifdef::GLSL[]
=== FTransform
Compatibility profile only

[source,glsl]
----
vec4 ftransform()
----

Available only when using the compatibility profile. For core {apiname}, use *invariant*.

For vertex shaders only. This function will ensure that the incoming vertex value will be
transformed in a way that produces exactly the same result as would be produced by {apiname}'s
fixed functionality transform. It is intended to be used to compute _gl_Position_, e.g.

[source,glsl]
----
gl_Position = ftransform()
----

This function should be used, for example, when an application is rendering the same geometry in
separate passes, and one pass uses the fixed functionality path to render and another pass uses
programmable shaders.
endif::GLSL[]

=== Face Forward
[source,glsl]
----
genFType faceforward(genFType N, genFType I, genFType Nref)
ifdef::GLSL[]
genDType faceforward(genDType N, genDType I, genDType Nref)
endif::GLSL[]
----

If *dot*(_Nref_, _I_) < 0 return _N_, otherwise return -_N_.

=== Reflect
[source,glsl]
----
genFType reflect(genFType I, genFType N)
ifdef::GLSL[]
genDType reflect(genDType I, genDType N)
endif::GLSL[]
----

For the incident vector _I_ and surface orientation _N_, returns the reflection direction:
[eq]#I - 2 {cdot} *dot*(N, I) {cdot} N#. _N_ must already be normalized in order to achieve
the desired result.

=== Refract
[source,glsl]
----
genFType refract(genFType I, genFType N, float eta)
ifdef::GLSL[]
genDType refract(genDType I, genDType N, double eta)
endif::GLSL[]
----

For the incident vector _I_ and surface normal _N_, and the ratio of indices of refraction
_eta_, return the refraction vector. The result is computed by the refraction equation shown below.

[latexmath]
++++
k = 1.0 - eta * eta * (1.0 - \textbf{dot}(N,I) \cdot \textbf{dot}(N,I))
++++

[latexmath]
++++
\begin{aligned}
result &=
  \begin{cases}
    genFType(0.0), & k < 0.0 \\
    eta * I - (eta * \textbf{dot}(N,I) + \sqrt { k }) * N, & \textbf{otherwise}
  \end{cases}
\end{aligned}
++++

The input parameters for the incident vector _I_ and the surface normal _N_ must already be
normalized to get the desired results.


[[matrix-functions]]
== Matrix Functions

For each of the following built-in matrix functions, there is both a
single-precision floating-point version, where all arguments and return
values are single precision, and a double-precision floating-point version,
where all arguments and return values are double precision.
Only the single-precision floating-point version is shown.

=== MatrixCompMult
[source,glsl]
----
mat matrixCompMult(mat x, mat y)
----

Multiply matrix _x_ by matrix _y_ component-wise, i.e., `result[i][j]`
is the scalar product of `_x_[i][j]` and `_y_[i][j]`.

NOTE: To get linear algebraic matrix multiplication, use the multiply operator (***).

=== OuterProduct
[source,glsl]
----
mat2 outerProduct(vec2 c, vec2 r)
mat3 outerProduct(vec3 c, vec3 r)
mat4 outerProduct(vec4 c, vec4 r)
mat2x3 outerProduct(vec3 c, vec2 r)
mat3x2 outerProduct(vec2 c, vec3 r)
mat2x4 outerProduct(vec4 c, vec2 r)
mat4x2 outerProduct(vec2 c, vec4 r)
mat3x4 outerProduct(vec4 c, vec3 r)
mat4x3 outerProduct(vec3 c, vec4 r)
----

Treats the first parameter _c_ as a column vector (matrix with one
column) and the second parameter _r_ as a row vector (matrix with one
row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a
matrix whose number of rows is the number of components in _c_ and
whose number of columns is the number of components in _r_.

=== Transpose
[source,glsl]
----
mat2 transpose(mat2 m)
mat3 transpose(mat3 m)
mat4 transpose(mat4 m)
mat2x3 transpose(mat3x2 m)

mat3x2 transpose(mat2x3 m)
mat2x4 transpose(mat4x2 m)
mat4x2 transpose(mat2x4 m)
mat3x4 transpose(mat4x3 m)
mat4x3 transpose(mat3x4 m)
----

Returns a matrix that is the transpose of _m_.

The input matrix _m_ is not modified.

=== Determinant
[source,glsl]
----
float determinant(mat2 m)
float determinant(mat3 m)
float determinant(mat4 m)
----

Returns the determinant of _m_.

=== Inverse
[source,glsl]
----
mat2 inverse(mat2 m)
mat3 inverse(mat3 m)
mat4 inverse(mat4 m)
----

Returns a matrix that is the inverse of _m_.

The input matrix _m_ is not modified.

The values in the returned matrix are undefined if _m_ is singular or
poorly-conditioned (nearly singular).


[[vector-relational-functions]]
== Vector Relational Functions

Relational and equality operators (*<*, *\<=*, *>*, *>=*, *==*, *!=*) are
defined to operate on scalars and produce scalar Boolean results.
For vector results, use the following built-in functions.
Below, the following placeholders are used for the listed specific types:

[options="header"]
|====
| Placeholder | Specific Types Allowed
| bvec        | bvec2, bvec3, bvec4
| ivec        | ivec2, ivec3, ivec4
| uvec        | uvec2, uvec3, uvec4
ifdef::GLSL[]
| vec         | vec2, vec3, vec4, dvec2, dvec3, dvec4
endif::GLSL[]
ifdef::ESSL[]
| vec         | vec2, vec3, vec4
endif::ESSL[]
|====

In all cases, the sizes of all the input and return vectors for any
particular call must match.

=== LessThan
[source,glsl]
----
bvec lessThan(vec x, vec y)
bvec lessThan(ivec x, ivec y)
bvec lessThan(uvec x, uvec y)
----

Returns the component-wise compare of [eq]#x < y#.

=== LessThanEqual
[source,glsl]
----
bvec lessThanEqual(vec x, vec y)
bvec lessThanEqual(ivec x, ivec y)
bvec lessThanEqual(uvec x, uvec y)
----

Returns the component-wise compare of [eq]#x {leq} y#.

=== GreaterThan
[source,glsl]
----
bvec greaterThan(vec x, vec y)
bvec greaterThan(ivec x, ivec y)
bvec greaterThan(uvec x, uvec y)
----

Returns the component-wise compare of [eq]#x > y#.

=== GreaterThanEqual
[source,glsl]
----
bvec greaterThanEqual(vec x, vec y)
bvec greaterThanEqual(ivec x, ivec y)
bvec greaterThanEqual(uvec x, uvec y)
----

Returns the component-wise compare of [eq]#x {geq} y#.

=== Equal
[source,glsl]
----
bvec equal(vec x, vec y)
bvec equal(ivec x, ivec y)
bvec equal(uvec x, uvec y)
bvec equal(bvec x, bvec y)
----

Returns the component-wise compare of [eq]#x == y#.

=== NotEqual
[source,glsl]
----
bvec notEqual(vec x, vec y)
bvec notEqual(ivec x, ivec y)
bvec notEqual(uvec x, uvec y)
bvec notEqual(bvec x, bvec y)
----

Returns the component-wise compare of [eq]#x {neq} y#.

=== Any
[source,glsl]
----
bool any(bvec x)
----

Returns *true* if any component of _x_ is *true*.

=== All
[source,glsl]
----
bool all(bvec x)
----

Returns *true* only if all components of _x_ are *true*.

=== Not
[source,glsl]
----
bvec not(bvec x)
----

Returns the component-wise logical complement of _x_.



[[integer-functions]]
== Integer Functions

These all operate component-wise.
The description is per component.
The notation [_a_, _b_] means the set of bits from bit-number _a_ through
bit-number _b_, inclusive.
The lowest-order bit is bit 0.
"`Bit number`" will always refer to counting up from the lowest-order bit as
bit 0.

=== UAddCarry
[source,glsl]
----
genUType uaddCarry(highp genUType x, highp genUType y, out lowp genUType carry)
----

Adds 32-bit unsigned integers _x_ and _y_, returning the sum modulo 2^32^.

The value _carry_ is set to zero if the sum was less than 2^32^, or one otherwise.

=== USubBorrow
[source,glsl]
----
genUType usubBorrow(highp genUType x, highp genUType y, out lowp genUType borrow)
----

Subtracts the 32-bit unsigned integer _y_ from _x_, returning the difference if non-negative, or
2^32^ plus the difference otherwise.

The value _borrow_ is set to zero if [eq]#x {geq} y#, or one otherwise.

===  Mul Extended
[source,glsl]
----
void umulExtended(highp genUType x,
                  highp genUType y,
                  out highp genUType msb,
                  out highp genUType lsb)
void imulExtended(highp genIType x,
                  highp genIType y,
                  out highp genIType msb,
                  out highp genIType lsb)
----

Multiplies 32-bit unsigned or signed integers _x_ and _y_, producing a 64-bit result.

 * The 32 least-significant bits are returned in _lsb_.
 * The 32 most-significant bits are returned in _msb_.

=== BitfieldExtract
[source,glsl]
----
genIType bitfieldExtract(genIType value, int offset, int bits)
genUType bitfieldExtract(genUType value, int offset, int bits)
----

Extracts bits [eq]#[offset, offset + bits - 1]# from _value_, returning them in the least
significant bits of the result.

For unsigned data types, the most significant bits of the result will be set to zero.
For signed data types, the most significant bits will be set to the value of bit
[eq]#offset + bits - 1#.

If _bits_ is zero, the result will be zero. The result will be undefined if _offset_ or _bits_ is
negative, or if the sum of _offset_ and _bits_ is greater than the number of bits used to store the
operand.

Note that for vector versions of *bitfieldExtract*(), a single pair of _offset_ and _bits_ values
is shared for all components.

=== BitfieldInsert
[source,glsl]
----
genIType bitfieldInsert(genIType base, genIType insert, int offset, int bits)
genUType bitfieldInsert(genUType base, genUType insert, int offset, int bits)
----

Inserts the _bits_ least significant bits of _insert_ into _base_.

The result will have bits [eq]#[offset, offset + bits - 1]# taken from bits [eq]#[0, bits - 1]# of
_insert_, and all other bits taken directly from the corresponding bits of _base_.
If _bits_ is zero, the result will simply be _base_. The result will be undefined if _offset_ or
_bits_ is negative, or if the sum of _offset_ and _bits_ is greater than the number of bits used
to store the operand.

Note that for vector versions of *bitfieldInsert*(), a single pair of _offset_ and _bits_ values is
shared for all components.

=== BitfieldReverse
[source,glsl]
----
genIType bitfieldReverse(highp genIType value)
genUType bitfieldReverse(highp genUType value)
----

Reverses the bits of _value_.

The bit numbered _n_ of the result will be taken from bit [eq]#(bits -1) - n# of _value_, where
_bits_ is the total number of bits used to represent _value_.

=== BitCount
[source,glsl]
----
ifdef::GLSL[]
genIType bitCount(genIType value)
genIType bitCount(genUType value)
endif::GLSL[]
ifdef::ESSL[]
lowp genIType bitCount(genIType value)
lowp genIType bitCount(genUType value)
endif::ESSL[]
----

Returns the number of one bits in the binary representation of _value_.

=== FindLSB
[source,glsl]
----
ifdef::GLSL[]
genIType findLSB(genIType value)
genIType findLSB(genUType value)
endif::GLSL[]
ifdef::ESSL[]
lowp genIType findLSB(genIType value)
lowp genIType findLSB(genUType value)
endif::ESSL[]
----

Returns the bit number of the least significant one bit in the binary representation of _value_.

If _value_ is zero, -1 will be returned.

=== FindMSB
[source,glsl]
----
ifdef::GLSL[]
genIType findMSB(highp genIType value)
genIType findMSB(highp genUType value)
endif::GLSL[]
ifdef::ESSL[]
lowp genIType findMSB(highp genIType value)
lowp genIType findMSB(highp genUType value)
endif::ESSL[]

----

Returns the bit number of the most significant bit in the binary representation of _value_.

For positive integers, the result will be the bit number of the most significant one bit.
For negative integers, the result will be the bit number of the most significant zero bit.
For a _value_ of zero or negative one, -1 will be returned.


[[texture-functions]]
== Texture Functions

Texture lookup functions are available in all shading stages.
However, level-of-detail is implicitly computed only for fragment shaders.
Other shaders operate as though the base level-of-detail were computed as
zero.
The functions in the table below provide access to textures through
texture-combined samplers, as set up through the API.
Texture properties such as size, pixel format, number of dimensions,
filtering method, number of mipmap levels, depth comparison, and so on are
also defined by API calls.
Such properties are taken into account as the texture is accessed via the
built-in functions defined below.

Texture data can be stored by the GL as single-precision floating-point,
normalized integer, unsigned integer or signed integer data.
This is determined by the type of the internal format of the texture.

Texture lookup functions are provided that can return their result as
floating-point, unsigned integer or signed integer, depending on the sampler
type passed to the lookup function.
Care must be taken to use the right sampler type for texture access.
The following table lists the supported combinations of sampler types and
texture internal formats.
Blank entries are unsupported.
Doing a texture lookup will return undefined values for unsupported
combinations.

For depth/stencil textures, the internal texture format is determined by the
component being accessed as set through the API.
When the depth/stencil texture mode is set to DEPTH_COMPONENT, the internal
format of the depth component should be used.
When the depth/stencil texture mode is set to STENCIL_INDEX, the internal format
of the stencil component should be used.

[options="header"]
|====
| Internal Texture Format | Floating-Point Sampler Types | Signed Integer Sampler Types | Unsigned Integer Sampler Types
| Floating-point          | Supported                    |                              |
| Normalized Integer      | Supported                    |                              |
| Signed Integer          |                              | Supported                    |
| Unsigned Integer        |                              |                              | Supported
|====

If an integer sampler type is used, the result of a texture lookup is an
*ivec4*.
If an unsigned integer sampler type is used, the result of a texture lookup
is a *uvec4*.
If a floating-point sampler type is used, the result of a texture lookup is
a *vec4*.

In the prototypes below, the `g` in the return type `gvec4` is used
as a placeholder for either nothing, `i`, or `u` making a return type of
*vec4*, *ivec4*, or *uvec4*.
In these cases, the sampler argument type also starts with `g`,
indicating the same substitution done on the return type; it is either a
ifdef::GLSL[single-precision]
floating-point, signed integer, or unsigned integer sampler, matching the
basic type of the return type, as described above.

For shadow forms (the sampler parameter is a shadow-type), a depth
comparison lookup on the depth texture bound to _sampler_ is done as
described in section
ifdef::GLSL[8.23]
ifdef::ESSL[8.20]
"`Texture Comparison Modes`" of the
<<references,{apispec}>>.
See the table below for which component specifies _D~ref~_.
The texture bound to _sampler_ must be a depth texture, or results are
undefined.
If a non-shadow texture call is made to a sampler that represents a depth
texture with depth comparisons turned on, then results are undefined.
If a shadow texture call is made to a sampler that represents a depth
texture with depth comparisons turned off, then results are undefined.
If a shadow texture call is made to a sampler that does not represent a
depth texture, then results are undefined.

In all functions below, the _bias_ parameter is optional for fragment
shaders.
The _bias_ parameter is not accepted in any other shader stage.
For a fragment shader, if _bias_ is present, it is added to the implicit
level-of-detail prior to performing the texture access operation.
No _bias_ or _lod_ parameters for
ifdef::GLSL[rectangle textures,]
multisample textures, or texture buffers
are supported because mipmaps are not allowed for these types of textures.

The implicit level-of-detail is selected as follows: For a texture that is
not mipmapped, the texture is used directly.
If it is mipmapped and running in a fragment shader, the level-of-detail
computed by the implementation is used to do the texture lookup.
If it is mipmapped and running in a non-fragment shader, then the base
texture is used.

Some texture functions (non-"`*Lod*`" and non-"`*Grad*`" versions) may
require implicit derivatives.
Implicit derivatives are undefined within non-uniform control flow and for
non-fragment shader texture fetches.

For *Cube* forms, the direction of _P_ is used to select which face to do a
2-dimensional texture lookup in, as described in section 8.13 "`Cube Map
Texture Selection`" of the <<references,{apispec}>>.

For *Array* forms, the array layer used will be

latexmath:[\max(0,\min(d-1,\left\lfloor layer + 0.5\right\rfloor))]

where _d_ is the depth of the texture array and _layer_ comes from the
component indicated in the tables below.


[[texture-query-functions]]
=== Texture Query Functions

The *textureSize* functions query the dimensions of a specific texture level
for a texture-combined sampler.

ifdef::GLSL[]
The *textureQueryLod* functions are available only in a fragment shader.
They take the components of _P_ and compute the level-of-detail information
that the texture pipe would use to access that texture through a normal
texture lookup.
The level-of-detail latexmath:[\lambda^{'}] (equation 3.18 of the
<<references,{apispec}>>) is obtained after any level-of-detail bias, but
prior to clamping to [TEXTURE_MIN_LOD, TEXTURE_MAX_LOD].
The mipmap array(s) that would be accessed are also computed.
If a single level-of-detail would be accessed, the level-of-detail number
relative to the base level is returned.
If multiple levels-of-detail would be accessed, a floating-point number
between the two levels is returned, with the fractional part equal to the
fractional part of the computed and clamped level-of-detail.

The algorithm used is given by the following pseudo-code:

[source,glsl]
----
float ComputeAccessedLod(float computedLod)
{
    // Clamp the computed LOD according to the texture LOD clamps.
    if (computedLod < TEXTURE_MIN_LOD) computedLod = TEXTURE_MIN_LOD;
    if (computedLod > TEXTURE_MAX_LOD) computedLod = TEXTURE_MAX_LOD;

    // Clamp the computed LOD to the range of accessible levels.
    if (computedLod < 0.0)
        computedLod = 0.0;
    if (computedLod > (float) maxAccessibleLevel)
        computedLod = (float) maxAccessibleLevel;

    // Return a value according to the min filter.
    if (TEXTURE_MIN_FILTER is LINEAR or NEAREST) {
        return 0.0;
    } else if (TEXTURE_MIN_FILTER is NEAREST_MIPMAP_NEAREST
               or LINEAR_MIPMAP_NEAREST) {
        return ceil(computedLod + 0.5) - 1.0;
    } else {
        return computedLod;
    }
}
----

The value _maxAccessibleLevel_ is the level number of the smallest
accessible level of the mipmap array (the value _q_ in section 8.14.3
"`Mipmapping`" of the <<references,{apispec}>>) minus the base level.
endif::GLSL[]

==== TextureSize
[source,glsl]
----
ifdef::GLSL[]
int textureSize(gsampler1D sampler, int lod)
ivec2 textureSize(gsampler2D sampler, int lod)
ivec3 textureSize(gsampler3D sampler, int lod)
ivec2 textureSize(gsamplerCube sampler, int lod)
int textureSize(sampler1DShadow sampler, int lod)
ivec2 textureSize(sampler2DShadow sampler, int lod)
ivec2 textureSize(samplerCubeShadow sampler, in lod)
ivec3 textureSize(gsamplerCubeArray sampler, int lod)
ivec3 textureSize(samplerCubeArrayShadow sampler, int lod)
ivec2 textureSize(gsampler1DArray sampler, int lod)
ivec2 textureSize(sampler1DArrayShadow sampler, int lod)
ivec3 textureSize(gsampler2DArray sampler, int lod)
ivec3 textureSize(sampler2DArrayShadow sampler, int lod)
ivec2 textureSize(gsamler2DRect sampler)
ivec2 textureSize(sampler2DRectShadow sampler)
int textureSize(gsamplerBuffer sampler)
ivec2 textureSize(gsampler2DMS sampler)
ivec3 textureSize(gsampler2DMSArray sampler)
endif::GLSL[]
ifdef::ESSL[]
highp ivec2 textureSize(gsampler2D sampler, int lod)
highp ivec3 textureSize(gsampler3D sampler, int lod)
highp ivec2 textureSize(gsamplerCube sampler, int lod)
highp ivec2 textureSize(sampler2DShadow sampler, int lod)
highp ivec2 textureSize(samplerCubeShadow sampler, in lod)
highp ivec3 textureSize(gsamplerCubeArray sampler, int lod)
highp ivec3 textureSize(samplerCubeArrayShadow sampler, int lod)
highp ivec3 textureSize(gsampler2DArray sampler, int lod)
highp ivec3 textureSize(sampler2DArrayShadow sampler, int lod)
highp int textureSize(gsamplerBuffer sampler)
highp ivec2 textureSize(gsampler2DMS sampler)
highp ivec3 textureSize(gsampler2DMSArray sampler)
endif::ESSL[]
----

Returns the dimensions of level _lod_ (if present) for the texture bound to _sampler_, as described
in section 11.1.3.4 "`Texture Queries`" of the <<references,{apispec}>>.

The components in the return value are filled in, in order, with the width, height, and depth of
the texture.

For the array forms, the last component of the return value is the number of layers in the texture
array, or the number of cubes in the texture cube map array.

ifdef::GLSL[]
==== TextureQueryLod
[source,glsl]
----
vec2 textureQueryLod(gsampler1D sampler, float P)
vec2 textureQueryLod(gsampler2D sampler, vec2 P)
vec2 textureQueryLod(gsampler3D sampler, vec3 P)
vec2 textureQueryLod(gsamplerCube sampler, vec3 P)
vec2 textureQueryLod(gsampler1DArray sampler, float P)
vec2 textureQueryLod(gsampler2DArray sampler, vec2 P)
vec2 textureQueryLod(gsamplerCubeArray sampler, vec3 P)
vec2 textureQueryLod(sampler1DShadow sampler, float P)
vec2 textureQueryLod(sampler2DShadow sampler, vec2 P)
vec2 textureQueryLod(samplerCubeShadow sampler, vec3 P)
vec2 textureQueryLod(sampler1DArrayShadow sampler, float P)
vec2 textureQueryLod(sampler2DArrayShadow sampler, vec2 P)
vec2 textureQueryLod(samplerCubeArrayShadow sampler, vec P)
----

Returns the mipmap array(s) that would be accessed in the _x_ component of the return value.

Returns the computed level-of-detail relative to the base level in the _y_ component of the return
value.

If called on an incomplete texture, the results are undefined.
endif::GLSL[]

ifdef::GLSL[]
==== TextureQueryLevels
[source,glsl]
----
int textureQueryLevels(gsampler1D sampler)
int textureQueryLevels(gsampler2D sampler)
int textureQueryLevels(gsampler3D sampler)
int textureQueryLevels(gsamplerCube sampler)
int textureQueryLevels(gsampler1DArray sampler)
int textureQueryLevels(gsampler2DArray sampler)
int textureQueryLevels(gsamplerCubeArray sampler)
int textureQueryLevels(sampler1DShadow sampler)
int textureQueryLevels(sampler2DShadow sampler)
int textureQueryLevels(samplerCubeShadow sampler)
int textureQueryLevels(sampler1DArrayShadow sampler)
int textureQueryLevels(sampler2DArrayShadow sampler)
int textureQueryLevels(samplerCubeArrayShadow sampler)
----

Returns the number of mipmap levels accessible in the texture associated with _sampler_, as defined
in the <<references,{apispec}.>>

The value zero will be returned if no texture or an incomplete texture is associated with _sampler_.

Available in all shader stages.
endif::GLSL[]

ifdef::GLSL[]
==== TextureSamples
[source,glsl]
----
int textureSamples(gsampler2DMS sampler)
int textureSamples(gsampler2DMSArray sampler)
----

Returns the number of samples of the texture bound to _sampler_.
endif::GLSL[]


[[texel-lookup-functions]]
=== Texel Lookup Functions

==== Texture
[source,glsl]
----
ifdef::GLSL[]
gvec4 texture(gsampler1D sampler, float P [, float bias])
endif::GLSL[]
gvec4 texture(gsampler2D sampler, vec2 P [, float bias])
gvec4 texture(gsampler3D sampler, vec3 P [, float bias])
gvec4 texture(gsamplerCube sampler, vec3 P [, float bias])
ifdef::GLSL[]
float texture(sampler1DShadow sampler, vec3 P [, float bias])
endif::GLSL[]
float texture(sampler2DShadow sampler, vec3 P [, float bias])
float texture(samplerCubeShadow sampler, vec4 P [, float bias])
gvec4 texture(gsampler2DArray sampler, vec3 P [, float bias])
gvec4 texture(gsamplerCubeArray sampler, vec4 P [, float bias])
ifdef::GLSL[]
gvec4 texture(gsampler1DArray sampler, vec2 P [, float bias])
float texture(sampler1DArrayShadow sampler, vec3 P [, float bias])
endif::GLSL[]
float texture(sampler2DArrayShadow sampler, vec4 P)
ifdef::GLSL[]
gvec4 texture(gsampler2DRect sampler, vec2 P)
float texture(sampler2DRectShadow sampler, vec3 P)
endif::GLSL[]
float texture(samplerCubeArrayShadow sampler, vec4 P, float compare)
----

Use the texture coordinate _P_ to do a texture lookup in the texture currently bound to _sampler_.

For shadow forms: When _compare_ is present, it is used as _D~ref~_ and the array layer comes from
the last component of _P_. When _compare_ is not present, the last component of _P_ is used as
_D~ref~_ and the array layer comes from the second to last component of _P_.
ifdef::GLSL[]
(The second component of _P_ is unused for *1D* shadow lookups.)
endif::GLSL[]

For non-shadow forms: the array layer comes from the last component of _P_.

==== TextureProj
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureProj(gsampler1D sampler, vec2 P [, float bias])
gvec4 textureProj(gsampler1D sampler, vec4 P [, float bias])
endif::GLSL[]
gvec4 textureProj(gsampler2D sampler, vec3 P [, float bias])
gvec4 textureProj(gsampler2D sampler, vec4 P [, float bias])
gvec4 textureProj(gsampler3D sampler, vec4 P [, float bias])
ifdef::GLSL[]
float textureProj(sampler1DShadow sampler, vec4 P [, float bias])
endif::GLSL[]
float textureProj(sampler2DShadow sampler, vec4 P [, float bias])
ifdef::GLSL[]
gvec4 textureProj(gsampler2DRect sampler, vec3 P)
gvec4 textureProj(gsampler2DRect sampler, vec4 P)
float textureProj(sampler2DRectShadow sampler, vec4 P)
endif::GLSL[]
----

Do a texture lookup with projection.

The texture coordinates consumed from _P_, not including the last component of _P_, are divided by
the last component of _P_ to form projected coordinates _P'_. The resulting third component of _P_
in the shadow forms is used as _D~ref~_. The third component of _P_ is ignored when _sampler_ has
type *gsampler2D* and _P_ has type *vec4*. After these values are computed, texture lookup proceeds
as in *texture*.

==== TextureLod
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureLod(gsampler1D sampler, float P float lod)
endif::GLSL[]
gvec4 textureLod(gsampler2D sampler, vec2 P, float lod)
gvec4 textureLod(gsampler3D sampler, vec3 P, float lod)
gvec4 textureLod(gsamplerCube sampler, vec3 P, float lod)
float textureLod(sampler2DShadow sampler, vec3 P, float lod)
ifdef::GLSL[]
float textureLod(sampler1DShadow sampler, vec3 P, float lod)
gvec4 textureLod(gsampler1DArray sampler, vec2 P, float lod)
float textureLod(sampler1DArrayShadow sampler, vec3 P, float lod)
endif::GLSL[]
gvec4 textureLod(gsampler2DArray sampler, vec3 P, float lod)
gvec4 textureLod(gsamplerCubeArray sampler, vec4 P, float lod)
----

Do a texture lookup as in *texture* but with explicit level-of-detail; _lod_ specifies
[eq]#{lambda}~base~]# and sets the partial derivatives as follows:

(See section 8.14 "`Texture Minification`" and equations 8.4-8.6 of the <<references,{apispec}>>.)

[eq]#{partial}u / {partial}x =
      {partial}v / {partial}x =
      {partial}w / {partial}x = 0#

[eq]#{partial}u / {partial}y =
      {partial}v / {partial}y =
      {partial}w / {partial}y = 0#

==== TextureOffset
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureOffset(gsampler1D sampler, float P, int offset [, float bias])
endif::GLSL[]
gvec4 textureOffset(gsampler2D sampler, vec2 P, ivec2 offset [, float bias])
gvec4 textureOffset(gsampler3D sampler, vec3 P, ivec3 offset [, float bias])
float textureOffset(sampler2DShadow sampler, vec3 P, ivec2 offset [, float bias])
ifdef::GLSL[]
gvec4 textureOffset(gsampler2DRect sampler, vec2 P, ivec2 offset)
float textureOffset(sampler2DRectShadow sampler, vec3 P, ivec2 offset)
float textureOffset(sampler1DShadow sampler, vec3 P, int offset [, float bias])
gvec4 textureOffset(gsampler1DArray sampler, vec2 P, int offset [, float bias])
endif::GLSL[]
gvec4 textureOffset(gsampler2DArray sampler, vec3 P, ivec2 offset [, float bias])
ifdef::GLSL[]
float textureOffset(sampler1DArrayShadow sampler, vec3 P, int offset [, float bias])
float textureOffset(sampler2DArrayShadow sampler, vec4 P, ivec2 offset)
endif::GLSL[]
----

Do a texture lookup as in *texture* but with _offset_ added to the [eq]#(u,v,w)# texel coordinates
before looking up each texel. The offset value must be a constant expression. A limited range of
offset values are supported; the minimum and maximum offset values are implementation-dependent and
given by _gl_MinProgramTexelOffset_ and _gl_MaxProgramTexelOffset_, respectively.

Note that _offset_ does not apply to the layer coordinate for texture arrays.

This is explained in detail in section 8.14.2 "`Coordinate Wrapping and Texel Selection`" of the
<<references,{apispec}>>, where _offset_ is [eq]#({delta}~u~, {delta}~v~, {delta}~w~)#.

Note that texel offsets are also not supported for cube maps.

==== TexelFetch
[source,glsl]
----
ifdef::GLSL[]
gvec4 texelFetch(gsampler1D sampler, int P, int lod)
endif::GLSL[]
gvec4 texelFetch(gsampler2D sampler, ivec2 P, int lod)
gvec4 texelFetch(gsampler3D sampler, ivec3 P, int lod)
ifdef::GLSL[]
gvec4 texelFetch(gsampler2DRect sampler, ivec2 P)
gvec4 texelFetch(gsampler1DArray sampler, ivec2 P, int lod)
endif::GLSL[]
gvec4 texelFetch(gsampler2DArray sampler, ivec3 P, int lod)
gvec4 texelFetch(gsamplerBuffer sampler, int P)
gvec4 texelFetch(gsampler2DMS sampler, ivec2 P, int sample)
gvec4 texelFetch(gsampler2DMSArray sampler, ivec3 P, int sample)
----

Use integer texture coordinate _P_ to lookup a single texel from _sampler_. The array layer comes
from the last component of _P_ for the array forms. The level-of-detail _lod_ (if present) is as
described in sections 11.1.3.2 "`Texel Fetches`" and 8.14.1 "`Scale Factor and Level of Detail`" of
the <<references,{apispec}>>.

==== TexelFetchOffset
[source,glsl]
----
ifdef::GLSL[]
gvec4 texelFetchOffset(gsampler1D sampler, int P, int lod, int offset)
endif::GLSL[]
gvec4 texelFetchOffset(gsampler2D sampler, ivec2 P, int lod, ivec2 offset)
gvec4 texelFetchOffset(gsampler3D sampler, ivec3 P, int lod, ivec3 offset)
ifdef::GLSL[]
gvec4 texelFetchOffset(gsampler2DRect sampler, ivec2 P, ivec2 offset)
gvec4 texelFetchOffset(gsampler1DArray sampler, ivec2 P, int lod, int offset)
endif::GLSL[]
gvec4 texelFetchOffset(gsampler2DArray sampler, ivec3 P, int lod, ivec2 offset)
----

Fetch a single texel as in *texelFetch*, offset by _offset_ as described in *textureOffset*.

==== TextureProjOffset
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureProjOffset(gsampler1D sampler, vec2 P, int offset [, float bias])
gvec4 textureProjOffset(gsampler1D sampler, vec4 P, int offset [, float bias])
endif::GLSL[]
gvec4 textureProjOffset(gsampler2D sampler, vec3 P, ivec2 offset [, float bias])
gvec4 textureProjOffset(gsampler2D sampler, vec4 P, ivec2 offset [, float bias])
gvec4 textureProjOffset(gsampler3D sampler, vec4 P, ivec3 offset [, float bias])
ifdef::GLSL[]
gvec4 textureProjOffset(gsampler2DRect sampler, vec3 P, ivec2 offset)
gvec4 textureProjOffset(gsampler2DRect sampler, vec4 P, ivec2 offset)
float textureProjOffset(sampler2DRectShadow sampler, vec4 P, ivec2 offset)
float textureProjOffset(sampler1DShadow sampler, vec4 P, int offset [, float bias])
endif::GLSL[]
float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset [, float bias])
----

Do a projective texture lookup as described in *textureProj*, offset by _offset_ as described in
*textureOffset*.

==== TextureLodOffset
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureLodOffset(gsampler1D sampler, float P, float lod, int offset)
endif::GLSL[]
gvec4 textureLodOffset(gsampler2D sampler, vec2 P, float lod, ivec2 offset)
gvec4 textureLodOffset(gsampler3D sampler, vec3 P, float lod, ivec3 offset)
ifdef::GLSL[]
float textureLodOffset(sampler1DShadow sampler, vec3 P, float lod, int offset)
endif::GLSL[]
float textureLodOffset(sampler2DShadow sampler, vec3 P, float lod, ivec2 offset)
ifdef::GLSL[]
gvec4 textureLodOffset(gsampler1DArray sampler, vec2 P, float lod, int offset)
endif::GLSL[]
gvec4 textureLodOffset(gsampler2DArray sampler, vec3 P, float lod, ivec2 offset)
ifdef::GLSL[]
float textureLodOffset(sampler1DArrayShadow sampler, vec3 P, float lod, int offset)
endif::GLSL[]
----

Do an offset texture lookup with explicit level-of-detail. See *textureLod* and *textureOffset*.

==== TextureProjLod
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureProjLod(gsampler1D sampler, vec2 P, float lod)
gvec4 textureProjLod(gsampler1D sampler, vec4 P, float lod)
endif::GLSL[]
gvec4 textureProjLod(gsampler2D sampler, vec3 P, float lod)
gvec4 textureProjLod(gsampler2D sampler, vec4 P, float lod)
gvec4 textureProjLod(gsampler3D sampler, vec4 P, float lod)
ifdef::GLSL[]
float textureProjLod(sampler1DShadow sampler, vec4 P, float lod)
endif::GLSL[]
float textureProjLod(sampler2DShadow sampler, vec4 P, float lod)
----

Do a projective texture lookup with explicit level-of-detail. See *textureProj* and *textureLod*.

==== TextureProdLodOffset
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureProjLodOffset(gsampler1D sampler, vec2 P, float lod, int offset)
gvec4 textureProjLodOffset(gsampler1D sampler, vec4 P, float lod, int offset)
endif::GLSL[]
gvec4 textureProjLodOffset(gsampler2D sampler, vec3 P, float lod, ivec2 offset)
gvec4 textureProjLodOffset(gsampler2D sampler, vec4 P, float lod, ivec2 offset)
gvec4 textureProjLodOffset(gsampler3D sampler, vec4 P, float lod, ivec3 offset)
ifdef::GLSL[]
float textureProjLodOffset(sampler1DShadow sampler, vec4 P, float lod, int offset)
endif::GLSL[]
float textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset)
----

Do an offset projective texture lookup with explicit level-of-detail. See *textureProj*,
*textureLod*, and *textureOffset*.

==== TextureGrad
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureGrad(gsampler1D sampler, float P, float dPdx, float dPdy)
endif::GLSL[]
gvec4 textureGrad(gsampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy)
gvec4 textureGrad(gsampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy)
gvec4 textureGrad(gsamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy)
ifdef::GLSL[]
gvec4 textureGrad(gsampler2DRect sampler, vec2 P, vec2 dPdx, vec2 dPdy)
float textureGrad(sampler2DRectShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy)
float textureGrad(sampler1DShadow sampler, vec3 P, float dPdx, float dPdy)
gvec4 textureGrad(gsampler1DArray sampler, vec2 P, float dPdx, float dPdy)
float textureGrad(sampler1DArrayShadow sampler, vec3 P, float dPdx, float dPdy)
endif::GLSL[]
float textureGrad(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy)
float textureGrad(samplerCubeShadow sampler, vec4 P, vec3 dPdx, vec3 dPdy)
gvec4 textureGrad(gsampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy)
float textureGrad(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)
gvec4 textureGrad(gsamplerCubeArray sampler, vec4 P, vec3 dPdx, vec3 dPdy)
----

Do a texture lookup as in *texture* but with <<explicit-gradients, explicit gradients>> as shown
below. The partial derivatives of _P_ are with respect to window _x_ and window _y_.

For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system
used before texture coordinates are projected onto the appropriate cube face.

[[explicit-gradients]]
===== Explicit Gradients

ifdef::GLSL[]
[latexmath]
++++
\begin{aligned}
  \frac{\partial{s}}{\partial{x}} & =
    \begin{cases}
      \frac{\partial{P}}{\partial{x}}, & \text{for a 1D texture} \\[0.8em]
      \frac{\partial{P.s}}{\partial{x}}, & \text{otherwise}
    \end{cases} \\[2.5em]
  \frac{\partial{s}}{\partial{y}} & =
    \begin{cases}
      \frac{\partial{P}}{\partial{y}}, & \text{for a 1D texture} \\[0.8em]
      \frac{\partial{P.s}}{\partial{y}}, & \text{otherwise}
    \end{cases} \\[2.5em]
  \frac{\partial{t}}{\partial{x}} & =
    \begin{cases}
      0.0,                               & \text{for a 1D texture} \\[0.8em]
      \frac{\partial{P.t}}{\partial{x}}, & \text{otherwise}
    \end{cases} \\[2.5em]
  \frac{\partial{t}}{\partial{y}} & =
    \begin{cases}
      0.0,                               & \text{for a 1D texture} \\[0.8em]
      \frac{\partial{P.t}}{\partial{y}}, & \text{otherwise}
    \end{cases} \\[2.5em]
  \frac{\partial{r}}{\partial{x}} & =
    \begin{cases}
      0.0,                               & \text{for 1D or 2D} \\[0.8em]
      \frac{\partial{P.p}}{\partial{x}}, & \text{cube, other}
    \end{cases} \\[2.5em]
  \frac{\partial{r}}{\partial{y}} & =
    \begin{cases}
      0.0,                               & \text{for 1D or 2D} \\[0.8em]
      \frac{\partial{P.p}}{\partial{y}}, & \text{cube, other}
    \end{cases}
\end{aligned}
++++
endif::GLSL[]
ifdef::ESSL[]
[latexmath]
++++
\begin{aligned}
  \frac{\partial{s}}{\partial{x}} & = \frac{\partial{P.s}}{\partial{x}} \\[0.8em]
  \frac{\partial{s}}{\partial{y}} & = \frac{\partial{P.s}}{\partial{y}} \\[0.8em]
  \frac{\partial{t}}{\partial{x}} & = \frac{\partial{P.t}}{\partial{x}} \\[0.8em]
  \frac{\partial{t}}{\partial{y}} & = \frac{\partial{P.t}}{\partial{y}} \\[0.8em]
  \frac{\partial{r}}{\partial{x}} & =
    \begin{cases}
      0.0,                               & \text{for 2D} \\[0.8em]
      \frac{\partial{P.p}}{\partial{x}}, & \text{cube, other}
    \end{cases} \\[2.5em]
  \frac{\partial{r}}{\partial{y}} & =
    \begin{cases}
      0.0,                               & \text{for 2D} \\[0.8em]
      \frac{\partial{P.p}}{\partial{y}}, & \text{cube, other}
    \end{cases}
\end{aligned}
++++
endif::ESSL[]

==== TextureGradOffset
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureGradOffset(gsampler1D sampler, float P, float dPdx, float dPdy, int offset)
endif::GLSL[]
gvec4 textureGradOffset(gsampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
gvec4 textureGradOffset(gsampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy, ivec3 offset)
ifdef::GLSL[]
gvec4 textureGradOffset(gsampler2DRect sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
float textureGradOffset(sampler2DRectShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
float textureGradOffset(sampler1DShadow sampler, vec3 P, float dPdx, float dPdy, int offset)
endif::GLSL[]
float textureGradOffset(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
gvec4 textureGradOffset(gsampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
ifdef::GLSL[]
gvec4 textureGradOffset(gsampler1DArray sampler, vec2 P, float dPdx, float dPdy, int offset)
float textureGradOffset(sampler1DArrayShadow sampler, vec3 P, float dPdx, float dPdy, int offset)
endif::GLSL[]
float textureGradOffset(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
----

Do a texture lookup with both explicit gradient and offset, as described in *textureGrad* and
*textureOffset*.

==== TextureProjGrad
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureProjGrad(gsampler1D sampler, vec2 P, float dPdx, float dPdy)
gvec4 textureProjGrad(gsampler1D sampler, vec4 P, float dPdx, float dPdy)
endif::GLSL[]
gvec4 textureProjGrad(gsampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy)
gvec4 textureProjGrad(gsampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy)
gvec4 textureProjGrad(gsampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy)
ifdef::GLSL[]
gvec4 textureProjGrad(gsampler2DRect sampler, vec3 P, vec2 dPdx, vec2 dPdy)
gvec4 textureProjGrad(gsampler2DRect sampler, vec4 P, vec2 dPdx, vec2 dPdy)
float textureProjGrad(sampler2DRectShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)
float textureProjGrad(sampler1DShadow sampler, vec4 P, float dPdx, float dPdy)
endif::GLSL[]
float textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)
----

Do a texture lookup both projectively, as described in *textureProj*, and with explicit gradient as
described in *textureGrad*. The partial derivatives _dPdx_ and _dPdy_ are assumed to be already
projected.

==== TextureProjGradOffset
[source,glsl]
----
ifdef::GLSL[]
gvec4 textureProjGradOffset(gsampler1D sampler, vec2 P, float dPdx, float dPdy, int offset)
gvec4 textureProjGradOffset(gsampler1D sampler, vec4 P, float dPdx, float dPdy, int offset)
endif::GLSL[]
gvec4 textureProjGradOffset(gsampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
gvec4 textureProjGradOffset(gsampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
gvec4 textureProjGradOffset(gsampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset)
ifdef::GLSL[]
gvec4 textureProjGradOffset(gsampler2DRect sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
gvec4 textureProjGradOffset(gsampler2DRect sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
float textureProjGradOffset(sampler2DRectShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
float textureProjGradOffset(sampler1DShadow sampler, vec4 P, float dPdx, float dPdy, int offset)
endif::GLSL[]
float textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)
----

Do a texture lookup projectively and with explicit gradient as described in *textureProjGrad*, as
well as with offset, as described in *textureOffset*.


[[texture-gather-functions]]
=== Texture Gather Functions

The texture gather functions take components of a single floating-point
vector operand as a texture coordinate, determine a set of four texels to
sample from the base level-of-detail of the specified texture image, and
return one component from each texel in a four-component result vector.

When performing a texture gather operation, the minification and
magnification filters are ignored, and the rules for LINEAR filtering in the
<<references,{apispec}>> are applied to the base level of the texture image
to identify the four texels _i~0~ j~1~_, _i~1~ j~1~_, _i~1~ j~0~_, and _i~0~
j~0~_.
The texels are then converted to texture base colors (_R~s~_, _G~s~_,
_B~s~_, _A~s~_) according to table 15.1, followed by application of the
texture swizzle as described in section 15.2.1 "`Texture Access`" of the
<<references,{apispec}>>.
A four-component vector is assembled by taking the selected component from
each of the post-swizzled texture source colors in the order (_i~0~ j~1~_,
_i~1~ j~1~_, _i~1~ j~0~_, _i~0~ j~0~_).

ifdef::ESSL[]
The selected component is identified by the optional _comp_ argument, where
the values zero, one, two, and three identify the _R~s~_, _G~s~_, _B~s~_, or
_A~s~_ component, respectively.
If _comp_ is omitted, it is treated as identifying the _R~s~_ component.

Incomplete textures (see section 8.16 "`Texture Completeness`" of the
<<references,{apispec}>>) return a texture source color of (0,0,0,1) for all
four source texels.

endif::ESSL[]
For texture gather functions using a texture-combined shadow sampler type,
each of the four
texel lookups perform a depth comparison against the depth reference value
passed in (_refZ_), and returns the result of that comparison in the
appropriate component of the result vector.

As with other texture lookup functions, the results of a texture gather are
undefined for shadow samplers if the texture referenced is not a depth
texture or has depth comparisons disabled; or for non-shadow samplers if the
texture referenced is a depth texture with depth comparisons enabled.

ifdef::ESSL[]
The *textureGatherOffset* built-in functions from the {slname} return a vector
derived from sampling four texels in the image array of level _level~base~_.
For each of the four texel offsets specified by the _offsets_ argument, the
rules for the LINEAR minification filter are applied to identify a 2 {times}
2 texel footprint, from which the single texel T~i0j0~ is selected.
A four-component vector is then assembled by taking a single component from
each of the four T~i0j0~ texels in the same manner as for the
*textureGather* function.
endif::ESSL[]

==== TextureGather
[source,glsl]
----
gvec4 textureGather(gsampler2D sampler, vec2 P [, int comp])
gvec4 textureGather(gsampler2DArray sampler, vec3 P [, int comp])
gvec4 textureGather(gsamplerCube sampler, vec3 P [, int comp])
gvec4 textureGather(gsamplerCubeArray sampler, vec4 P [, int comp])
ifdef::GLSL[]
gvec4 textureGather(gsampler2DRect sampler, vec2 P [, int comp])
endif::GLSL[]
vec4 textureGather(sampler2DShadow sampler, vec2 P, float refZ)
vec4 textureGather(sampler2DArrayShadow sampler, vec3 P, float refZ)
vec4 textureGather(samplerCubeShadow sampler, vec3 P, float refZ)
vec4 textureGather(samplerCubeArrayShadow sampler, vec4 P, float refZ)
ifdef::GLSL[]
vec4 textureGather(sampler2DRectShadow sampler, vec2 P, float refZ)
endif::GLSL[]
----

Returns the value

[source,glsl]
----
vec4(Sample_i0_j1(P, base).comp,
     Sample_i1_j1(P, base).comp,
     Sample_i1_j0(P, base).comp,
     Sample_i0_j0(P, base).comp)
----

If specified, the value of _comp_ must be a constant integer expression with
a value of 0, 1, 2, or 3, identifying the _x_, _y_, _z_, or _w_
post-swizzled component of the four-component vector lookup result for each
texel, respectively.

If _comp_ is not specified, it is treated as 0, selecting the _x_ component
of each texel to generate the result.

==== TextureGatherOffset
[source,glsl]
----
gvec4 textureGatherOffset(gsampler2D sampler, vec2 P, ivec2 offset [, int comp])
gvec4 textureGatherOffset(gsampler2DArray sampler, vec3 P, ivec2 offset [, int comp])
vec4 textureGatherOffset(sampler2DShadow sampler, vec2 P, float refZ, ivec2 offset)
vec4 textureGatherOffset(sampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offset)
ifdef::GLSL[]
gvec4 textureGatherOffset(gsampler2DRect sampler, vec2 P, ivec2 offset [, int comp])
vec4 textureGatherOffset(sampler2DRectShadow sampler, vec2 P, float refZ, ivec2 offset)
endif::GLSL[]
----

Perform a texture gather operation as in *textureGather* by _offset_ as described in
*textureOffset* except that the _offset_ can be variable (non constant) and the
implementation-dependent minimum and maximum offset values are given by
MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively.

==== TextureGatherOffsets
[source,glsl]
----
gvec4 textureGatherOffsets(gsampler2D sampler, vec2 P, ivec2 offsets[4] [, int comp])
gvec4 textureGatherOffsets(gsampler2DArray sampler, vec3 P, ivec2 offsets[4] [, int comp])
vec4 textureGatherOffsets(sampler2DShadow sampler, vec2 P, float refZ, ivec2 offsets[4])
vec4 textureGatherOffsets(sampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offsets[4])
ifdef::GLSL[]
gvec4 textureGatherOffsets(gsampler2DRect sampler, vec2 P, ivec2 offsets[4] [, int comp])
vec4 textureGatherOffsets(sampler2DRectShadow sampler, vec2 P, float refZ, ivec2 offsets[4])
endif::GLSL[]
----

Operate identically to *textureGatherOffset* except that _offsets_ is used to determine the
location of the four texels to sample. Each of the four texels is obtained by applying the
corresponding offset in _offsets_ as a (_u_, _v_) coordinate offset to _P_, identifying the
four-texel LINEAR footprint, and then selecting the texel _i~0~ j~0~_ of that footprint. The
specified values in _offsets_ must be constant integral expressions.

ifdef::GLSL[]
[[compatibility-profile-texture-functions]]
=== Compatibility Profile Texture Functions

The following texture functions are only in the compatibility profile.

==== Texture1D
[source,glsl]
----
vec4 texture1D(sampler1D sampler, float coord [, float bias])
vec4 texture1DProj(sampler1D sampler, vec2 coord [, float bias])
vec4 texture1DProj(sampler1D sampler, vec4 coord [, float bias])
vec4 texture1DLod(sampler1D sampler, float coord, float lod)
vec4 texture1DProjLod(sampler1D sampler, vec2 coord, float lod)
vec4 texture1DProjLod(sampler1D sampler, vec4 coord, float lod)
----

See corresponding signature above without "`1D`" in the name.


==== Texture2D
[source,glsl]
----
vec4 texture2D(sampler2D sampler, vec2 coord [, float bias])
vec4 texture2DProj(sampler2D sampler, vec3 coord [, float bias])
vec4 texture2DProj(sampler2D sampler, vec4 coord [, float bias])
vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod)
vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod)
vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod)
----

See corresponding signature above without "`2D`" in the name.

==== Texture3D
[source,glsl]
----
vec4 texture3D(sampler3D sampler, vec3 coord [, float bias])
vec4 texture3DProj(sampler3D sampler, vec4 coord [, float bias])
vec4 texture3DLod(sampler3D sampler, vec3 coord, float lod)
vec4 texture3DProjLod(sampler3D sampler, vec4 coord, float lod)
----

See corresponding signature above without "`3D`" in the name. Use the texture coordinate _coord_
to do a texture lookup in the 3D texture currently bound to _sampler_. For the projective
("`*Proj*`") versions, the texture coordinate is divided by _coord.q_.

==== TextureCube
[source,glsl]
----
vec4 textureCube(samplerCube sampler, vec3 coord [, float bias])
vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod)
----

See corresponding signature above without "`Cube`" in the name.

==== Shadow
[source,glsl]
----
vec4 shadow1D(sampler1DShadow sampler, vec3 coord [, float bias])
vec4 shadow2D(sampler2DShadow sampler, vec3 coord [, float bias])
vec4 shadow1DProj(sampler1DShadow sampler, vec4 coord [, float bias])
vec4 shadow2DProj(sampler2DShadow sampler, vec4 coord [, float bias])
vec4 shadow1DLod(sampler1DShadow sampler, vec3 coord, float lod)
vec4 shadow2DLod(sampler2DShadow sampler, vec3 coord, float lod)
vec4 shadow1DProjLod(sampler1DShadow sampler, vec4 coord, float lod)
vec4 shadow2DProjLod(sampler2DShadow sampler, vec4 coord, float lod)
----

Same functionality as the "`*texture*`" based names above with the same signature.
endif::GLSL[]


[[atomic-counter-functions]]
== Atomic Counter Functions

The atomic-counter operations in this section operate atomically with
respect to each other.
They are atomic for any single counter, meaning any of these operations on a
specific counter in one shader instantiation will be indivisible by any of
these operations on the same counter from another shader instantiation.
There is no guarantee that these operations are atomic with respect to other
forms of access to the counter or that they are serialized when applied to
separate counters.
Such cases would require additional use of fences, barriers, or other forms
of synchronization, if atomicity or serialization is desired.

The underlying counter is a 32-bit unsigned integer.
The result of operations will wrap to [0, 2^32^-1].

=== AtomicCounterIncrement
[source,glsl]
----
uint atomicCounterIncrement(atomic_uint c)
----

Atomically

  . increments the counter for _c_, and
  . returns its value prior to the increment operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.


=== AtomicCounterDecrement
[source,glsl]
----
uint atomicCounterDecrement(atomic_uint c)
----

Atomically

  . decrements the counter for _c_, and
  . returns the value resulting from the decrement operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.

=== AtomicCounter
[source,glsl]
----
uint atomicCounter(atomic_uint c)
----

Returns the counter value for _c_.

ifdef::GLSL[]
=== AtomicCounterAdd
[source,glsl]
----
uint atomicCounterAdd(atomic_uint c, uint data)
----

Atomically

  . adds the value of _data_ to the counter for _c_, and
  . returns its value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.

=== AtomicCounterSubtract
[source,glsl]
----
uint atomicCounterSubtract(atomic_uint c, uint data)
----

Atomically

  . subtracts the value of _data_ from the counter for _c_, and
  . returns its value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.

=== AtomicCounterMin
[source,glsl]
----
uint atomicCounterMin(atomic_uint c, uint data)
----

Atomically

  . sets the counter for _c_ to the minimum of the value of the counter and
    the value of _data_, and
  . returns the value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.

=== AtomicCounterMax
[source,glsl]
----
uint atomicCounterMax(atomic_uint c, uint data)
----

Atomically

  . sets the counter for _c_ to the maximum of the value of the counter and
    the value of _data_, and
  . returns the value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.

=== AtomicCounterAnd
[source,glsl]
----
uint atomicCounterAnd(atomic_uint c, uint data)
----

Atomically

  . sets the counter for _c_ to the bitwise AND of the value of the counter
    and the value of _data_, and
  . returns the value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.

=== AtomicCounterOr
[source,glsl]
----
uint atomicCounterOr(atomic_uint c, uint data)
----

Atomically

  . sets the counter for _c_ to the bitwise OR of the value of the counter
    and the value of _data_, and
  . returns the value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.

=== AtomicCounterXor
[source,glsl]
----
uint atomicCounterXor(atomic_uint c, uint data)
----

Atomically

  . sets the counter for _c_ to the bitwise XOR of the value of the counter
    and the value of _data_, and
  . returns the value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.

=== AtomicCounterExchange
[source,glsl]
----
uint atomicCounterExchange(atomic_uint c, uint data)
----

Atomically

  . sets the counter value for _c_ to the value of _data_, and
  . returns its value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.

=== AtomicCounterCompSwap
[source,glsl]
----
uint atomicCounterCompSwap(atomic_uint c, uint compare, uint data)
----

Atomically

  . compares the value of _compare_ and the counter value for _c_
  . if the values are equal, sets the counter value for _c_ to the value of
    _data_, and
  . returns its value prior to the operation.

These three steps are done atomically with respect to the atomic counter
functions in this table.
endif::GLSL[]


[[atomic-memory-functions]]
== Atomic Memory Functions

Atomic memory functions perform atomic operations on an individual signed or
unsigned integer stored in buffer object or shared variable storage.  All of
the atomic memory operations read a value from memory, compute a new value
using one of the operations described below, write the new value to memory, and
return the original value read, converted to the precision declared in the
shader. Note that the operations are performed at the in-memory precision of
the storage, which may differ from the precision declared in the shader.

The contents of the memory being updated by the atomic operation are
guaranteed not to be modified by any other assignment or atomic memory
function in any shader invocation between the time the original value is
read and the time the new value is written.

Atomic memory functions are supported only for a limited set of variables.
A shader will fail to compile if the value passed to the _mem_ argument of
an atomic memory function does not correspond to a buffer or shared
variable.
It is acceptable to pass an element of an array or a single component of a
vector to the _mem_ argument of an atomic memory function, as long as the
underlying array or vector is a buffer or shared variable.

All the built-in functions in this section accept arguments with
combinations of *restrict*, *coherent*, and *volatile* memory qualification,
despite not having them listed in the prototypes.
The atomic operation will operate as required by the calling argument's
memory qualification, not by the built-in function's formal parameter memory
qualification.

=== AtomicAdd
[source,glsl]
----
uint atomicAdd(inout uint mem, uint data)
int atomicAdd(inout int mem, int data)
----

Computes a new value by adding the value of _data_ to the contents _mem_.

=== AtomicMin
[source,glsl]
----
uint atomicMin(inout uint mem, uint data)
int atomicMin(inout int mem, int data)
----

Computes a new value by taking the minimum of the value of _data_ and the contents of _mem_.

=== AtomicMax
[source,glsl]
----
uint atomicMax(inout uint mem, uint data)
int atomicMax(inout int mem, int data)
----

Computes a new value by taking the maximum of the value of _data_ and the contents of _mem_.

=== AtomicAnd
[source,glsl]
----
uint atomicAnd(inout uint mem, uint data)
int atomicAnd(inout int mem, int data)
----

Computes a new value by performing a bit-wise AND of the value of _data_ and the contents of _mem_.

=== AtomicOr
[source,glsl]
----
uint atomicOr(inout uint mem, uint data)
int atomicOr(inout int mem, int data)
----

Computes a new value by performing a bit-wise OR of the value of _data_ and the contents of _mem_.

=== AtomicXor
[source,glsl]
----
uint atomicXor(inout uint mem, uint data)
int atomicXor(inout int mem, int data)
----

Computes a new value by performing a bit-wise EXCLUSIVE OR of the value of _data_ and the contents
of _mem_.

=== AtomicExchange
[source,glsl]
----
uint atomicExchange(inout uint mem, uint data)
int atomicExchange(inout int mem, int data)
----

Computes a new value by simply copying the value of _data_.

=== AtomicCompSwap
[source,glsl]
----
uint atomicCompSwap(inout uint mem, uint compare, uint data)
int atomicCompSwap(inout int mem, int compare, int data)
----

Compares the value of _compare_ and the contents of _mem_. If the values are equal, the new value
is given by _data_; otherwise, it is taken from the original contents of _mem_.


[[image-functions]]
== Image Functions

Variables using one of the image basic types may be used by the built-in
shader image memory functions defined in this section to read and write
individual texels of a texture.
Each image variable references an image unit, which has a texture image
attached.

When image memory functions below access memory, an individual texel in the
image is identified using an (_i_), (_i, j_), or (_i, j, k_) coordinate
corresponding to the values of _P_.
ifdef::GLSL[]
For *image2DMS* and *image2DMSArray* variables (and the corresponding
int/unsigned int types) corresponding to multisample textures, each texel
may have multiple samples and an individual sample is identified using the
integer _sample_ parameter.
endif::GLSL[]
The coordinates
ifdef::GLSL[and sample number]
are used to select an individual texel in the manner described in section
ifdef::GLSL[8.26]
ifdef::ESSL[8.22]
"`Texture Image Loads and Stores`" of the <<references,{apispec}>>.

Loads and stores support float, integer, and unsigned integer types.
The data types below starting `gimage` serve as placeholders meaning
types starting either "`*image*`", "`*iimage*`", or "`*uimage*`" in the same
way as "*gvec*" or "*gsampler*" in earlier sections.

The _IMAGE_PARAMS_ in the prototypes below is a placeholder representing
ifdef::GLSL[33]
ifdef::ESSL[18]
separate functions, each for a different type of image variable.
The _IMAGE_PARAMS_ placeholder is replaced by one of the following parameter
lists:

{empty}:: gimage2D _image_, ivec2 _P_
{empty}:: gimage3D _image_, ivec3 _P_
{empty}:: gimageCube _image_, ivec3 _P_
{empty}:: gimageBuffer _image_, int _P_
{empty}:: gimage2DArray _image_, ivec3 _P_
{empty}:: gimageCubeArray _image_, ivec3 _P_
ifdef::GLSL[]
{empty}:: gimage1D _image_, int _P_
{empty}:: gimage1DArray _image_, ivec2 _P_
{empty}:: gimage2DRect _image_, ivec2 _P_
{empty}:: gimage2DMS _image_, ivec2 _P_, int _sample_
{empty}:: gimage2DMSArray _image_, ivec3 _P_, int _sample_
endif::GLSL[]

where each of the lines represents one of three different image variable
types, and _image_,
ifdef::GLSL[_P_, and _sample_]
ifdef::ESSL[_P_]
specify the individual texel to operate on.
The method for identifying the individual texel operated on from _image_,
_P_,
ifdef::GLSL[and _sample_,]
and the method for reading and writing the texel are specified in section
ifdef::GLSL[8.26]
ifdef::ESSL[8.22]
"`Texture Image Loads and Stores`" of the <<references,{apispec}>>.

The atomic functions perform operations on individual texels or samples of
an image variable.
Atomic memory operations read a value from the selected texel, compute a new
value using one of the operations described below, write the new value to
the selected texel, and return the original value read.
The contents of the texel being updated by the atomic operation are
guaranteed not to be modified by any other image store or atomic function
between the time the original value is read and the time the new value is
written.

Atomic memory operations are supported on only a subset of all image
variable types; _image_ must be either:

  * a signed integer image variable (type starts "`*iimage*`") and a format
    qualifier of *r32i*, used with a _data_ argument of type *int*, or
  * an unsigned integer image variable (type starts "`*uimage*`") and a
    format qualifier of *r32ui*, used with a _data_ argument of type *uint*,
    or
  * a float image variable (type starts "`*image*`") and a format qualifier
    of *r32f*, used with a _data_ argument of type *float*
    (*imageAtomicExchange* only).

All the built-in functions in this section accept arguments with
combinations of *restrict*, *coherent*, and *volatile* memory qualification,
despite not having them listed in the prototypes.
The image operation will operate as required by the calling argument's
memory qualification, not by the built-in function's formal parameter memory
qualification.

=== ImageSize
[source,glsl]
----
ifdef::GLSL[]
int imageSize(readonly writeonly gimage1D image)
ivec2 imageSize(readonly writeonly gimage2D image)
ivec3 imageSize(readonly writeonly gimage3D image)
ivec2 imageSize(readonly writeonly gimageCube image)
ivec3 imageSize(readonly writeonly gimageCubeArray image)
ivec3 imageSize(readonly writeonly gimage2DArray image)
ivec2 imageSize(readonly writeonly gimage2DRect image)
ivec2 imageSize(readonly writeonly gimage1DArray image)
ivec2 imageSize(readonly writeonly gimage2DMS image)
ivec3 imageSize(readonly writeonly gimage2DMSArray image)
int imageSize(readonly writeonly gimageBuffer image)
endif::GLSL[]
ifdef::ESSL[]
highp ivec2 imageSize(readonly writeonly gimage2D _image)
highp ivec3 imageSize(readonly writeonly gimage3D _image)
highp ivec2 imageSize(readonly writeonly gimageCube _image)
highp ivec3 imageSize(readonly writeonly gimageCubeArray _image)
highp ivec3 imageSize(readonly writeonly gimage2DArray _image)
highp int imageSize(readonly writeonly gimageBuffer _image)
endif::ESSL[]
----

Returns the dimensions of the image bound to _image_. For arrayed images, the last component of the
return value will hold the size of the array. Cube images only return the dimensions of one face,
and the number of cubes in the cube map array, if arrayed.

NOTE: The qualification *readonly writeonly* accepts a variable qualified with *readonly*,
      *writeonly*, both, or neither. It means the formal argument will be used for neither reading
      nor writing to the underlying memory.

ifdef::GLSL[]
=== ImageSamples
[source,glsl]
----
int imageSamples(readonly writeonly gimage2DMS image)
int imageSamples(readonly writeonly gimage2DMSArray image)
----

Returns the number of samples of the image bound to _image_.
endif::GLSL[]

=== ImageLoad
[source,glsl]
----
gvec4 imageLoad(readonly IMAGE_PARAMS)
----

Loads the texel at the coordinate _P_ from the image unit _image_ (in _IMAGE_PARAMS_).

ifdef::GLSL[]
For multisample loads, the sample number is given by _sample_. When _image_, _P_, and _sample_
endif::GLSL[]
ifdef::ESSL[]
When _image_ and _P_
endif::ESSL[]
identify a valid texel, the bits used to represent the selected texel in memory are converted to a
*vec4*, *ivec4*, or *uvec4* in the manner described in section
ifdef::GLSL[8.26]
ifdef::ESSL[8.23]
"`Texture Image Loads and Stores`" of the <<references,{apispec}>> and returned.

=== ImageStore
[source,glsl]
----
void imageStore(writeonly IMAGE_PARAMS, gvec4 data)
----

Stores _data_ into the texel at the coordinate _P_ from the image specified by _image_.
ifdef::GLSL[]
For multisample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_
endif::GLSL[]
ifdef::ESSL[]
When _image_ and _P_
endif::ESSL[]
identify a valid texel, the bits used to represent _data_ are converted to the format of the image
unit in the manner described in section
ifdef::GLSL[8.26]
ifdef::ESSL[8.23]
"`Texture Image Loads and Stores`" of the <<references,{apispec}>> and stored to the specified
texel.

=== ImageAtomicAdd
[source,glsl]
----
ifdef::GLSL[]
uint imageAtomicAdd(IMAGE_PARAMS, uint data)
int imageAtomicAdd(IMAGE_PARAMS, int data)
endif::GLSL[]
ifdef::ESSL[]
highp uint imageAtomicAdd(IMAGE_PARAMS, uint data)
highp int imageAtomicAdd(IMAGE_PARAMS, int data)
endif::ESSL[]
----

Computes a new value by adding the value of _data_ to the contents of the selected texel.

=== ImageAtomicMin
[source,glsl]
----
ifdef::GLSL[]
uint imageAtomicMin(IMAGE_PARAMS, uint data)
int imageAtomicMin(IMAGE_PARAMS, int data)
endif::GLSL[]
ifdef::ESSL[]
highp uint imageAtomicMin(IMAGE_PARAMS, uint data)
highp int imageAtomicMin(IMAGE_PARAMS, int data)
endif::ESSL[]
----

Computes a new value by taking the minimum of the value of _data_ and the contents of the selected
texel.

=== ImageAtomicMax
[source,glsl]
----
ifdef::GLSL[]
uint imageAtomicMax(IMAGE_PARAMS, uint data)
int imageAtomicMax(IMAGE_PARAMS, int data)
endif::GLSL[]
ifdef::ESSL[]
highp uint imageAtomicMax(IMAGE_PARAMS, uint data)
highp int imageAtomicMax(IMAGE_PARAMS, int data)
endif::ESSL[]
----

Computes a new value by taking the maximum of the value _data_ and the contents of the selected
texel.

=== ImageAtomicAnd
[source,glsl]
----
ifdef::GLSL[]
uint imageAtomicAnd(IMAGE_PARAMS, uint data)
int imageAtomicAnd(IMAGE_PARAMS, int data)
endif::GLSL[]
ifdef::ESSL[]
highp uint imageAtomicAnd(IMAGE_PARAMS, uint data)
highp int imageAtomicAnd(IMAGE_PARAMS, int data)
endif::ESSL[]
----

Computes a new value by performing a bit-wise AND of the value of _data_ and the contents of the
selected texel.

=== ImageAtomicOr
[source,glsl]
----
ifdef::GLSL[]
uint imageAtomicOr(IMAGE_PARAMS, uint data)
int imageAtomicOr(IMAGE_PARAMS, int data)
endif::GLSL[]
ifdef::ESSL[]
highp uint imageAtomicOr(IMAGE_PARAMS, uint data)
highp int imageAtomicOr(IMAGE_PARAMS, int data)
endif::ESSL[]
----

Computes a new value by performing a bit-wise OR of the value of _data_ and the contents of the
selected texel.

=== ImageAtomicXor
[source,glsl]
----
ifdef::GLSL[]
uint imageAtomicXor(IMAGE_PARAMS, uint data)
int imageAtomicXor(IMAGE_PARAMS, int data)
endif::GLSL[]
ifdef::ESSL[]
highp uint imageAtomicXor(IMAGE_PARAMS, uint data)
highp int imageAtomicXor(IMAGE_PARAMS, int data)
endif::ESSL[]
----

Computes a new value by performing a bit-wise EXCLUSIVE OR of the value of _data_ and the contents
of the selected texel.

=== ImageAtomicExchange
[source,glsl]
----
ifdef::GLSL[]
uint imageAtomicExchange(IMAGE_PARAMS, uint data)
int imageAtomicExchange(IMAGE_PARAMS, int data)
float imageAtomicExchange(IMAGE_PARAMS, float data)
endif::GLSL[]
ifdef::ESSL[]
highp uint imageAtomicExchange(IMAGE_PARAMS, uint data)
highp int imageAtomicExchange(IMAGE_PARAMS, int data)
highp float imageAtomicExchange(IMAGE_PARAMS, float data)
endif::ESSL[]
----

Computes a new value by simply copying the value of _data_.

=== ImageAtomicCompSwap
[source,glsl]
----
ifdef::GLSL[]
uint imageAtomicCompSwap(IMAGE_PARAMS, uint compare, uint data)
int imageAtomicCompSwap(IMAGE_PARAMS, int compare, int data)
endif::GLSL[]
ifdef::ESSL[]
highp uint imageAtomicCompSwap(IMAGE_PARAMS, uint compare, uint data)
highp int imageAtomicCompSwap(IMAGE_PARAMS, int compare, int data)
endif::ESSL[]
----

Compares the value of _compare_ and the contents of the selected texel. If the values are equal,
the new value is given by _data_; otherwise, it is taken from the original value loaded from the
texel.


[[geometry-shader-functions]]
== Geometry Shader Functions

These functions are only available in geometry shaders.
They are described in more depth following the table.

ifdef::GLSL[]
=== EmitStreamVertex
[source,glsl]
----
void EmitStreamVertex(int stream)
----

Emits the current values of output variables to the current output primitive on stream _stream_.
The argument to _stream_ must be a constant integral expression. On return from this call, the
values of all output variables are undefined.

Can only be used if multiple output streams are supported.

=== EndStreamPrimitive
[source,glsl]
----
void EndStreamPrimitive(int stream)
----

Completes the current output primitive on stream _stream_ and starts a new one. The argument to
_stream_ must be a constant integral expression. No vertex is emitted.

Can only be used if multiple output streams are supported.
endif::GLSL[]

=== EmitVertex
[source,glsl]
----
void EmitVertex()
----

Emits the current values of output variables to the current output primitive.
ifdef::GLSL[]
When multiple output streams are supported, this is equivalent to calling *EmitStreamVertex*(0).
endif::GLSL[]

On return from this call, the values of output variables are undefined.

=== EndPrimitive
[source,glsl]
----
void EndPrimitive()
----

Completes the current output primitive and starts a new one.
ifdef::GLSL[]
When multiple output streams are supported, this is equivalent to calling *EndStreamPrimitive*(0).
endif::GLSL[]

No vertex is emitted.

=== Description
ifdef::GLSL[]
The function *EmitStreamVertex*() specifies that a vertex is completed.
A vertex is added to the current output primitive in vertex stream _stream_
using the current values of all built-in and user-defined output variables
associated with _stream_.
The values of all output variables for all output streams are undefined
after a call to *EmitStreamVertex*().
If a geometry shader invocation has emitted more vertices than permitted by
the output layout qualifier *max_vertices*, the results of calling
*EmitStreamVertex*() are undefined.

The function *EndStreamPrimitive*() specifies that the current output
primitive for vertex stream _stream_ is completed and a new output primitive
(of the same type) will be started by any subsequent *EmitStreamVertex*().
This function does not emit a vertex.
If the output layout is declared to be *points*, calling
*EndStreamPrimitive*() is optional.

A geometry shader starts with an output primitive containing no vertices for
each stream.
When a geometry shader terminates, the current output primitive for each
stream is automatically completed.
It is not necessary to call *EndStreamPrimitive*() if the geometry shader
writes only a single primitive.

Multiple output streams are supported only if the output primitive type is
declared to be *points*.
It is a compile-time or link-time error if a program contains a geometry
shader calling *EmitStreamVertex*() or *EndStreamPrimitive*() if its output
primitive type is not *points*.
endif::GLSL[]
ifdef::ESSL[]
The function *EmitVertex*() specifies that a vertex is completed.
A vertex is added to the current output primitive using the current values
of all built-in and user-defined output variables.
The values of all output variables are undefined after a call to
*EmitVertex*().
If a geometry shader invocation has emitted more vertices than permitted by
the output layout qualifier *max_vertices*, the results of calling
*EmitVertex*() are undefined.

The function *EndPrimitive*() specifies that the current output primitive is
completed and a new output primitive (of the same type) will be started by
any subsequent *EmitVertex*().
This function does not emit a vertex.
If the output layout is declared to be *points*, calling *EndPrimitive*() is
optional.

A geometry shader starts with an output primitive containing no vertices.
When a geometry shader terminates, the current output primitive is
automatically completed.
It is not necessary to call *EndPrimitive*() if the geometry shader writes
only a single primitive.
endif::ESSL[]


[[fragment-processing-functions]]
== Fragment Processing Functions

Fragment processing functions are only available in fragment shaders.


[[derivative-functions]]
=== Derivative Functions

Derivatives may be computationally expensive and/or numerically unstable.
Therefore, an implementation may approximate the true derivatives
by using a fast but not entirely accurate derivative computation.
Derivatives are undefined within non-uniform control flow.

The expected behavior of a derivative is specified using forward/backward
differencing.

Forward differencing:

latexmath:[F(x+dx) - F(x) \sim dFdx(x) \cdot dx (1a)]

latexmath:[dFdx(x) \sim \frac{F(x+dx) - F(x)}{dx} (1b)]

Backward differencing:

latexmath:[F(x-dx) - F(x) \sim -dFdx(x) \cdot dx (2a)]

latexmath:[dFdx(x) \sim \frac{F(x) - F(x-dx)}{dx} (2b)]

With single-sample rasterization, latexmath:[dx \leq 1.0] in equations 1b
and 2b.
For multisample rasterization, latexmath:[dx < 2.0] in equations 1b and 2b.

latexmath:[dFdy] is approximated similarly, with _y_ replacing _x_.

ifdef::GLSL[]
With multisample rasterization, for any given fragment or sample, either
neighboring fragments or samples may be considered.

It is typical to consider a 2x2 square of fragments or samples, and compute
independent *dFdxFine* per row and independent *dFdyFine* per column, while
computing only a single *dFdxCoarse* and a single *dFdyCoarse* for the
entire 2x2 square.
Thus, all second-order coarse derivatives, e.g.
*dFdxCoarse*(*dFdxCoarse*(_x_)), may be 0, even for non-linear arguments.
However, second-order fine derivatives, e.g. *dFdxFine*(*dFdyFine*(_x_))
will properly reflect the difference between the independent fine
derivatives computed within the 2x2 square.

The method may differ per fragment, subject to the constraint that the
method may vary by window coordinates, not screen coordinates.
The invariance requirement described in section 14.2 "`Invariance`" of the
<<references,{apispec}>>, is relaxed for derivative calculations, because
the method may be a function of fragment location.

In some implementations, varying degrees of derivative accuracy for *dFdx*
and *dFdy* may be obtained by providing GL hints (see section 21.4 "`Hints`"
of the <<references,{apispec}>>), allowing a user to make an image quality
versus speed trade off.
These hints have no effect on *dFdxCoarse*, *dFdyCoarse*, *dFdxFine* and
*dFdyFine*.

=== DFdx
[source,glsl]
----
genFType dFdx(genFType p)
----

Returns either *dFdxFine*(_p_) or *dFdxCoarse*(_p_), based on implementation choice, presumably
whichever is the faster, or by whichever is selected in the API through quality-versus-speed hints.

=== DFdy
[source,glsl]
----
genFType dFdy(genFType p)
----

Returns either *dFdyFine*(_p_) or *dFdyCoarse*(_p_), based on implementation choice, presumably
whichever is the faster, or by whichever is selected in the API through quality-versus-speed hints.

=== DFdxFine
[source,glsl]
----
genFType dFdxFine(genFType p)
----

Returns the partial derivative of _p_ with respect to the window x coordinate. Will use local
differencing based on the value of _p_ for the current fragment and its immediate neighbor(s).

=== DFdyFine
[source,glsl]
----
genFType dFdyFine(genFType p)
----

Returns the partial derivative of _p_ with respect to the window y coordinate. Will use local
differencing based on the value of _p_ for the current fragment and its immediate neighbor(s).

=== DFdxCoarse
[source,glsl]
----
genFType dFdxCoarse(genFType p)
----

Returns the partial derivative of _p_ with respect to the window x coordinate. Will use local
differencing based on the value of _p_ for the current fragment's neighbors, and will possibly, but
not necessarily, include the value of _p_ for the current fragment.

That is, over a given area, the implementation can x compute derivatives in fewer unique locations
than would be allowed for *dFdxFine*(_p_).

=== DFdyCoarse
[source,glsl]
----
genFType dFdyCoarse(genFType p)
----

Returns the partial derivative of _p_ with respect to the window y coordinate. Will use local
differencing based on the value of _p_ for the current fragment's neighbors, and will possibly, but
not necessarily, include the value of _p_ for the current fragment.

That is, over a given area, the implementation can compute y derivatives in fewer unique locations
than would be allowed for *dFdyFine*(_p_).

=== Fwidth
[source,glsl]
----
genFType fwidth(genFType p)
----

Returns *abs*(*dFdx*(_p_)) + *abs*(*dFdy*(_p_)).

=== FwidthFine
[source,glsl]
----
genFType fwidthFine(genFType p)
----

Returns *abs*(*dFdxFine*(_p_)) + *abs*(*dFdyFine*(_p_)).

=== FwidthCoarse
[source,glsl]
----
genFType fwidthCoarse(genFType p)
----

Returns *abs*(*dFdxCoarse*(_p_)) + *abs*(*dFdyCoarse*(_p_)).

endif::GLSL[]
ifdef::ESSL[]
An implementation may use the above or other methods to perform
the calculation, subject to the following conditions:

  . The method may use piecewise linear approximations.
    Such linear approximations imply that higher order derivatives,
    *dFdx*(*dFdx*(_x_)) and above, are undefined.
  . The method may assume that the function evaluated is continuous.
    Therefore derivatives within the body of a non-uniform conditional are
    undefined.
  . The method may differ per fragment, subject to the constraint that the
    method may vary by window coordinates, not screen coordinates.
    The invariance requirement described in section 13.2 "`Invariance`" of
    the <<references,{apispec}>>, is relaxed for derivative calculations,
    because the method may be a function of fragment location.

Other properties that are desirable, but not required, are:

  . Functions should be evaluated within the interior of a primitive
    (interpolated, not extrapolated).
  . Functions for *dFdx* should be evaluated while holding _y_ constant.
    Functions for *dFdy* should be evaluated while holding _x_ constant.
    However, mixed higher order derivatives, like *dFdx*(*dFdy*(_y_)) and
    *dFdy*(*dFdx*(_x_)) are undefined.
  . Derivatives of constant arguments should be 0.

In some implementations, varying degrees of derivative accuracy may be
obtained by providing GL hints (see section 19.1 "`Hints`" of the
<<references,{apispec}>>), allowing a user to make an image quality versus
speed trade off.

=== DFdx
[source,glsl]
----
genFType dFdx(genFType p)
----

Returns the derivative in x using local differencing for the input argument _p_.

=== DFdy
[source,glsl]
----
genFType dFdy(genFType p)
----

Returns the derivative in y using local differencing for the input argument _p_.

These two functions are commonly used to estimate the filter width used to anti-alias procedural
textures. We are assuming that the expression is being evaluated in parallel on a SIMD array so
that at any given point in time the value of the function is known at the grid points represented
by the SIMD array. Local differencing between SIMD array elements can therefore be used to derive
*dFdx*, *dFdy*, etc.

=== Fwidth
[source,glsl]
----
genFType fwidth(genFType p)
----

Returns the sum of the absolute derivative in x and y using local differencing for the input
argument _p_, i.e., *abs*(*dFdx*(_p_)) + *abs*(*dFdy*(_p_));

endif::ESSL[]


[[interpolation-functions]]
=== Interpolation Functions

Built-in interpolation functions are available to compute an interpolated
value of a fragment shader input variable at a shader-specified (_x_, _y_)
location.
A separate (_x_, _y_) location may be used for each invocation of the
built-in function, and those locations may differ from the default (_x_,
_y_) location used to produce the default value of the input.

For all of the interpolation functions, _interpolant_ must be an l-value
from an *in* declaration;
this can include a variable,
ifdef::GLSL[a block or structure member,]
ifdef::ESSL[an anonymous block member,]
an array element, or some combination of these.
ifdef::GLSL[]
Additionally, component selection operators (e.g. *.xy*, *.xxz*) may be applied
to _interpolant_, in which case the interpolation function will return the
result of applying the component selection operator to the interpolated value
of _interpolant_ (for example, interpolateAt(v.xxz) is defined to return
interpolateAt(v).xxz).
endif::GLSL[]
ifdef::ESSL[]
Component selection operators (e.g. *.xy*), and field selection operators may
not be used when specifying _interpolant_.
endif::ESSL[]
Arrayed inputs can be indexed with general (nonuniform) integer expressions.

If _interpolant_ is declared with the *flat* qualifier, the interpolated
value will have the same value everywhere for a single primitive, so the
location used for interpolation has no effect and the functions just return
that same value.
If _interpolant_ is declared with the *centroid* qualifier, the value
returned by *interpolateAtSample*() and *interpolateAtOffset*() will be
evaluated at the specified location, ignoring the location normally used
with the *centroid* qualifier.
ifdef::GLSL[]
If _interpolant_ is declared with the *noperspective* qualifier, the
interpolated value will be computed without perspective correction.
endif::GLSL[]

=== InterpolateAtCentroid
[source,glsl]
----
float interpolateAtCentroid(float interpolant)
vec2 interpolateAtCentroid(vec2 interpolant)
vec3 interpolateAtCentroid(vec3 interpolant)
vec4 interpolateAtCentroid(vec4 interpolant)
----

Returns the value of the input _interpolant_ sampled at a location inside both the pixel and the
primitive being processed. The value obtained would be the same value assigned to the input
variable if declared with the *centroid* qualifier.

=== InterpolateAtSample
[source,glsl]
----
float interpolateAtSample(float interpolant, int sample)
vec2 interpolateAtSample(vec2 interpolant, int sample)
vec3 interpolateAtSample(vec3 interpolant, int sample)
vec4 interpolateAtSample(vec4 interpolant, int sample)
----

Returns the value of the input _interpolant_ variable at the location of sample number _sample_.
If multisample buffers are not available, the input variable will be evaluated at the center of the
pixel. If sample _sample_ does not exist, the position used to interpolate the input variable is undefined.

=== InterpolateAtOffset
[source,glsl]
----
float interpolateAtOffset(float interpolant, vec2 offset)
vec2 interpolateAtOffset(vec2 interpolant, vec2 offset)
vec3 interpolateAtOffset(vec3 interpolant, vec2 offset)
vec4 interpolateAtOffset(vec4 interpolant, vec2 offset)
----

Returns the value of the input _interpolant_ variable sampled at an offset from the center of the
pixel specified by _offset_. The two floating-point components of _offset_, give the offset in
pixels in the _x_ and _y_ directions, respectively.

An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets
supported by this function is implementation-dependent.


ifdef::GLSL[]
[[noise-functions]]
== Noise Functions

The noise functions *noise1*, *noise2*, *noise3*, and *noise4* have been
deprecated starting with version 4.4 of GLSL.
When not generating SPIR-V they are defined to return the value 0.0 or a vector
whose components are all 0.0. When generating SPIR-V the noise functions are
not declared and may not be used.

As in previous releases, the noise functions are not semantically considered to
be compile-time constant expressions.

=== Noise1
[source,glsl]
----
float noise1(genFType x)
----

Returns a 1D noise value based on the input value _x_.

=== Noise2
[source,glsl]
----
vec2 noise2(genFType x)
----

Returns a 2D noise value based on the input value _x_.

=== Noise3
[source,glsl]
----
vec3 noise3(genFType x)
----

Returns a 3D noise value based on the input value _x_.

=== Noise4
[source,glsl]
----
vec4 noise4(genFType x)
----

Returns a 4D noise value based on the input value _x_.
endif::GLSL[]


[[shader-invocation-control-functions]]
== Shader Invocation Control Functions

The shader invocation control function is only available in tessellation
control and compute shaders.
It is used to control the relative execution order of multiple shader
invocations used to process a patch (in the case of tessellation control
shaders) or a workgroup (in the case of compute shaders), which are
otherwise executed with an undefined relative order.

=== Barrier
[source,glsl]
----
void barrier()
----

For any given static instance of *barrier*(), all tessellation control shader invocations for a
single input patch must enter it before any will be allowed to continue beyond it, or all compute
shader invocations for a single workgroup must enter it before any will continue beyond it.

The function *barrier*() provides a partially defined order of execution
between shader invocations.
The ensures that, for some types of memory accesses, values written by one
invocation prior to a given static instance of *barrier*() can be safely read
by other invocations after their call to the same static instance *barrier*().
Because invocations may execute in an undefined order between these barrier
calls, the values of a per-vertex or per-patch output variable for tessellation
control shaders, or the values of *shared* variables for compute shaders will be
undefined in a number of cases enumerated in
"`<<output-variables,Output Variables>>`" (for tessellation control shaders)
and "`<<shared-variables,Shared Variables>>`" (for compute shaders).

For tessellation control shaders, the *barrier*() function may only be
placed inside the function *main*() of the shader and may not be called
within any control flow.
Barriers are also disallowed after a return statement in the function
*main*().
Any such misplaced barriers result in a compile-time error.

A *barrier*() affects control flow but only synchronizes memory accesses
to *shared* variables and tessellation control output variables.
For other memory accesses, it does not ensure that values written by one invocation
prior to a given static instance of *barrier*() can be safely read by other
invocations after their call to the same static instance of *barrier*().
To achieve this requires the use of both *barrier*() and a memory barrier.

For compute shaders, the *barrier*() function may be placed within control
flow, but that control flow must be uniform control flow.
That is, all the controlling expressions that lead to execution of the
barrier must be dynamically uniform expressions.
This ensures that if any shader invocation enters a conditional statement,
then all invocations will enter it.
While compilers are encouraged to give warnings if they can detect this
might not happen, compilers cannot completely determine this.
Hence, it is the author's responsibility to ensure *barrier*() only exists
inside uniform control flow.
Otherwise, some shader invocations will stall indefinitely, waiting for a
barrier that is never reached by other invocations.

[[shader-memory-control-functions]]
== Shader Memory Control Functions

Within a single shader invocation, the visibility and order of writes made
by that invocation are well-defined.
However, the relative order of reads and writes to a single shared memory
address from multiple separate shader invocations is largely undefined.
Additionally, the order of accesses to multiple memory addresses performed
by a single shader invocation, as observed by other shader invocations, is
also undefined.

The following built-in functions can be used to control the ordering of
reads and writes:

=== MemoryBarrier
[source,glsl]
----
void memoryBarrier()
----

Control the ordering of memory transactions issued by a single shader invocation.

=== MemoryBarrierAtomicCounter
[source,glsl]
----
void memoryBarrierAtomicCounter()
----

Control the ordering of accesses to atomic-counter variables issued by a single shader invocation.

=== MemoryBarrierBuffer
[source,glsl]
----
void memoryBarrierBuffer()
----

Control the ordering of memory transactions to buffer variables issued within a single shader invocation.

=== MemoryBarrierShared
[source,glsl]
----
void memoryBarrierShared()
----

Control the ordering of memory transactions to shared variables issued within a single shader
invocation, as viewed by other invocations in the same workgroup.

Only available in compute shaders.

=== MemoryBarrierImage
[source,glsl]
----
void memoryBarrierImage()
----

Control the ordering of memory transactions to images issued within a single shader invocation.

=== GroupMemoryBarrier
[source,glsl]
----
void groupMemoryBarrier()
----

Control the ordering of all memory transactions issued within a single shader invocation, as viewed
by other invocations in the same workgroup.

Only available in compute shaders.

=== Description
The memory barrier built-in functions can be used to order reads and writes
to variables stored in memory accessible to other shader invocations.
When called, these functions will wait for the completion of all reads and
writes previously performed by the caller that access selected variable
types, and then return with no other effect.
The built-in functions *memoryBarrierAtomicCounter*(),
*memoryBarrierBuffer*(), *memoryBarrierImage*(), and *memoryBarrierShared*()
wait for the completion of accesses to atomic counter, buffer, image, and
shared variables, respectively.
The built-in functions *memoryBarrier*() and *groupMemoryBarrier*() wait for
the completion of accesses to all of the above variable types.
The functions *memoryBarrierShared*() and *groupMemoryBarrier*() are
available only in compute shaders; the other functions are available in all
shader types.

When these functions return, the effects of any memory stores performed
using coherent variables prior to the call will be visible to any
future^1^ coherent access to the same memory performed by any other shader
invocation.
In particular, the values written this way in one shader stage are
guaranteed to be visible to coherent memory accesses performed by shader
invocations in subsequent stages when those invocations were triggered by
the execution of the original shader invocation (e.g. fragment shader
invocations for a primitive resulting from a particular geometry
shader invocation).

1::
    An access is only a _future_ access if a _happens-before_ relation can
    be established between the store and the load.

Additionally, memory barrier functions order stores performed by the calling
invocation, as observed by other shader invocations.
Without memory barriers, if one shader invocation performs two stores to
coherent variables, a second shader invocation might see the values written
by the second store prior to seeing those written by the first.
However, if the first shader invocation calls a memory barrier function
between the two stores, selected other shader invocations will never see the
results of the second store before seeing those of the first.
When using the functions *groupMemoryBarrier*() or *memoryBarrierShared*(),
this ordering guarantee applies only to other shader invocations in the same
compute shader workgroup; all other memory barrier functions provide the
guarantee to all other shader invocations.
No memory barrier is required to guarantee the order of memory stores as
observed by the invocation performing the stores; an invocation reading from
a variable that it previously wrote will always see the most recently
written value unless another shader invocation also wrote to the same
memory.

== Subpass-Input Functions

Subpass-input functions are only available when targeting a Vulkan fragment stage.

Subpass inputs are read through the built-in functions below. The `g` is again
a placeholder for either nothing, `i`, or `u`, indicating either a floating-point,
signed integer, or unsigned integer, and these must match between argument type
and return type.

=== SubpassLoad
[source,glsl]
----
gvec4 subpassLoad(gsubpassInput subpass)
gvec4 subpassLoad(gsubpassInputMS subpass, int sample)
----

Read from a subpass input, from the implicit location _(x, y, layer)_ of the current fragment
coordinate.

ifdef::GLSL[]
[[shader-invocation-group-functions]]
== Shader Invocation Group Functions

Implementations of the {slname} may optionally group multiple shader
invocations for a single shader stage into a single SIMD invocation group,
where invocations are assigned to groups in an undefined,
implementation-dependent manner.
Shader algorithms on such implementations may benefit from being able to
evaluate a composite of Boolean values over all active invocations in a
group.

=== AnyInvocation
[source,glsl]
----
bool anyInvocation(bool value)
----

Returns *true* if and only if _value_ is *true* for at least one active invocation in the group.

=== AllInvocations
[source,glsl]
----
bool allInvocations(bool value)
----

Returns *true* if and only if _value_ is *true* for all active invocations in the group.

=== AllInvocationsEqual
[source,glsl]
----
bool allInvocationsEqual(bool value)
----

Returns *true* if _value_ is the same for all active invocations in the group.

=== Description
For all of these functions, the same result is returned to all active
invocations in the group.

These functions may be called within conditionally executed code.
In groups where some invocations do not execute the function call, the value
returned by the function is not affected by any invocation not calling the
function, even when value is well-defined for that invocation.

Because these functions depend on the values of _value_ in an undefined
group of invocations, the value returned by these functions is largely
undefined.
However, *anyInvocation*() is guaranteed to return *true* if _value_ is
*true*, and *allInvocations*() is guaranteed to return *false* if _value_ is
*false*.

Because implementations are not required to combine invocations into groups,
simply returning _value_ for *anyInvocation*() and *allInvocations*() and
returning true for *allInvocationsEqual*() is a legal implementation of
these functions.

For fragment shaders, invocations in a SIMD invocation group may include
invocations corresponding to pixels that are covered by a primitive being
rasterized, as well as invocations corresponding to neighboring pixels not
covered by the primitive.
_Helper invocations_ (see "`<<built-in-language-variables, Built-In Language
Variables>>`") may be created and the value of _value_ for such
helper-invocation pixels may affect the value returned by *anyInvocation*(),
*allInvocations*(), and *allInvocationsEqual*().
endif::GLSL[]
