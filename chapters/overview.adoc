// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0

[[overview-of-opengl-shading]]
= Overview of Shading

The {slname} is actually several closely related languages.
These languages are used to create shaders for each of the programmable
processors contained in the API's processing pipeline.
Currently, these processors are the vertex, tessellation control,
tessellation evaluation, geometry, fragment, and compute processors.

ifdef::ESSL[]
Compilation units for these processors are referred to as _shaders_ and the
processors themselves are also referred to as _shader stages_.
Only one shader can be run on a processor at any one time; there is no
support for linking multiple compilation units together for a single shader
stage.
One or more shaders are linked together to form a single program and each
program contains shader _executables_ for one or more consecutive shader
stages.
endif::ESSL[]

Unless otherwise noted in this paper, a language feature applies to all
languages, and common usage will refer to these languages as a single
language.
The specific languages will be referred to by the name of the processor they
target: vertex, tessellation control, tessellation evaluation, geometry,
fragment, or compute.

Most API state is not tracked or made available to shaders.
Typically, user-defined variables will be used for communicating between
different stages of the API pipeline.
However, a small amount of state is still tracked and automatically made
available to shaders, and there are a few built-in variables for interfaces
between different stages of the API pipeline.


[[vertex-processor]]
== Vertex Processor

The _vertex processor_ is a programmable unit that operates on incoming
vertices and their associated data.
Compilation units written in the {slname} to run on this processor are called
_vertex shaders_.
ifdef::GLSL[]
When a set of vertex shaders are successfully compiled and linked, they
result in a _vertex shader executable_ that runs on the vertex processor.
endif::GLSL[]

The vertex processor operates on one vertex at a time.
It does not replace graphics operations that require knowledge of several
vertices at a time.


[[tessellation-control-processor]]
== Tessellation Control Processor

The _tessellation control processor_ is a programmable unit that operates on
a patch of incoming vertices and their associated data, emitting a new
output patch.
Compilation units written in the {slname} to run on this processor are called
tessellation control shaders.
ifdef::GLSL[]
When a set of tessellation control shaders are successfully compiled and
linked, they result in a _tessellation control shader executable_ that runs
on the tessellation control processor.
endif::GLSL[]

The tessellation control shader is invoked for each vertex of the output
patch.
Each invocation can read the attributes of any vertex in the input or output
patches, but can only write per-vertex attributes for the corresponding
output patch vertex.
The shader invocations collectively produce a set of per-patch attributes
for the output patch.

After all tessellation control shader invocations have completed, the output
vertices and per-patch attributes are assembled to form a patch to be used
by subsequent pipeline stages.

Tessellation control shader invocations run mostly independently, with
undefined relative execution order.
However, the built-in function *barrier*() can be used to control execution
order by synchronizing invocations, effectively dividing tessellation
control shader execution into a set of phases.
Tessellation control shaders will get undefined results if one invocation
reads from a per-vertex or per-patch attribute written by another invocation
at any point during the same phase, or if two invocations attempt to write
different values to the same per-patch output
ifdef::GLSL[32-bit component]
in a single phase.


[[tessellation-evaluation-processor]]
== Tessellation Evaluation Processor

The _tessellation evaluation processor_ is a programmable unit that
evaluates the position and other attributes of a vertex generated by the
tessellation primitive generator, using a patch of incoming vertices and
their associated data.
Compilation units written in the {slname} to run on this processor are called
tessellation evaluation shaders.
ifdef::GLSL[]
When a set of tessellation evaluation shaders are successfully compiled and
linked, they result in a _tessellation evaluation shader executable_ that
runs on the tessellation evaluation processor.
endif::GLSL[]

Each invocation of the tessellation evaluation executable computes the
position and attributes of a single vertex generated by the tessellation
primitive generator.
The executable can read the attributes of any vertex in the input patch,
plus the tessellation coordinate, which is the relative location of the
vertex in the primitive being tessellated.
The executable writes the position and other attributes of the vertex.


[[geometry-processor]]
== Geometry Processor

The _geometry processor_ is a programmable unit that operates on data for
incoming vertices for a primitive assembled after vertex processing and
outputs a sequence of vertices forming output primitives.
Compilation units written in the {slname} to run on this processor are called
_geometry shaders_.
ifdef::GLSL[]
When a set of geometry shaders are successfully compiled and linked, they
result in a _geometry shader executable_ that runs on the geometry
processor.
endif::GLSL[]

A single invocation of the geometry shader executable on the geometry
processor will operate on a declared input primitive with a fixed number of
vertices.
This single invocation can emit a variable number of vertices that are
assembled into primitives of a declared output primitive type and passed to
subsequent pipeline stages.


[[fragment-processor]]
== Fragment Processor

The _fragment processor_ is a programmable unit that operates on fragment
values and their associated data.
Compilation units written in the {slname} to run on this processor are called
_fragment shaders_.
ifdef::GLSL[]
When a set of fragment shaders are successfully compiled and linked, they
result in a _fragment shader executable_ that runs on the fragment
processor.
endif::GLSL[]

A fragment shader cannot change a fragment's (_x_, _y_) position.
Access to neighboring fragments is not allowed.
The values computed by the fragment shader are ultimately used to update
framebuffer memory or texture memory, depending on the current API
state and the API command that caused the fragments to be generated.


[[compute-processor]]
== Compute Processor

The _compute processor_ is a programmable unit that operates independently
from the other shader processors.
Compilation units written in the {slname} to run on this processor are called
_compute shaders_.
ifdef::GLSL[]
When a set of compute shaders are successfully compiled and linked, they
result in a _compute shader executable_ that runs on the compute processor.
endif::GLSL[]

A compute shader has access to many of the same resources as fragment and
other shader processors, such as textures, buffers, image variables, and
atomic counters.
It does not have fixed-function outputs.
It is not part of the graphics pipeline and its visible side effects are
through changes to images, storage buffers, and atomic counters.

A compute shader operates on a group of work items called a _workgroup_.
A workgroup is a collection of shader invocations that execute the same
code, potentially in parallel.
An invocation within a workgroup may share data with other members of the
same workgroup through shared variables and issue memory and control flow
barriers to synchronize with other members of the same workgroup.
