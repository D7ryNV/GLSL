// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0

[[variables-and-types]]
= Variables and Types

All variables and functions must be declared before being used.
Variable and function names are identifiers.

There are no default types.
All variable and function declarations must have a declared type, and
optionally qualifiers.
A variable is declared by specifying its type followed by one or more names
separated by commas.
In many cases, a variable can be initialized as part of its declaration by
using the assignment operator (*=*).

User-defined types may be defined using *struct* to aggregate a list of
existing types into a single name.

The {slname} is type safe.
ifdef::GLSL[]
There are some implicit conversions between types.
Exactly how and when this can occur is described in section
"`<<implicit-conversions,Implicit Conversions>>`" and as referenced by other
sections in this specification.
endif::GLSL[]
ifdef::ESSL[]
There are no implicit conversions between types.
endif::ESSL[]


[[basic-types]]
== Basic Types

Definition::
A _basic type_ is a type defined by a keyword in the language.

The {slname} supports the following basic data types, grouped as follows.


*Transparent Types*

[options="header"]
|====
| Type      | Meaning
| *void*    | for functions that do not return a value
| *bool*    | a conditional type, taking on values of true or false
| *int*     | a signed integer
| *uint*    | an unsigned integer
| *float*   | a single-precision floating-point scalar
ifdef::GLSL[]
| *double*  | a double-precision floating-point scalar
endif::GLSL[]
| *vec2*    | a two-component single-precision floating-point vector
| *vec3*    | a three-component single-precision floating-point vector
| *vec4*    | a four-component single-precision floating-point vector
ifdef::GLSL[]
| *dvec2*   | a two-component double-precision floating-point vector
| *dvec3*   | a three-component double-precision floating-point vector
| *dvec4*   | a four-component double-precision floating-point vector
endif::GLSL[]
| *bvec2*   | a two-component Boolean vector
| *bvec3*   | a three-component Boolean vector
| *bvec4*   | a four-component Boolean vector
| *ivec2*   | a two-component signed integer vector
| *ivec3*   | a three-component signed integer vector
| *ivec4*   | a four-component signed integer vector
| *uvec2*   | a two-component unsigned integer vector
| *uvec3*   | a three-component unsigned integer vector
| *uvec4*   | a four-component unsigned integer vector
| *mat2*    | a 2 {times} 2 single-precision floating-point matrix
| *mat3*    | a 3 {times} 3 single-precision floating-point matrix
| *mat4*    | a 4 {times} 4 single-precision floating-point matrix
| *mat2x2*  | same as a *mat2*
| *mat2x3*  | a single-precision floating-point matrix with 2 columns and 3 rows
| *mat2x4*  | a single-precision floating-point matrix with 2 columns and 4 rows
| *mat3x2*  | a single-precision floating-point matrix with 3 columns and 2 rows
| *mat3x3*  | same as a *mat3*
| *mat3x4*  | a single-precision floating-point matrix with 3 columns and 4 rows
| *mat4x2*  | a single-precision floating-point matrix with 4 columns and 2 rows
| *mat4x3*  | a single-precision floating-point matrix with 4 columns and 3 rows
| *mat4x4*  | same as a *mat4*
ifdef::GLSL[]
| *dmat2*   | a 2 {times} 2 double-precision floating-point matrix
| *dmat3*   | a 3 {times} 3 double-precision floating-point matrix
| *dmat4*   | a 4 {times} 4 double-precision floating-point matrix
| *dmat2x2* | same as a *dmat2*
| *dmat2x3* | a double-precision floating-point matrix with 2 columns and 3 rows
| *dmat2x4* | a double-precision floating-point matrix with 2 columns and 4 rows
| *dmat3x2* | a double-precision floating-point matrix with 3 columns and 2 rows
| *dmat3x3* | same as a *dmat3*
| *dmat3x4* | a double-precision floating-point matrix with 3 columns and 4 rows
| *dmat4x2* | a double-precision floating-point matrix with 4 columns and 2 rows
| *dmat4x3* | a double-precision floating-point matrix with 4 columns and 3 rows
| *dmat4x4* | same as a *dmat4*
endif::GLSL[]
|====

Note that where the following tables say "`accessing a texture`", the
*+sampler*+* opaque types access textures, and the *+image*+* opaque types
access images, of a specified type.


*Floating-Point Opaque Types*

[options="header"]
|====
| Type                      | Meaning
ifdef::GLSL[]
| *sampler1D* +
  *texture1D* +
  *image1D*                 | a handle for accessing a 1D texture
| *sampler1DShadow*         | a handle for accessing a 1D depth texture with comparison
| *sampler1DArray* +
  *texture1DArray* +
  *image1DArray*            | a handle for accessing a 1D array texture
| *sampler1DArrayShadow*    | a handle for accessing a 1D array depth texture with comparison
endif::GLSL[]
| *sampler2D* +
  *texture2D* +
  *image2D*                 | a handle for accessing a 2D texture
| *sampler2DShadow*         | a handle for accessing a 2D depth texture with comparison
| *sampler2DArray* +
  *texture2DArray* +
  *image2DArray*            | a handle for accessing a 2D array texture
| *sampler2DArrayShadow*    | a handle for accessing a 2D array depth texture with comparison
ifdef::GLSL[]
| *sampler2DMS* +
  *texture2DMS* +
  *image2DMS*
endif::GLSL[]
ifdef::ESSL[]
| *sampler2DMS* +
  *texture2DMS*
endif::ESSL[]
                            | a handle for accessing a 2D multisample texture
ifdef::GLSL[]
| *sampler2DMSArray* +
  *texture2DMSArray* +
  *image2DMSArray*
endif::GLSL[]
ifdef::ESSL[]
| *sampler2DMSArray*
endif::ESSL[]
                            | a handle for accessing a 2D multisample array texture
ifdef::GLSL[]
| *sampler2DRect* +
  *texture2DRect* +
  *image2DRect*             | a handle for accessing a rectangle texture
| *sampler2DRectShadow*     | a handle for accessing a rectangle texture with comparison
endif::GLSL[]
| *sampler3D* +
  *texture3D* +
  *image3D*                 | a handle for accessing a 3D texture
| *samplerCube* +
  *textureCube* +
  *imageCube*               | a handle for accessing a cube mapped texture
| *samplerCubeShadow*       | a handle for accessing a cube map depth texture with comparison
| *samplerCubeArray* +
  *textureCubeArray* +
  *imageCubeArray*          | a handle for accessing a cube map array texture
| *samplerCubeArrayShadow*  | a handle for accessing a cube map array depth texture with comparison
| *samplerBuffer* +
  *textureBuffer* +
  *imageBuffer*             | a handle for accessing a buffer texture
| *subpassInput*            | a handle for accessing a floating-point subpass input
| *subpassInputMS*          | a handle for accessing a multi-sampled floating-point subpass input
|====


*Signed Integer Opaque Types*

[options="header"]
|====
| Type                    | Meaning
ifdef::GLSL[]
| *isampler1D* +
  *itexture1D* +
  *iimage1D*              | a handle for accessing an integer 1D texture
| *isampler1DArray* +
  *itexture1DArray* +
  *iimage1DArray*         | a handle for accessing an integer 1D array texture
endif::GLSL[]
| *isampler2D* +
  *itexture2D* +
  *iimage2D*              | a handle for accessing an integer 2D texture
| *isampler2DArray* +
  *itexture2DArray* +
  *iimage2DArray*         | a handle for accessing an integer 2D array texture
ifdef::GLSL[]
| *isampler2DMS* +
  *itexture2DMS* +
  *iimage2DMS*
endif::GLSL[]
ifdef::ESSL[]
| *isampler2DMS* +
  *itexture2DMS*
endif::ESSL[]
                          | a handle for accessing an integer 2D multisample texture
ifdef::GLSL[]
| *isampler2DMSArray* +
  *itexture2DMSArray* +
  *iimage2DMSArray*
endif::GLSL[]
ifdef::ESSL[]
| *isampler2DMSArray* +
  *itexture2DMSArray*
endif::ESSL[]
                          | a handle for accessing an integer 2D multisample array texture
ifdef::GLSL[]
| *isampler2DRect* +
  *itexture2DRect* +
  *iimage2DRect*          | a handle for accessing an integer 2D rectangle texture
endif::GLSL[]
| *isampler3D* +
  *itexture3D* +
  *iimage3D*              | a handle for accessing an integer 3D texture
| *isamplerCube* +
  *itextureCube* +
  *iimageCube*            | a handle for accessing an integer cube mapped texture
| *isamplerCubeArray* +
  *itextureCubeArray* +
  *iimageCubeArray*       | a handle for accessing an integer cube map array texture
| *isamplerBuffer* +
  *itextureBuffer* +
  *iimageBuffer*          | a handle for accessing an integer buffer texture
| *isubpassInput*         | a handle for accessing an integer subpass input
| *isubpassInputMS*       | a handle for accessing a multi-sampled integer subpass input
|====


*Unsigned Integer Opaque Types*

[options="header"]
|====
| Type | Meaning
ifdef::GLSL[]
| *usampler1D* +
  *utexture1D* +
  *uimage1D*
    | a handle for accessing an unsigned integer 1D texture
| *usampler1DArray* +
  *utexture1DArray* +
  *uimage1DArray*
    | a handle for accessing an unsigned integer 1D array texture
endif::GLSL[]
| *usampler2D* +
  *utexture2D* +
  *uimage2D*
    | a handle for accessing an unsigned integer 2D texture
| *usampler2DArray* +
  *utexture2DArray* +
  *uimage2DArray*
    | a handle for accessing an unsigned integer 2D array texture
ifdef::GLSL[]
| *usampler2DMS* +
  *utexture2DMS* +
  *uimage2DMS*
endif::GLSL[]
ifdef::ESSL[]
| *usampler2DMS* +
  *utexture2DMS*
endif::ESSL[]
    | a handle for accessing an unsigned integer 2D multisample texture
ifdef::GLSL[]
| *usampler2DMSArray* +
  *utexture2DMSArray* +
  *uimage2DMSArray*
endif::GLSL[]
ifdef::ESSL[]
| *usampler2DMSArray* +
  *utexture2DMSArray*
endif::ESSL[]
    | a handle for accessing an unsigned integer 2D multisample array texture
ifdef::GLSL[]
| *usampler2DRect* +
  *utexture2DRect* +
  *uimage2DRect*
    | a handle for accessing an unsigned integer rectangle texture
endif::GLSL[]
| *usampler3D* +
  *utexture3D* +
  *uimage3D*
    | a handle for accessing an unsigned integer 3D texture
| *usamplerCube* +
  *utextureCube* +
  *uimageCube*
    | a handle for accessing an unsigned integer cube mapped texture
| *usamplerCubeArray* +
  *utextureCubeArray* +
  *uimageCubeArray*
    | a handle for accessing an unsigned integer cube map array texture
| *usamplerBuffer* +
  *utextureBuffer* +
  *uimageBuffer*
    | a handle for accessing an unsigned integer buffer texture
| *atomic_uint*
    | a handle for accessing an unsigned integer atomic counter
| *usubpassInput*          | a handle for accessing an unsigned-integer subpass input
| *usubpassInputMS*        | a handle for accessing a multi-sampled unsigned-integer subpass input
|====

*Sampler Opaque Types*

[options="header"]
|====
| Type                    | Meaning
| *sampler*               | a handle for accessing state describing how to sample a texture
| *samplerShadow*         | a handle for accessing state describing how to sample a depth
                            texture with comparison
|====

In addition, a shader can aggregate these basic types using arrays and
structures to build more complex types.

There are no pointer types.

ifdef::GLSL[]
In this specification, an _aggregate_ will mean a structure or array.
(Matrices and vectors are not by themselves aggregates.) Aggregates,
matrices, and vectors will collectively be referred to as _composites_.
endif::GLSL[]


[[void]]
=== Void

Functions that do not return a value must be declared as *void*.
There is no default function return type.
The keyword *void* cannot be used in any other declarations (except for
empty formal or actual parameter lists), or {compiletimeerror} results.


[[booleans]]
=== Booleans

Definition::
A _boolean type_ is any boolean scalar or vector type (*bool*, *bvec2*,
*bvec3*, *bvec4*)

To make conditional execution of code easier to express, the type *bool* is
supported.
There is no expectation that hardware directly supports variables of this
type.
It is a genuine Boolean type, holding only one of two values meaning either
true or false.
Two keywords *true* and *false* can be used as literal Boolean constants.
Booleans are declared and optionally initialized as in the follow example:

[source,glsl]
----
bool success;      // declare "success" to be a Boolean
bool done = false; // declare and initialize "done"
----

Expressions used for conditional jumps (*if*, *for*, *?:*, *while*,
*do*-*while*) must evaluate to the type *bool*.


[[integers]]
=== Integers

Definitions::
An _integral type_ is any signed or unsigned, scalar or vector integer type.
It excludes arrays and structures.

{empty}:: A _scalar integral type_ is a scalar signed or unsigned integer type:

{empty}:: A _vector integral type_ is a vector of signed or unsigned integers:

Signed and unsigned integer variables are fully supported.
In this document, the term _integer_ is meant to generally include both
signed and unsigned integers.

ifdef::GLSL[For OpenGL, unsigned integers have exactly 32 bits of precision.]
ifdef::GLSL[When targeting Vulkan, *highp*]
ifdef::ESSL[*highp*]
unsigned integers have exactly 32 bits of precision.

ifdef::GLSL[For OpenGL, signed integers use 32 bits, including a sign bit, in two's complement form.]
ifdef::GLSL[When targeting Vulkan, *highp*]
ifdef::ESSL[*highp*]
signed integers use 32 bits, including a sign bit, in two's complement form.

When targeting Vulkan, *mediump* and *lowp* integers are as defined by the
SPIR-V *RelaxedPrecision* decoration.
ifdef::ESSL[]
Otherwise, *mediump* and *lowp* integers have implementation-defined numbers of bits.
See "`<<range-and-precision,Range and Precision>>`" for details.
endif::ESSL[]

ifdef::ESSL[For all precisions, addition,]
ifdef::GLSL[Addition,]
subtraction and multiplication resulting in overflow or
underflow will result in the low-order
ifdef::GLSL[32]
ifdef::ESSL[n]
bits of the correct result R, where
ifdef::ESSL[n is the size in bits of the integer and]
R is computed with enough precision to avoid overflow or underflow.
Division resulting in overflow will result in an undefined value.

Integers are declared and optionally initialized with integer expressions,
as in the following example:

[source,glsl]
----
int i, j = 42; // default integer literal type is int
uint k = 3u;   // "u" establishes the type as uint
----

Literal integer constants can be expressed in decimal (base 10), octal (base
8), or hexadecimal (base 16) as follows.

[role="bnf"]
--
_integer-constant_ : ::
    _decimal-constant_ _integer-suffix~opt~_ +
    _octal-constant_ _integer-suffix~opt~_ +
    _hexadecimal-constant_ _integer-suffix~opt~_

_integer-suffix_ : one of ::
    *u* *U*

_decimal-constant_ : ::
    _nonzero-digit_ +
    _decimal-constant_ _digit_

_octal-constant_ : ::
    *0* +
    _octal-constant_ _octal-digit_

_hexadecimal-constant_ : ::
    *0x* _hexadecimal-digit_ +
    *0X* _hexadecimal-digit_ +
    _hexadecimal-constant_ _hexadecimal-digit_

_digit_ : ::
    *0* +
    _nonzero-digit_

_nonzero-digit_ : one of ::
    *1 2 3 4 5 6 7 8 9*

_octal-digit_ : one of ::
    *0 1 2 3 4 5 6 7*

_hexadecimal-digit_ : one of ::
    *0 1 2 3 4 5 6 7 8 9 +
    a b c d e f +
    A B C D E F*
--

No white space is allowed between the digits of an integer constant,
including after the leading *0* or after the leading *0x* or *0X* of a
constant, or before the suffix *u* or *U*.
ifdef::GLSL[]
When tokenizing, the maximal token matching the above will be recognized
before a new token is started.
endif::GLSL[]
When the suffix *u* or *U* is present, the literal has type *uint*,
otherwise the type is *int*.
A leading unary minus sign (-) is interpreted as an arithmetic unary
negation, not as part of the constant.
Hence, literals themselves are always expressed with non-negative syntax,
though they could result in a negative value.

It is {compiletimeerror} to provide a literal integer whose bit pattern
cannot fit in 32 bits.
The bit pattern of the literal is always used unmodified.
So a signed literal whose bit pattern includes a set sign bit creates a
negative value.

For example,

[source,glsl]
----
1             // OK. Signed integer, value 1
1u            // OK. Unsigned integer, value 1
-1            // OK. Unary minus applied to signed integer.
              // result is a signed integer, value -1
-1u           // OK. Unary minus applies to unsigned integer.
              // Result is an unsigned integer, value 0xffffffff
0xA0000000    // OK. 32-bit signed hexadecimal
0xABcdEF00u   // OK. 32-bit unsigned hexadecimal
0xffffffff    // OK. Signed integer, value -1
0x80000000    // OK. Evaluates to -2147483648
0xffffffffu   // OK. Unsigned integer, value 0xffffffff
0xfffffffff   // Error: needs more than 32 bits
3000000000    // OK. A signed decimal literal taking 32 bits.
              // It evaluates to -1294967296
2147483648    // OK. Evaluates to -2147483648 (the literal set the sign bit)
5000000000    // Error: needs more than 32 bits
----


[[floats]]
=== Floats

ifdef::GLSL[]
Single-precision and double-precision floating-point variables are available
for use in a variety of scalar calculations.
Generally, the term _floating-point_ will refer to both single- and
double-precision floating-point.
Floating-point variables are defined as in the following examples:

[source,glsl]
----
float a, b = 1.5;    // single-precision floating-point
double c, d = 2.0LF; // double-precision floating-point
----

As an input value to one of the processing units, a single-precision or
double-precision floating-point variable is expected to match the
corresponding IEEE 754 floating-point definition for precision and dynamic
range.
Floating-point variables within a shader are also encoded according to the
IEEE 754 specification for single-precision floating-point values
endif::GLSL[]
ifdef::ESSL[]

Definition::
A _floating-point type_ is any floating-point scalar, vector or matrix type.
It excludes arrays and structures.

Floats are available for use in a variety of scalar calculations.
Floating-point variables are defined as in the following example:

[source,glsl]
----
float a, b = 1.5;
----

As an input value to one of the processing units, a floating-point variable
is expected to match the IEEE 754 single precision floating-point definition
for precision and dynamic range.
*highp* floating-point variables within a shader are encoded according to
the IEEE 754 specification for single-precision floating-point values
endif::ESSL[]
(logically, not necessarily physically).
While encodings are logically IEEE 754, operations (addition,
multiplication, etc.) are not necessarily performed as required by IEEE 754.
See "`<<range-and-precision,Range and Precision>>`" for more details on
precision and usage of NaNs (Not a Number) and Infs (positive or negative
infinities).

Floating-point constants are defined as follows.

[role="bnf"]
--
_floating-constant_ : ::
    _fractional-constant_ _exponent-part~opt~_ _floating-suffix~opt~_ +
    _digit-sequence_ _exponent-part_ _floating-suffix~opt~_

_fractional-constant_ : ::
    _digit-sequence_ *.* _digit-sequence_ +
    _digit-sequence_ *.* +
    *.* _digit-sequence_

_exponent-part_ : ::
    *e* _sign~opt~_ _digit-sequence_ +
    *E* _sign~opt~_ _digit-sequence_

_sign_ : one of ::
    *+* *-*

_digit-sequence_ : ::
    _digit_ +
    _digit-sequence_ _digit_

_floating-suffix_ : one of ::
    *f* *F*
ifdef::GLSL[*lf* *LF*]
--

A decimal point (*.*) is not needed if the exponent part is present.
No white space may appear anywhere within a floating-point constant,
including before a suffix.
ifdef::GLSL[]
When tokenizing, the maximal token matching the above will be recognized
before a new token is started.
When the suffix "lf" or "LF" is present, the literal has type *double*.
Otherwise, the literal has type *float*.
endif::GLSL[]
A leading unary minus sign (*-*) is interpreted as a unary operator and is
not part of the floating-point constant.

ifdef::ESSL[]
There is no limit on the number of digits in any _digit-sequence_.
If the value of the floating-point number is too large (small) to be stored
as a single precision value, it is converted to positive (negative)
infinity.
A value with a magnitude too small to be represented as a mantissa and
exponent is converted to zero.
Implementations may also convert subnormal (denormalized) numbers to zero.
endif::ESSL[]


[[vectors]]
=== Vectors

The {slname} includes data types for generic 2-, 3-, and 4-component vectors
of floating-point values, integers, and Booleans.
Floating-point vector variables can be used to store colors, normals,
positions, texture coordinates, texture lookup results and the like.
Boolean vectors can be used for component-wise comparisons of numeric
vectors.
Some examples of vector declarations are:

[source,glsl]
----
vec2 texcoord1, texcoord2;
vec3 position;
vec4 myRGBA;
ivec2 textureLookup;
bvec3 less;
----

Initialization of vectors can be done with constructors.
See "`<<vector-and-matrix-constructors,Vector and Matrix Constructors>>`".


[[matrices]]
=== Matrices

The {slname} has built-in types for 2 {times} 2, 2 {times} 3, 2 {times} 4, 3
{times} 2, 3 {times} 3, 3 {times} 4, 4 {times} 2, 4 {times} 3, and 4 {times}
4 matrices of floating-point numbers.
ifdef::GLSL[]
Matrix types beginning with "*mat*" have single-precision components while
matrix types beginning with "*dmat*" have double-precision components.
endif::GLSL[]
The first number in the type is the number of columns, the second is the
number of rows.
If there is only one number, the matrix is square.
Example matrix declarations:

[source,glsl]
----
mat2 mat2D;
mat3 optMatrix;
mat4 view, projection;
mat4x4 view; // an alternate way of declaring a mat4
mat3x2 m;    // a matrix with 3 columns and 2 rows
ifdef::GLSL[]
dmat4 highPrecisionMVP;
dmat2x4 dm;
endif::GLSL[]
----

Initialization of matrix values is done with constructors (described in
"`<<vector-and-matrix-constructors,Vector and Matrix Constructors>>`") in
column-major order.

ifdef::ESSL[]
*mat2* is an alias for *mat2x2*, not a distinct type.
Similarly for *mat3* and *mat4.* The following is legal:

[source,glsl]
----
mat2 a;
mat2x2 b = a;
----
endif::ESSL[]


[[opaque-types]]
=== Opaque Types

Definition::
An _opaque type_ is a type where the internal structure of the type is
hidden from the language.

The opaque types, as listed in the following sections, declare variables
that are effectively opaque handles to other objects.
These objects are accessed through built-in functions, not through direct
reading or writing of the declared variable.
They can only be declared as function parameters or in **uniform**-qualified
variables (see "`<<uniform-variables,Uniform Variables>>`").
The only opaque types that take memory qualifiers are the image types.
Except for array indexing, structure member selection, and parentheses,
opaque variables are not allowed to be operands in expressions; such use
results in a compile-time error.

When aggregated into arrays within a shader, opaque types can only be
indexed with a dynamically uniform integral expression (see "`Dynamically
Uniform Expressions`") unless otherwise noted; otherwise, results are
undefined.

Opaque variables cannot be treated as l-values; hence cannot be used as
*out* or *inout* function parameters, nor can they be assigned into.
Any such use results in a compile-time error.
However, they can be passed as *in* parameters with matching types and
memory qualifiers.
They cannot be declared with an initializer.

Because a single opaque type declaration effectively declares two objects,
the opaque handle itself and the object it is a handle to, there is room for
both a storage qualifier and a memory qualifier.
The storage qualifier will qualify the opaque handle, while the memory
qualifier will qualify the object it is a handle to.


[[samplers]]
==== Texture-Combined Samplers

Texture-combined sampler types (e.g. *sampler2D*) are the sampler types
described in the Basic Types tables as handles for accessing textures.
(They do not include *sampler* and *samplerShadow*.)
There are distinct texture-combined sampler types for each texture target,
and for each of float, integer, and unsigned integer data types.
Texture accesses are done through built-in texture functions (described in
"`<<texture-functions,Texture Functions>>`") and texture-combined samplers
are used to specify which texture to access and how it is to be filtered.

Texture-combined sampler types are opaque types,
declared and behaving as described above for opaque types.

[[images]]
==== Images

Image types are opaque types, declared and behaving as described above for
opaque types.
They can be further qualified with memory qualifiers.
ifdef::ESSL[]
When aggregated into arrays within a shader, images can only be indexed with
a constant integral expression.
endif::ESSL[]

Image variables are handles to
ifdef::GLSL[one-,]
two-, or three-dimensional images
corresponding to all or a portion of a single level of a texture image bound
to an image unit.
There are distinct image variable types for each texture target, and for
each of float, integer, and unsigned integer data types.
Image accesses should use an image type that matches the target of the
texture whose level is bound to the image unit, or for non-layered bindings
of 3D or array images should use the image type that matches the
dimensionality of the layer of the image (i.e., a layer of 3D, 2DArray,
Cube, or CubeArray should use
ifdef::ESSL[*image2D*).]
ifdef::GLSL[]
*image2D*, a layer of 1DArray should use *image1D*, and a layer of 2DMSArray
should use *image2DMS*).
endif::GLSL[]
If the image target type does not match the bound image in this manner, if
the data type does not match the bound image, or if the format layout
qualifier does not match the image unit format as described in section
ifdef::GLSL[8.25]
ifdef::ESSL[8.22]
"`Texture Image Loads and Stores`" of the <<references,{apispec}>>, the
results of image accesses are undefined but cannot include program
termination.

Image variables are used in the image load, store, and atomic functions
described in "`<<image-functions,Image Functions>>`" to specify an image to
access.


[[atomic-counters]]
==== Atomic Counters

Atomic counter types (e.g. *atomic_uint*) are opaque handles to counters,
declared and behaving as described above for opaque types.
The variables they declare specify which counter to access when using the
built-in atomic counter functions as described in
"`<<atomic-counter-functions,Atomic Counter Functions>>`".
They are bound to buffers as described in
"`<<atomic-counter-layout-qualifiers,Atomic Counter Layout Qualifiers>>`".

Members of structures cannot be declared as atomic counter types.

ifdef::ESSL[]
The default precision of all atomic types is *highp*.
It is an error to declare an atomic type with a different precision or to
specify the default precision for an atomic type to be *lowp* or *mediump*.
endif::ESSL[]

Atomic counter types are not available when targeting Vulkan.

==== Texture, *sampler*, and *samplerShadow* Types

Texture (e.g., *texture2D*), *sampler*, and *samplerShadow* types are opaque
types, declared and behaving as described above for opaque types.
These types are only available when targeting Vulkan.
Texture variables are handles to one-, two-, and three-dimensional textures,
cube maps, etc., as enumerated in the basic types tables.
There are distinct texture types for each texture target, and for each of
float, integer, and unsigned integer data types.
Textures can be combined with a variable of type *sampler* or *samplerShadow*
to create a texture-combined sampler type (e.g., sampler2D, or sampler2DShadow).
This is done with a constructor, e.g., `sampler2D(texture2D, sampler)`,
`sampler2DShadow(texture2D, sampler)`, `sampler2DShadow(texture2D, samplerShadow)`,
or `sampler2D(texture2D, samplerShadow)` and is described in more detail
in section 5.4 "Constructors".

==== Subpass Inputs

Subpass-input types are only available when targeting Vulkan.

Subpass-input types (e.g., *subpassInput*) are opaque types, declared
and behaving as described above for opaque types.

Subpass-input types are handles to two-dimensional single sampled or
multi-sampled images, with distinct types for each of float, integer,
and unsigned integer data types.

Subpass-input types are only available in fragment shaders.  It is
{compiletimeerror} to use them in any other stage.

[[structures]]
=== Structures

User-defined types can be created by aggregating other already defined types
into a structure using the *struct* keyword.
For example,

[source,glsl]
----
struct light {
    float intensity;
    vec3 position;
} lightVar;
----

In this example, _light_ becomes the name of the new type, and _lightVar_
becomes a variable of type _light_.
To declare variables of the new type, use its name (without the keyword
*struct*).

[source,glsl]
----
light lightVar2;
----

More formally, structures are declared as follows.
However, the definitive grammar is as given in
"`<<shading-language-grammar,Shading Language Grammar>>`".

[role="bnf"]
--
_struct-definition_ : ::
    _qualifier~opt~_ *struct* name~opt~_ *{* _member-list_ *}*
    _declarators~opt~_ *;*

_member-list_ : ::
    _member-declaration_ *;* +
    _member-declaration_ _member-list_ *;*

_member-declaration_ : ::
    _basic-type_ _declarators_ *;*
--

where _name_ becomes the user-defined type, and can be used to declare
variables to be of this new type.
The _name_ shares the same name space as other variables, types, and
functions.
All previously visible variables, types, constructors, or functions with
that name are hidden.
The optional _qualifier_ only applies to any _declarators_, and is not part
of the type being defined for _name_.

Structures must have at least one member declaration.
Bit fields are not supported.
Member types must be already defined (there are no forward references).

Member declarations may contain precision qualifiers, but use of any other
qualifier results in {compiletimeerror}. Where a member declaration does not
include a precision qualifier the member's precision is inferred as described
in <<default-precision-qualifiers, Default Precision Qualifiers>> at the point
of the struct type's declaration.

A compile-time error results if a member declaration contains an
initializer.
Member declarators can contain arrays.
Such arrays must have a size specified, and the size must be a constant
integral expression that's greater than zero (see
"`<<constant-expressions,Constant Expressions>>`").
Each level of structure has its own name space for names given in member
declarators; such names need only be unique within that name space.

Anonymous structures are not supported.
Embedded structure definitions are not supported.
ifdef::GLSL[These result in compile-time errors.]

[source,glsl]
----
struct S { float f; }; // Allowed: S is defined as a structure.

struct T {
    S;              // Error: anonymous structures disallowed
    struct { ... }; // Error: embedded structures disallowed
    S s;            // Allowed: nested structure with a name.
};
----

Structures can be initialized at declaration time using constructors, as
discussed in "`<<structure-constructors,Structure Constructors>>`".

Any restrictions on the usage of a type or qualifier also apply to any
structure that contains a member of that type or qualifier.
This also applies to structure members that are structures, recursively.

ifdef::ESSL[]
Structures can contain variables of any type except:

  * *atomic_uint* (since there is no mechanism to specify the binding)
  * image types (since there is no mechanism to specify the format
    qualifier)
endif::ESSL[]


[[arrays]]
=== Arrays

Variables of the same type can be aggregated into arrays by declaring a name
followed by brackets (*[ ]*) enclosing an optional size.
When present, the array size must be a constant integral expression (see
"`<<constant-expressions,Constant Expressions>>`") greater than zero.
The type of the size parameter can be a signed or unsigned integer and the
choice of type does not affect the type of the resulting array.
Arrays only have a single dimension (a single number within "`[ ]`"),
however, arrays of arrays can be declared.
Any type can be formed into an array.

There are 3 types of array objects:

  Explicitly Sized:: The number of elements in the array is explicitly given.
  Runtime Sized:: The number of elements is not given and the array is the
                  outermost dimension of the last declared member of a shader
                  storage block (see section "`<<interface-blocks,Interface
                  Blocks>>`"). The array size is inferred at run-time from the
                  size of the data store backing the shader storage block.
  Unsized:: The number of array elements is not given and the array
            is not runtime sized.

Unsized arrays may become explicitly sized following either an explicitly-sized
initializer or a redeclaration with an explicit size (Explicitly-sized and
runtime-sized arrays may not be redeclared).
It is a compile-time error to redeclare an array with a different underlying
member type.

ifdef::GLSL[]
Note, however, unless noted otherwise, blocks cannot be redeclared; so an unsized
array member in a user-declared block cannot be sized by a block redeclaration.
endif::GLSL[]

It is {compiletimeerror} if, following any initializer, an array contains any type that
is or includes an unsized array.

ifdef::ESSL[]
Unsized arrays are used for certain builtin variables but it is an error if a
user-declared array remains unsized following its initializer.
endif::ESSL[]

It is {compiletimeerror} if:

 * an unsized array is indexed with anything other than a constant integral expression.
 * an unsized array is declared as a formal parameter to a function.
 * an unsized array is declared as the return type of a function.
 * a runtime-sized or unsized array is passed as a function argument.
 * any array is indexed using a negative constant expression.
 * an explicitly sized array is indexed with a constant expression greater than
   or equal to the declared size.
 * an unsized array is redeclared with a size less than or equal to any
   constant index used earlier in the shader to index the array.

Undefined behavior results from indexing an array with a non-constant
expression that's greater than or equal to the array's size or less than 0.

[NOTE]
.Note
====
Some features outside the scope of GLSL, for example OpenGL or Vulkan's "Robust
Buffer Access" features, may further constrain what behaviors are valid here.
Typically these features will prevent out-of-bounds indexing causing program
termination and may determine which values must be returned.
====

[NOTE]
.Note
====
All arrays are inherently homogeneous; made of elements all having the same
type and size, with one exception.
An array of shader storage blocks whose last member is a runtime-sized array
allows the individual blocks to have different sizes and hence a different
number of elements in the trailing array.
====


Some examples of array declarations are:

[source,glsl]
----
float frequencies[3];
uniform vec4 lightPosition[4u];
light lights[];            // Unsized. Valid in GLSL, illegal in ESSL.
const int numLights = 2;
light lights[numLights];
vec4 a[3][2];

// a shader storage block, introduced in section 4.3.7 "Buffer Variables"
buffer b {
    float u[]; // an error, unless u gets statically sized by link time
    vec4 v[];  // okay, v will be sized dynamically, if not statically
} name[3];     // when the block is arrayed, all u will be the same size,
               // but not necessarily all v, if sized dynamically
----

An array type can be formed by specifying a non-array type
(<<type_specifier_nonarray>>) followed by an <<array_specifier>>.
Note that in this context the construct _type [size]_ does not always result in
an array of length _size_ of type _type_.
For example,

[source,glsl]
----
float[5]    // an array of size [5] of float
float[2][3] // an array of size [2] of array of size [3] of float,
            // not size [3] of float[2]
----

Such an array type can be used anywhere any other type can be used, including
as the return value from a function, as a constructor of an array and in
declarations.

[source,glsl]
----
// As a function return type
float[5] foo() { }
// As an array constructor
float[5](3.4, 4.2, 5.0, 5.2, 1.1)
// In declaring an unnamed parameter
void foo(float[5])
// In normal declarations
float[5] a;

// The following 3 declarations are equivalent:
vec4 a[3][2]; // size-3 array of size-2 array of vec4
vec4[2] a[3];
vec4[3][2] a;
----

If such an array type is unsized and used as a constructor then the size of the
array is inferred from the constructor arguments. For example,
[source,glsl]
----
float a[5] = float[5](3.4, 4.2, 5.0, 5.2, 1.1);
float a[5] = float[](3.4, 4.2, 5.0, 5.2, 1.1);  // Constructor also of type float[5]
----

It is {compiletimeerror} to assign either to or from a runtime-sized or unsized
array (rather than specific elements).
Note, this is a rare case that initializers and assignments appear to have
different semantics.
An initializer for an unsized array is valid and will size the array, but the
equivalent assigment is not valid.
For example,
[source,glsl]
----
float a[5];
float b[];
// An initializer sizes an array ...
float c[] = a;  // c is explicitly size 5
// ... but the equivalent assignment is not valid
float d[];
d = a;          // Error. Assignment to an unsized array
// It is never valid to assign from an unsized array
float e[] = b;  // Error. b is unsized so cannot be assigned
----

ifdef::GLSL[]
Alternatively, the initializer-list syntax can be used to initialize an
array of arrays:

[source,glsl]
----
vec4 a[3][2] = { vec4[2](vec4(0.0), vec4(1.0)),
                 vec4[2](vec4(0.0), vec4(1.0)),
                 vec4[2](vec4(0.0), vec4(1.0)) };
----

For arrays of arrays, any unsized dimension is explicitly sized by the
initializer:

[source,glsl]
----
vec4 a[][] = { vec4[2](vec4(0.0), vec4(1.0)), // okay, size to a[3][2]
               vec4[2](vec4(0.0), vec4(1.0)),
               vec4[2](vec4(0.0), vec4(1.0)) };
----
endif::GLSL[]

When in transparent memory (like in a uniform block), the layout is that the
inner-most (right-most in declaration) dimensions iterate faster than the
outer dimensions.
That is, for the above, the order in memory would be:

{empty}:: Low address : a[0][0] : a[0][1] : a[1][0] : a[1][1] : a[2][0] : a[2][1]
     : High address

ifdef::ESSL[]
Any restrictions on the usage of a type also apply to arrays of that type.
This applies recursively.
endif::ESSL[]


==== The *length*() Method

The number of elements in an array can be obtained by using the *length*()
method:

[source,glsl]
----
float a[5];
a.length(); // returns 5

vec4 a[3][2];
a.length()    // returns 3
a[x].length() // returns 2
----

The return value has type *int*.

It is {compiletimeerror} to use the *length*() method on an unsized array.
The return value is a constant expression if and only if the array is
explicitly-sized.

When the *length*() method returns a compile-time constant, the expression the
*length*() method is applied to will be parsed and is subject to the normal
language rules but any arrays will not be dereferenced.
This means that the value returned is well-defined even if the indices are out
of bounds at runtime.
Note, however, that because indices which are constant expressions are still
checked, an error will still be generated for constant indexing out-of-bounds.

When the *length*() method returns a compile-time constant and the expression the
*length*() method is applied to contains any side effects (such as writes
to l-values within the expression, or function calls that themselves have side
effects), behavior is undefined.
A compile- or link-time error may be given by the implementation but this is
not required.

[source,glsl]
----
float a, b;
float[2](a=3.0, ++b).length(); // Behavior undefined. Illegal side effects

float c[5][3];
c[7].length(); // Error. Static indexing out of bounds.
c[i].length(); // Valid, returns 3 even if i < 0 or i >= 5 at runtime.

struct S {
    float a[3];
} s[5];
s[i+3].a.length(); // Valid. Returns 3 for all inputs i.
s[i++].a.length(); // Behavior undefined. Illegal side-effects.

buffer B {
    float x[3];
    float y[];
} b[5];
b[i++].x.length(); // Behaviour undefined. Illegal side-effects.
b[i++].y.length(); // Valid. i is incremented and b dereferenced. The runtime size
                   // of y is returned if 0 <= x < 5, behavior undefined if not.
----

The precision is determined using the same rules as for other cases where
there is no intrinsic precision.
See "`<<precision-qualifiers,Precision Qualifiers>>`".


// There is a gigantic block of GLSL/ESSL differences starting here
// and going down through the Storage Qualifiers section. Apparently
// there was a complete rewrite by one spec, probably ESSL, as virtually
// no language is shared

ifdef::GLSL[]
[[implicit-conversions]]
=== Implicit Conversions

In some situations, an expression and its type will be implicitly converted
to a different type.
The following table shows all allowed implicit conversions:

[options="header"]
|====
| Type of expression | Can be implicitly converted to
| *int*              | *uint*
| *int* +
  *uint*             | *float*
| *int* +
  *uint* +
  *float*            | *double*
| *ivec2*            | *uvec2*
| *ivec3*            | *uvec3*
| *ivec4*            | *uvec4*
| *ivec2* +
  *uvec2*            | *vec2*
| *ivec3* +
  *uvec3*            | *vec3*
| *ivec4* +
  *uvec4*            | *vec4*
| *ivec2* +
  *uvec2* +
  *vec2*             | *dvec2*
| *ivec3* +
  *uvec3* +
  *vec3*             | *dvec3*
| *ivec4* +
  *uvec4* +
  *vec4*             | *dvec4*
| *mat2*             | *dmat2*
| *mat3*             | *dmat3*
| *mat4*             | *dmat4*
| *mat2x3*           | *dmat2x3*
| *mat2x4*           | *dmat2x4*
| *mat3x2*           | *dmat3x2*
| *mat3x4*           | *dmat3x4*
| *mat4x2*           | *dmat4x2*
| *mat4x3*           | *dmat4x3*
|====

There are no implicit array or structure conversions.
For example, an array of *int* cannot be implicitly converted to an array of
*float*.

When an implicit conversion is done, it is the same conversion that would be
done under explicit conversion, using a constructor.
The explicit conversions via constructors are described in
<<conversion-and-scalar-constructors, Conversion and Scalar Constructors>>.

When performing implicit conversion for binary operators, there may be
multiple data types to which the two operands can be converted.
For example, when adding an *int* value to a *uint* value, both values can
be implicitly converted to *uint*, *float*, and *double*.
In such cases, a floating-point type is chosen if either operand has a
floating-point type.
Otherwise, an unsigned integer type is chosen if either operand has an
unsigned integer type.
Otherwise, a signed integer type is chosen.
If operands can be implicitly converted to multiple data types deriving from
the same base data type, the type with the smallest component size is used.

The conversions in the table above are done only as indicated by other
sections of this specification.


[[initializers]]
=== Initializers

At declaration, an initial value for a variable may be provided, specified
as an equals (=) followed by an initializer.
The initializer is either an _assignment-expression_ or a list of
initializers enclosed in curly braces.
The grammar for the initializer is:

[role="bnf"]
--
_initializer_ : ::
    _assignment-expression_ +
    *{* _initializer-list_ *}* +
    *{* _initializer-list_ *,* *}*

_initializer-list_ : ::
    _initializer_ +
    _initializer-list_ , _initializer_
--

The _assignment-expression_ is a normal expression except that a comma (*,*)
outside parentheses is interpreted as the end of the initializer, not as the
sequence operator.
As explained in more detail below, this allows creation of nested
initializers: The variable type and its initializer must exactly match in
terms of nesting, number of components/elements/members present at each
level, and types of components/elements/members.
An _assignment-expression_ at global scope can include calls to user-defined
functions.

An _assignment-expression_ in an initializer must be either the same type as
the object it initializes or be a type that can be converted to the object's
type according to "`<<implicit-conversions,Implicit Conversions>>`".
Since these include constructors, a composite variable can be initialized by
either a constructor or an initializer list; and an element in an
initializer list can be a constructor.

If an initializer is a list of initializers enclosed in curly braces, the
variable being declared must be a vector, a matrix, an array, or a
structure.

[source,glsl]
----
int i = { 1 }; // illegal, i is not a composite
----

A list of initializers enclosed in a matching set of curly braces is applied
to one composite.
This may be the variable being declared or a composite contained in the
variable being declared.
Individual initializers from the initializer list are applied to the
elements/members of the composite, in order.

If the composite has a vector type, initializers from the list are applied
to the components of the vector, in order, starting with component 0.
The number of initializers must match the number of components.

If the composite has a matrix type, initializers from the list must be
vector initializers and are applied to the columns of the matrix, in order,
starting with column 0.
The number of initializers must match the number of columns.

If the composite has a structure type, initializers from the list are
applied to the members of the structure, in the order declared in the
structure, starting with the first member.
The number of initializers must match the number of members.

Applying these rules, the following matrix declarations are equivalent:

[source,glsl]
----
mat2x2 a = mat2(  vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) );
mat2x2 b =      { vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) };
mat2x2 c =      {     { 1.0, 0.0 },     { 0.0, 1.0 } };
----

All of the following declarations result in a compile-time error.

[source,glsl]
----
float a[2] = { 3.4, 4.2, 5.0 };         // illegal
vec2 b = { 1.0, 2.0, 3.0 };             // illegal
mat3x3 c = { vec3(0.0), vec3(1.0), vec3(2.0), vec3(3.0) }; // illegal
mat2x2 d = { 1.0, 0.0, 0.0, 1.0 };      // illegal, can't flatten nesting
struct {
    float a;
    int b;
} e = { 1.2, 2, 3 };                    // illegal
----

In all cases, the inner-most initializer (i.e., not a list of initializers
enclosed in curly braces) applied to an object must have the same type as
the object being initialized or be a type that can be converted to the
object's type according to "`<<implicit-conversions,Implicit
Conversions>>`".
In the latter case, an implicit conversion will be done on the initializer
before the assignment is done.

[source,glsl]
----
struct {
    float a;
    int b;
} e = { 1.2, 2 }; // legal, all types match
struct {
    float a;
    int b;
} e = { 1, 3 };   // legal, first initializer is converted
----

All of the following declarations result in a compile-time error.

[source,glsl]
----
int a = true;                         // illegal
vec4 b[2] = { vec4(0.0), 1.0 };       // illegal
mat4x2 c = { vec3(0.0), vec3(1.0) };  // illegal

struct S1 {
    vec4 a;
    vec4 b;
};

struct {
    float s;
    float t;
} d[] = { S1(vec4(0.0), vec4(1.1)) }; // illegal
----

If an initializer (of either form) is provided for an unsized array, the
size of the array is determined by the number of top-level (non-nested)
initializers within the initializer.
All of the following declarations create arrays explicitly sized with five
elements:

[source,glsl]
----
float a[] = float[](3.4, 4.2, 5.0, 5.2, 1.1);
float b[] = { 3.4, 4.2, 5.0, 5.2, 1.1 };
float c[] = a;                          // c is explicitly size 5
float d[5] = b;                         // means the same thing
----

It is a compile-time error to have too few or too many initializers in an
initializer list for the composite being initialized.
That is, all elements of an array, all members of a structure, all columns
of a matrix, and all components of a vector must have exactly one
initializer expression present, with no unconsumed initializers.


[[scoping]]
== Scoping

The scope of a variable is determined by where it is declared.
If it is declared outside all function definitions, it has global scope,
which starts from where it is declared and persists to the end of the shader
it is declared in.
If it is declared in a *while* test or a *for* statement, then it is scoped
to the end of the following sub-statement.
If it is declared in an *if* or *else* statement, it is scoped to the end of
that statement.
(See "`<<selection,Selection>>`" and "`<<iteration,Iteration>>`" for the
location of statements and sub-statements.) Otherwise, if it is declared as
a statement within a compound statement, it is scoped to the end of that
compound statement.
If it is declared as a parameter in a function definition, it is scoped
until the end of that function definition.
A function's parameter declarations and body together form a single scope
nested in the global scope.
The *if* statement's expression does not allow new variables to be declared,
hence does not form a new scope.

Within a declaration, the scope of a name starts immediately after the
initializer if present or immediately after the name being declared if not.
Several examples:

[source,glsl]
----
int x = 1;
{
    int x = 2, y = x; // y is initialized to 2
}

struct S
{
    int x;
};

{
    S S = S(0); // 'S' is only visible as a struct and constructor
    S;          // 'S' is now visible as a variable
}

int x = x; // Error if x has not been previously defined.
           // If the previous definition of x was in this
           // same scope, this causes a redeclaration error.

int f( /* nested scope begins here */ int k)
{
    int k = k + 3; // redeclaration error of the name k
    ...
}

int f(int k)
{
    {
        int k = k + 3; // 2nd k is parameter, initializing nested first k
        int m = k;     // use of new k, which is hiding the parameter
    }
}
----

For both *for* and *while* loops, the sub-statement itself does not
introduce a new scope for variable names, so the following has a
redeclaration compile-time error:

[source,glsl]
----
for ( /* nested scope begins here */ int i = 0; i < 10; i++) {
    int i; // redeclaration error
}
----

The body of a *do*-*while* loop introduces a new scope lasting only between
the *do* and *while* (not including the while test expression), whether or
not the body is simple or compound:

[source,glsl]
----
int i = 17;
do
    int i = 4;  // okay, in nested scope_
while (i == 0); // i is 17, scoped outside the do-while body
----

The statement following a *switch* (...) forms a nested scope.

All variable names, structure type names, and function names in a given
scope share the same name space.
Function names can be redeclared in the same scope, with the same or
different parameters, without error.
An implicitly-sized array can be redeclared in the same scope as an array of
the same base type.
Otherwise, within one compilation unit, a declared name cannot be redeclared
in the same scope; doing so results in a redeclaration compile-time error.
If a nested scope redeclares a name used in an outer scope, it hides all
existing uses of that name.
There is no way to access the hidden name or make it unhidden, without
exiting the scope that hid it.

The built-in functions are scoped in a scope outside the global scope that
users declare global variables in.
That is, a shader's global scope, available for user-defined functions and
global variables, is nested inside the scope containing the built-in
functions.
When a function name is redeclared in a nested scope, it hides all functions
declared with that name in the outer scope.
Function declarations (prototypes) cannot occur inside of functions; they
must be at global scope, or for the built-in functions, outside the global
scope, otherwise a compile-time error results.

Shared globals are global variables declared with the same name in
independently compiled units (shaders) within the same language (i.e., same
stage, e.g. vertex) that are linked together when making a single program.
(Globals forming the interface between two different shader languages are
discussed in other sections.) Shared globals share the same name space, and
must be declared with the same type.
They will share the same storage.

Shared global arrays must have the same base type and the same explicit
size.
An array implicitly sized in one shader can be explicitly sized by another
shader in the same stage.
If no shader in a stage has an explicit size for the array, the largest
implicit size (one more than the largest index used) in that stage is used.
There is no cross-stage array sizing.
If there is no static access to an implicitly sized array within the stage
declaring it, then the array is given a size of 1, which is relevant when
the array is declared within an interface block that is shared with other
stages or the application (other unused arrays might be eliminated by the
optimizer).

Shared global scalars must have exactly the same type name and type
definition.
Structures must have the same name, sequence of type names, and type
definitions, and member names to be considered the same type.
This rule applies recursively for nested or embedded types.
If a shared global has multiple initializers, the initializers must all be
constant expressions, and they must all have the same value.
Otherwise, a link-time error will result.
(A shared global having only one initializer does not require that
initializer to be a constant expression.)
endif::GLSL[]

ifdef::ESSL[]
[[scoping]]
== Scoping

The scope of a declaration determines where the declaration is visible.
{slabbrev} uses a system of statically nested scopes.
This allows names to be redefined within a shader.


[[definition-of-terms]]
=== Definition of Terms

The term _scope_ refers to a specified region of the program where names are
guaranteed to be visible.
For example, a _compound_statement_with_scope_ ('{' _statement_ _statement_
...
'}') defines a scope.

A _nested scope_ is a scope defined within an outer scope.

The terms '_same scope'_ and '_current scope_' are equivalent to the term
'_scope_' but used to emphasize that nested scopes are excluded.

The _scope of a declaration_ is the region or regions of the program where
that declaration is visible.

A _name space_ defines where names may be defined.
Within a single name space, a name has at most one entry, specifying it to
be one of: structure, variable, or function.

In general, each scope has an associated name space.
However, in certain cases e.g. for uniforms, multiple scopes share the same
name space.
In these cases, conflicting declarations are an error, even though the name
is only visible in the scopes where it is declared.


[[types-of-scope]]
=== Types of Scope

The scope of a variable is determined by where it is declared.
If it is declared outside all function definitions, it has global scope,
which starts from where it is declared and persists to the end of the shader
it is declared in.
If it is declared in a *while* test or a *for* statement, then it is scoped
to the end of the following sub-statement (specified as
_statement-no-new-scope_ in the grammar).
Otherwise, if it is declared as a statement within a compound statement, it
is scoped to the end of that compound statement.
If it is declared as a parameter in a function definition, it is scoped
until the end of that function definition.
A function's parameter declarations and body together form a single scope.

[source,glsl]
----
int f( /* nested scope begins here */ int k)
{
    int k = k + 3; // redeclaration error of the name k
    ...
}
int f(int k)
{
    {
       int k = k + 3; // 2nd k is parameter, initializing nested first k
       int m = k // use of new k, which is hiding the parameter
    }
}
----

For both for and while loops, the sub-statement itself does not introduce a
new scope for variable names, so the following has a redeclaration
compile-time error:

[source,glsl]
----
for ( /* nested scope begins here */ int i = 0; i < 10; i++)
{
    int i; // redeclaration error
}
----

The body of a *do*-*while* loop introduces a new scope lasting only between
the do and while (not including the while test expression), whether or not
the body is simple or compound:

[source,glsl]
----
int _i_ = 17;
do
    int i = 4; // okay, in nested scope
while (i == 0); // i is 17, scoped outside the do-while body
----

The statement following a *switch* (...) forms a nested scope.

Representing the if construct as:

*if* if-expression *then* if-statement *else* else-statement,

a variable declared in the if-statement is scoped to the end of the
if-statement.
A variable declared in the else-statement is scoped to the end of the
else-statement.
This applies both when these statements are simple statements and when they
are compound statements.
The if-expression does not allow new variables to be declared, hence does
not form a new scope.

Within a declaration, the scope of a name starts immediately after the
initializer if present or immediately after the name being declared if not.
Several examples:

[source,glsl]
----
int x = 1;
{
    int x = 2,/* 2nd x visible here */ y = x; // y is initialized to 2
    int z = z; // error if z not previously defined.
}
{
int x = x; // x is initialized to '1'
}
----

A structure name declaration is visible at the end of the _struct_specifier_
in which it was declared:

[source,glsl]
----
struct S
{
    int x;
};
{
    S S = S(0); // 'S' is only visible as a struct and constructor
    S; // 'S' is now visible as a variable
}
int x = x; // Error if x has not been previously defined.
----


[[redeclaring-names]]
=== Redeclaring Names

All variable names, structure type names, and function names in a given
scope share the same name space.
Function names can be redeclared in the same scope, with the same or
different parameters, without error.
Otherwise, within a shader, a declared name cannot be redeclared in the same
scope; doing so results in a redeclaration error.
If a nested scope redeclares a name used in an outer scope, it hides all
existing uses of that name.
There is no way to access the hidden name or make it unhidden, without
exiting the scope that hid it.

Names of built-in functions cannot be redeclared as functions.
Therefore overloading or redefining built-in functions is an error.

A _declaration_ is considered to be a statement that adds a name or
signature to the symbol table.
A _definition_ is a statement that fully defines that name or signature.
E.g.

[source,glsl]
----
int f();// declaration;
int f() {return 0;}// declaration and definition
int x; // declaration and definition
int a[4];// array declaration and definition
struct S {int x;};// structure declaration and definition
----

The determination of equivalence of two declarations depends on the type of
declaration.
For functions, the whole function signature must be considered (see
"`Function Definitions`").
For variables (including arrays) and structures only the names must match.

Within each scope, a name may be declared either as a variable declaration
_or_ as function declarations _or_ as a structure.

Examples of combinations that are allowed:

1.

--
[source,glsl]
----
void f(int) {...}
void f(float) {...}// function overloading allowed
----
--
2.

--
[source,glsl]
----
void f(int);// 1^st^ declaration (allowed)
void f(int);// repeated declaration (allowed)
void f(int) {...}// single definition (allowed)
----
--

Examples of combinations that are disallowed:

1.

--
[source,glsl]
----
void f(int) {...}
void f(int) {...}// Error: repeated definition
----
--
2.

--
[source,glsl]
----
void f(int);
struct f {int x;};// Error: type 'f' conflicts with function 'f'
----
--
3.

--
[source,glsl]
----
struct f {int x;};
int f;// Error: conflicts with the type 'f'
----
--
4.

--
[source,glsl]
----
int a[3];
int a[3];// Error: repeated array definition
----
--
5.

--
[source,glsl]
----
int x;
int x;// Error: repeated variable definition
----
--


[[global-scope]]
=== Global Scope

The built-in functions are scoped in the global scope users declare global
variables in.
That is, a shader's global scope, available for user-defined functions and
global variables, is the same as the scope containing the built-in
functions.
Function declarations (prototypes) cannot occur inside of functions; they
must be at global scope.
Hence it is not possible to hide a name with a function.


[[shared-globals]]
=== Shared Globals

Shared globals are variables that can be accessed by multiple compilation
units.
In {slabbrev} the only shared globals are uniforms.
Vertex shader outputs are not considered to be shared globals since they
must pass through the rasterization stage before they are used as input by
the fragment shader.

Shared globals share the same name space, and must be declared with the same
type and precision.
They will share the same storage.
Shared global arrays must have the same base type and the same explicit
size.
Scalars must have exactly the same precision, type name and type definition.
Structures must have the same name, sequence of type names, and type
definitions, and member names to be considered the same type.
This rule applies recursively for nested or embedded types.
endif::ESSL[]


[[storage-qualifiers]]
== Storage Qualifiers

Variable declarations may have at most one storage qualifier specified in
front of the type.
These are summarized as

[options="header"]
|====
| Storage Qualifier | Meaning
| <none: default>   | local read/write memory, or an input parameter to a
                      function
| *const*           |
ifdef::GLSL[a variable whose value cannot be changed]
ifdef::ESSL[a compile-time constant]
| *in*              | linkage into a shader from a previous stage, variable
                      is copied in
| *out*             | linkage out of a shader to a subsequent stage,
                      variable is copied out
ifdef::GLSL[]
| *attribute*       | compatibility profile only and vertex language only;
                      same as *in* when in a vertex shader
endif::GLSL[]
| *uniform*         | value does not change across the primitive being
                      processed, uniforms form the linkage between a shader,
                      API, and the application
ifdef::GLSL[]
| *varying*         | compatibility profile only and vertex and fragment
                      languages only; same as *out* when in a vertex shader
                      and same as *in* when in a fragment shader
endif::GLSL[]
| *buffer*          | value is stored in a buffer object, and can be read or
                      written both by shader invocations and the API
| *shared*          | compute shader only; variable storage is shared across
                      all work items in a workgroup
|====

Some input and output qualified variables can be qualified with at most one
additional auxiliary storage qualifier:

[options="header"]
|====
| Auxiliary Storage Qualifier | Meaning
| *centroid*                  | centroid-based interpolation
| *sample*                    | per-sample interpolation
| *patch*                     | per-tessellation-patch attributes
|====

ifdef::GLSL[]
Not all combinations of qualification are allowed.
Auxiliary storage qualifiers can only be used with the *in* or *out* storage
qualifiers.
Additional qualifier rules are defined in upcoming sections.
endif::GLSL[]

Local variables can only use the *const* storage qualifier (or use no
storage qualifier).

Note that function parameters can use *const*, *in*, and *out* qualifiers,
but as _parameter qualifiers_.
Parameter qualifiers are discussed in
"`<<function-calling-conventions,Function Calling Conventions>>`".

Function return types and structure members do not use storage qualifiers.

ifdef::GLSL[]
Initializers in global declarations may only be used in declarations of
global variables with no storage qualifier, with a *const* qualifier, or
with a *uniform* qualifier.
endif::GLSL[]
ifdef::ESSL[]
Data types for communication from one run of a shader executable to its next
run (to communicate between fragments or between vertices) do not exist.
This would prevent parallel execution of the same shader executable on
multiple vertices or fragments.

In declarations of global variables with no storage qualifier or with a
const qualifier, any initializer must be a constant expression.
Declarations of global variables with other storage qualifiers may not
contain initializers.
endif::ESSL[]
Global variables without storage qualifiers that are not initialized in
their declaration or by the application will not be initialized,
but rather will enter _main()_ with undefined values.

ifdef::GLSL[]
When comparing an output from one shader stage to an input of a subsequent
shader stage, the input and output don't match if their auxiliary qualifiers
(or lack thereof) are not the same.
endif::GLSL[]


[[default-storage-qualifier]]
=== Default Storage Qualifier

If no qualifier is present on a global variable, then the variable has no
linkage to the application or shaders running on other pipeline stages.
For either global or local unqualified variables, the declaration will
appear to allocate memory associated with the processor it targets.
This variable will provide read/write access to this allocated memory.


[[constant-qualifier]]
=== Constant Qualifier

Named compile-time constants
ifdef::GLSL[or read-only variables]
can be declared using
the *const* qualifier.
ifdef::ESSL[]
Any variables qualified as constant are read-only variables for that shader.
Declaring variables as constant allows more descriptive shaders than using
hard-wired numerical constants.
endif::ESSL[]
The *const* qualifier can be used with any of the non-void transparent basic
data types, as well as with structures and arrays of these.
It is {compiletimeerror} to write to a *const* variable outside of its
declaration, so they must be initialized when declared.
For example,

ifdef::GLSL[]
[source,glsl]
----
const vec3 zAxis = vec3 (0.0, 0.0, 1.0);
const float ceiling = a + b; // a and b not necessarily constants
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
const vec3 zAxis = vec3 (0.0, 0.0, 1.0);
----
endif::ESSL[]

Structure members may not be qualified with *const*.
Structure variables can be declared as *const*, and initialized with a
structure
ifdef::GLSL[constructor or initializer.]
ifdef::ESSL[constructor.]

Initializers for *const* declarations
ifdef::GLSL[at global scope]
must be constant expressions, as defined in
"`<<constant-expressions,Constant Expressions>>`".


[[constant-expressions]]
=== Constant Expressions

SPIR-V specialization constants are expressed in {slabbrev} as *const* with the
layout qualifier *constant_id*, as described in
"`<<specialization-constant-qualifier, Specialization-Constant
Qualifier.>>`"

A _constant expression_ is one of

  * A literal value (e.g. *5* or *true*).
  * A variable declared with the *const* qualifier and an initializer, where
    the initializer is a constant expression.
    This includes both *const* declared with a specialization-constant
    layout qualifier, e.g. *layout*(*constant_id* = ...), and those declared
    without a specialization-constant layout qualifier.
  * Built-in variables qualified as *const*.
  * An expression formed by an operator on operands that are all constant
    expressions, including getting an element of a constant array, or a
    member of a constant structure, or components of a constant vector.
    However, the lowest precedence operators of the sequence operator (*,*)
    and the assignment operators (*=*, *+=*, *...*) are not included in the
    operators that can create a constant expression.
    Also, an array access with a specialization constant as an index does
    not result in a constant expression.
ifdef::GLSL[]
  * Valid use of the *length*() method on an explicitly sized object,
    whether or not the object itself is constant (implicitly sized or
    run-time sized arrays do not return a constant expression).
endif::GLSL[]
ifdef::ESSL[]
  * The *length*() method on a compile-time sized array, whether or not the
    object itself is constant.
endif::ESSL[]
  * A constructor whose arguments are all constant expressions.
ifdef::GLSL[]
  * For non-specialization constants only: The value returned by certain
    built-in function calls whose arguments are all constant expressions,
    including at least the list below.
    Any other built-in function that does not access memory (not the texture
    lookup functions, image access, atomic counter, etc.), that has a
    non-*void* return type, that has no *out* parameter, and is not a noise
    function might also be considered a constant.
    When a function is called with an argument that is a specialization
    constant, the result is not a constant expression.
  ** Angle and Trigonometric Functions
  *** *radians*
  *** *degrees*
  *** *sin*
  *** *cos*
  *** *asin*
  *** *acos*
  ** Exponential Functions
  *** *pow*
  *** *exp*
  *** *log*
  *** *exp2*
  *** *log2*
  *** *sqrt*
  *** *inversesqrt*
  ** Common Functions
  *** *abs*
  *** *sign*
  *** *floor*
  *** *trunc*
  *** *round*
  *** *ceil*
  *** *mod*
  *** *min*
  *** *max*
  *** *clamp*
  ** Geometric Functions
  *** *length*
  *** *dot*
  *** *normalize*
  * Function calls to user-defined functions (non-built-in functions) cannot
    be used to form constant expressions.
endif::GLSL[]
ifdef::ESSL[]
  * For non-specialization constants only:
    A built-in function call whose arguments are all constant expressions,
    with the exception of the texture lookup functions.
    This rule excludes functions with a *void* return or functions that have
    an *out* parameter.
    The built-in functions *dFdx*, *dFdy*, and *fwidth* must return 0 when
    evaluated inside an initializer with an argument that is a constant
    expression.

Function calls to user-defined functions (non-built-in functions) cannot be
used to form constant expressions.

Scalar, vector, matrix, array and structure variables are constant
expressions if qualified as *const*.
Opaque types cannot be constant expressions.
endif::ESSL[]

A _constant integral expression_ is a constant expression that evaluates to
a scalar signed or unsigned integer.

Constant expressions will be evaluated in an invariant way so as to create
the same value in multiple shaders when the same constant expressions appear
in those shaders.
See "`<<the-invariant-qualifier,The Invariant Qualifier>>`" for more details
on how to create invariant expressions and
"`<<precision-qualifiers,Precision Qualifiers>>`" for detail on how
expressions are evaluated.

Constant expressions respect the *precise* and *invariant* qualifiers but
will be always be evaluated in an invariant way, independent of the use of
such qualification, so as to create the same value in multiple shaders when
the same constant expressions appear in those shaders.
See "`<<the-invariant-qualifier,The Invariant Qualifier>>`" and
"`<<the-precise-qualifier,The Precise Qualifier>>`" for more details on how
to create invariant expressions.

Constant-expressions may be evaluated by a
host platform, and are therefore not required to compute the same value that
the same expression would evaluate to on the shader execution target.
However, the host must use the same or greater precision than the target
would use.
When the precision qualification cannot be determined, the expression is
evaluated at *highp*.
See "`<<default-precision-qualifiers, Default Precision Qualifiers>>`".

Specialization-constant expressions are never evaluated by the compiler
front end, but instead retain the expression's operations needed to evaluate
them later on the host.


[[input-variables]]
=== Input Variables

Shader input variables are declared with the *in* storage qualifier.
They form the input interface between previous stages of the API
pipeline and the declaring shader.
Input variables must be declared at global scope.
Values from the previous pipeline stage are copied into input variables at
the beginning of shader execution.
It is {compiletimeerror} to write to a variable declared as an input.

Only the input variables that are
ifdef::GLSL[statically]
ifdef::ESSL[actually]
read need to be written by the
previous stage; it is allowed to have superfluous declarations of input
variables.
ifdef::GLSL[]
This is shown in the following table.

// This is very tricky to specify with multiple column and row spans

[%autowidth,cols="5"]
|====
2.2+| Treatment of Mismatched Input Variables
                               3+| Consuming Shader (input variables)
                                 | No Declaration | Declared but no Static Use | Declared and Static Use
 .3+| Generating Shader (output variables)
    | No Declaration             | Allowed        | Allowed                    | Link-Time Error
    | Declared but no Static Use | Allowed        | Allowed                    | Allowed (values are undefined)
    | Declared and Static Use    | Allowed        | Allowed                    | Allowed (values are potentially undefined)
|====

Consumption errors are based on static use only.
Compilation may generate a warning, but not an error, for any dynamic use
the compiler can deduce that might cause consumption of undefined values.
endif::GLSL[]

See "`<<built-in-variables,Built-In Variables>>`" for a list of the built-in
input names.

Vertex shader input variables (or attributes) receive per-vertex data.
It is {compiletimeerror} to use auxiliary storage or interpolation qualifiers
on a vertex shader input.
The values copied in are established by the API or through the use
of the layout identifier *location*.

It is a compile-time error to declare a vertex shader input with, or that
contains, any of the following types:

  * A <<booleans, boolean type>>
  * An <<opaque-types, opaque type>>
ifdef::ESSL[]
  * An array
endif::ESSL[]
  * A structure

Example declarations in a vertex shader:

ifdef::GLSL[]
[source,glsl]
----
in vec4 position;
in vec3 normal;
in vec2 texCoord[4];
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
in vec4 position;
in vec3 normal;
----
endif::ESSL[]

It is expected that graphics hardware will have a small number of fixed
vector locations for passing vertex inputs.
Therefore, the {slname} defines each non-matrix input variable as taking up
one such vector location.
There is an implementation-dependent limit on the number of locations that
can be used, and if this is exceeded it will cause a link-time error.
(Declared input variables that are not statically used do not count against
this limit.) A scalar input counts the same amount against this limit as a
*vec4*, so applications may want to consider packing groups of four
unrelated float inputs together into a vector to better utilize the
capabilities of the underlying hardware.
A matrix input will use up multiple locations.
The number of locations used will equal the number of columns in the matrix.

Tessellation control, evaluation, and geometry shader input variables get
the per-vertex values written out by output variables of the same names in
the previous active shader stage.
For these inputs, *centroid* and interpolation qualifiers are allowed, but
have no effect.
Since tessellation control, tessellation evaluation, and geometry shaders
operate on a set of vertices, each input variable (or input block, see
<<interface-blocks,Interface Blocks>> below) needs to be declared as an array.
For example,

[source,glsl]
----
in float foo[]; // geometry shader input for vertex "out float foo"
----

Each element of such an array corresponds to one vertex of the primitive
being processed.
Each array can optionally have a size declared.
For geometry shaders, the array size will be set by, (or if provided must be
consistent with) the input *layout* declaration(s) establishing the type of
input primitive, as described later in "`<<input-layout-qualifiers,Input
Layout Qualifiers>>`".

Some inputs and outputs are _arrayed_, meaning that for an interface between
two shader stages either the input or output declaration requires an extra
level of array indexing for the declarations to match.
For example, with the interface between a vertex shader and a geometry
shader, vertex shader output variables and geometry shader input variables
of the same name must have matching types, except that the geometry shader
will have one more array dimension than the vertex shader, to allow for
vertex indexing.
If such an arrayed interface variable is not declared with the necessary
additional input or output array dimension, a link-time error will result.
Geometry shader inputs, tessellation control shader inputs and outputs, and
tessellation evaluation inputs all have an additional level of arrayness
relative to other shader inputs and outputs.
These inputs and outputs are known as _per-vertex-arrayed_ inputs and
outputs.
Component limits for arrayed interfaces (e.g.
_gl_MaxTessControlInputComponents_) are limits per vertex, not limits for
the entire interface.

For non-arrayed interfaces (meaning array dimensionally stays the same
between stages), it is a link-time error if the input variable is not
declared with the same type, including array dimensionality, as the matching
output variable.

The link-time type-matching rules apply to all declared input and output
variables, whether or not they are used.

Additionally, tessellation evaluation shaders support per-patch input
variables declared with the *patch* and *in* qualifiers.
Per-patch input variables are filled with the values of per-patch output
variables written by the tessellation control shader.
Per-patch inputs may be declared as one-dimensional arrays, but are not
indexed by vertex number.
Applying the *patch* qualifier to inputs can only be done in tessellation
evaluation shaders.
As with other input variables, per-patch inputs must be declared using the
same type and qualification as per-patch outputs from the previous
(tessellation control) shader stage.
It is a compile-time error to use *patch* with inputs in any other stage.

It is a compile-time error to declare a tessellation control, tessellation
evaluation or geometry shader input with, or that contains, any of the
following types:

  * A <<booleans, boolean type>>
  * An <<opaque-types, opaque type>>
ifdef::ESSL[]
  * A structure containing an array
  * A structure containing a structure
  * For per-vertex-arrayed variables:
  ** Per-vertex-arrayed arrays of arrays
  ** Per-vertex-arrayed arrays of structures
  * For non-per-vertex-arrayed variables:
  ** An array of arrays
  ** An array of structures
endif::ESSL[]

Fragment shader inputs get per-fragment values, typically interpolated from
a previous stage's outputs.
ifdef::GLSL[]
The auxiliary storage qualifiers *centroid* and *sample* can also be
applied, as well as the interpolation qualifiers *flat*, *noperspective*,
and *smooth.*
endif::GLSL[]

It is a compile-time error to declare a fragment shader input with, or that
contains, any of the following types:

  * A <<booleans, boolean type>>
  * An <<opaque-types, opaque type>>
ifdef::ESSL[]
  * An array of arrays
  * An array of structures
  * A structure containing an array
  * A structure containing a structure
endif::ESSL[]

Fragment shader inputs that are, or contain, integral
ifdef::GLSL[or double-precision floating-point]
types must be
qualified with the interpolation qualifier *flat*.

Fragment inputs are declared as in the following examples:

ifdef::GLSL[]
[source,glsl]
----
in vec3 normal;
centroid in vec2 TexCoord;
noperspective in float temperature;
flat in vec3 myColor;
noperspective centroid in vec2 myTexCoord;
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
in vec3 normal;
centroid in vec2 TexCoord;
flat in vec3 myColor;
----
endif::ESSL[]

The fragment shader inputs form an interface with the last active shader in
the vertex processing pipeline.
For this interface, the last active shader stage output variables and
fragment shader input variables of the same name must match in type and
qualification, with a few exceptions: The storage qualifiers must, of
course, differ (one is *in* and one is *out*).
Also,
ifdef::GLSL[interpolation qualification (e.g. *flat*) and]
auxiliary qualification (e.g. *centroid*) may differ.
ifdef::GLSL[]
These mismatches are allowed between any pair of stages.
endif::GLSL[]
When
ifdef::GLSL[interpolation or]
auxiliary qualifiers do not match, those provided in
the fragment shader supersede those provided in previous stages.
If any such qualifiers are completely missing in the fragment shaders, then
the default is used, rather than any qualifiers that may have been declared
in previous stages.
That is, what matters is what is declared in the fragment shaders, not what
is declared in shaders in previous stages.

When an interface between shader stages is formed using shaders from two
separate program objects, it is not possible to detect mismatches between
inputs and outputs when the programs are linked.
When there are mismatches between inputs and outputs on such interfaces,
ifdef::GLSL[]
the values passed across the interface will be partially or completely
undefined.
endif::GLSL[]
ifdef::ESSL[]
attempting to use the two programs in the same program pipeline will result
in program pipeline validation failures, as described in section 7.4.1
"`Shader Interface Matching`" of the <<references,{apispec}>>.
endif::ESSL[]

Shaders can ensure matches across such interfaces either by using input and
output layout qualifiers (sections "`<<input-layout-qualifiers,Input Layout
Qualifiers>>`" and "`<<output-layout-qualifiers,Output Layout
Qualifiers>>`") or by using identical input and output declarations of
blocks or variables.
Complete rules for interface matching are found in section 7.4.1 "`Shader
Interface Matching`" of the <<references,{apispec}>>.

Compute shaders do not permit user-defined input variables and do not form a
formal interface with any other shader stage.
See "`<<compute-shader-special-variables,Compute Shader Special
Variables>>`" for a description of built-in compute shader input variables.
All other input to a compute shader is retrieved explicitly through image
loads, texture fetches, loads from uniforms or uniform buffers, or other
user supplied code.
ifdef::GLSL[]
Redeclaration of built-in input variables in compute shaders is not
permitted.
endif::GLSL[]


[[uniform-variables]]
=== Uniform Variables

The *uniform* qualifier is used to declare global variables whose values are
the same across the entire primitive being processed.
ifdef::GLSL[]
All *uniform* variables are read-only and are initialized externally either
at link time or through the API.
The link-time initial value is either the value of the variable's
initializer, if present, or 0 if no initializer is present.
Opaque types cannot have initializers, or a compile-time error results.
endif::GLSL[]
ifdef::ESSL[]
All *uniform* variables are read-only.
Except for variables declared within a uniform block, all uniform variables
are initialized to 0 at link time and may be updated through the API.
endif::ESSL[]
When targeting Vulkan, it is {compiletimeerror} to declare *uniform*
variables outside a block.

Example declarations are:

ifdef::GLSL[]
[source,glsl]
----
uniform vec4 lightPosition;
uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
uniform vec4 lightPosition;
----
endif::ESSL[]

The *uniform* qualifier can be used with any of the basic data types, or
when declaring a variable whose type is a structure, or an array of any of
these.

There is an implementation-dependent limit on the amount of storage for
uniforms that can be used for each type of shader and if this is exceeded it
will cause a compile-time or link-time error.
Uniform variables that are declared but not
ifdef::ESSL[statically]
used do not count against this limit.
The number of user-defined uniform variables and the number of built-in
uniform variables that are used within a shader are added together to
determine whether available uniform storage has been exceeded.

Uniforms in shaders all share a single global name space when linked into a
program or separable program.
Hence, the types,
ifdef::GLSL[initializers,]
ifdef::ESSL[precisions,]
and any location specifiers of all statically used uniform variables with the
same name must match across all shaders that are linked into a single program.
However it is not required to repeat the
ifdef::GLSL[initializer or]
location specifier in all the linked shaders.
While this single uniform name space is cross stage, a uniform variable
name's scope is per stage: If a uniform variable name is declared in one
stage (e.g. a vertex shader) but not in another (e.g. a fragment shader),
then that name is still available in the other stage for a different use.

ifdef::ESSL[]
A compile or link-time error is generated if any of the explicitly given or
compiler generated uniform locations is greater than the
implementation-defined maximum number of uniform locations minus one.

Unlike locations for inputs and outputs, uniform locations are logical
values, not register locations, and there is no concept of overlap.
For example:

[source,glsl]
----
layout(location = 2) uniform mat4 x;
layout(location = 3) uniform mat4 y; // No overlap with x
layout(location = 2) in mat4 x;
layout(location = 3) in mat4 y; // Error, locations conflict with x
----
endif::ESSL[]


[[output-variables]]
=== Output Variables

Shader output variables are declared with the *out* storage qualifier.
They form the output interface between the declaring shader and the
subsequent stages of the API pipeline.
Output variables must be declared at global scope.
During shader execution they will behave as normal unqualified global
variables.
Their values are copied out to the subsequent pipeline stage on shader exit.
Only output variables that are read by the subsequent pipeline stage need to
be written; it is allowed to have superfluous declarations of output
variables.

There is _not_ an *inout* storage qualifier for declaring a single variable
name as both input and output to a shader.
Also, a variable cannot be declared with both the *in* and the *out*
qualifiers, this will result in a compile-time or link-time error.
Output variables must be declared with different names than input variables.
However, nesting an input or output inside an interface block with an
instance name allows the same names with one referenced through a block
instance name.

Vertex, tessellation evaluation, and geometry output variables output
per-vertex data and are declared using the *out* storage qualifier.
Applying *patch* to an output can only be done in a tessellation control
shader.
It is a compile-time error to use *patch* on outputs in any other stage.

It is a compile-time error to declare a vertex, tessellation evaluation,
tessellation control, or geometry shader output with, or that contains, any
of the following types:

  * A <<booleans, boolean type>>
  * An <<opaque-types, opaque type>>
ifdef::ESSL[]
  * A structure containing an array
  * A structure containing a structure
  * For per-vertex-arrayed variables (applies to tessellation control,
    tessellation evaluation and geometry shaders):
  ** Per-vertex-arrayed arrays of arrays
  ** Per-vertex-arrayed arrays of structures
  * For non-per-vertex-arrayed variables:
  ** An array of arrays
  ** An array of structures

Vertex shader outputs may be qualified with the interpolation qualifier
*flat*^1^.

1::
    Unlike previous versions of the {slname}, there is no requirement for
    outputs containing integers to be qualified as *flat*, since the vertex
    shader may interface with the tessellation control shader.
    However, in all cases, the qualifier must match across interfaces.
endif::ESSL[]

Individual outputs are declared as in the following examples:

[source,glsl]
----
out vec3 normal;
centroid out vec2 TexCoord;
invariant centroid out vec4 Color;
flat out vec3 myColor;
sample out vec4 perSampleColor;
----

These can also appear in interface blocks, as described in
"`<<interface-blocks,Interface Blocks>>`".
Interface blocks allow simpler addition of arrays to the interface from
vertex to geometry shader.
They also allow a fragment shader to have the same input interface as a
geometry shader for a given vertex shader.

Tessellation control shader output variables are used to output
per-vertex and per-patch data.
Per-vertex output variables are arrayed (see _arrayed_ under
"`<<input-variables,Input Variables>>`") and declared using the *out*
qualifier without the *patch* qualifier.
Per-patch output variables are declared using the *patch* and *out*
qualifiers.

Since tessellation control shaders produce an arrayed primitive comprising
multiple vertices, each per-vertex output variable (or output block, see
<<interface-blocks,Interface Blocks>> below) needs to be declared as an array.
For example,

[source,glsl]
----
out float foo[]; // feeds next stage input "in float foo[]"
----

Each element of such an array corresponds to one vertex of the primitive
being produced.
Each array can optionally have a size declared.
The array size will be set by (or if provided must be consistent with) the
output layout declaration(s) establishing the number of vertices in the
output patch, as described later in
"`<<tessellation-control-outputs,Tessellation Control Outputs>>`".

Each tessellation control shader invocation has a corresponding output patch
vertex, and may assign values to per-vertex outputs only if they belong to
that corresponding vertex.
If a per-vertex output variable is used as an l-value, it is a compile-time
or link-time error if the expression indicating the vertex index is not the
identifier _gl_InvocationID_.

The order of execution of a tessellation control shader invocation relative
to the other invocations for the same input patch is undefined unless the
built-in function *barrier*() is used.
This provides some control over relative execution order.
When a shader invocation calls *barrier*(), its execution pauses until all
other invocations have reached the same point of execution.
Output variable assignments performed by any invocation executed prior to
calling *barrier*() will be visible to any other invocation after the call
to *barrier*() returns.

Because tessellation control shader invocations execute in undefined order
between barriers, the values of per-vertex or per-patch output variables
will sometimes be undefined.
Consider the beginning and end of shader execution and each call to
*barrier*() as synchronization points.
The value of an output variable will be undefined in any of the three
following cases:

  . At the beginning of execution.
  . At each synchronization point, unless
+
--
* the value was well-defined after the previous synchronization point and
  was not written by any invocation since, or
* the value was written by exactly one shader invocation since the previous
  synchronization point, or
* the value was written by multiple shader invocations since the previous
  synchronization point, and the last write performed by all such
  invocations wrote the same value.
--
  . When read by a shader invocation, if
+
--
* the value was undefined at the previous synchronization point and has not
  been written by the same shader invocation since, or
* the output variable is written to by any other shader invocation between
  the previous and next synchronization points, even if that assignment
  occurs in code following the read.
--

Fragment outputs output per-fragment data and are declared using the *out*
storage qualifier.
It is {compiletimeerror} to use auxiliary storage qualifiers or
interpolation qualifiers in a fragment shader output declaration.
It is a compile-time error to declare a fragment shader output with, or that
contains, any of the following types:

  * A <<booleans, boolean type>>
ifdef::GLSL[]
  * A double-precision scalar or vector (*double*, *dvec2*, *dvec3*,
    *dvec4*)
endif::GLSL[]
  * An <<opaque-types, opaque type>>
  * A matrix type
  * A structure
ifdef::ESSL[]
  * An array of arrays

Fragment shader outputs declared as arrays may only be indexed by a constant
integral expression.
endif::ESSL[]

Fragment outputs are declared as in the following examples:

[source,glsl]
----
out vec4 FragmentColor;
out uint Luminosity;
----

Compute shaders have no built-in output variables, do not support
user-defined output variables and do not form a formal interface with any
other shader stage.
All outputs from a compute shader take the form of the side effects such as
image stores and operations on atomic counters.


[[buffer-variables]]
=== Buffer Variables

The *buffer* qualifier is used to declare global variables whose values are
stored in the data store of a buffer object bound through the API.
Buffer variables can be read and written, with the underlying storage shared
among all active shader invocations.
Buffer variable memory reads and writes within a single shader invocation
are processed in order.
However, the order of reads and writes performed in one invocation relative
to those performed by another invocation is largely undefined.
Buffer variables may be qualified with memory qualifiers affecting how the
underlying memory is accessed, as described in "`<<memory-qualifiers,Memory
Qualifiers>>`".

The *buffer* qualifier can be used to declare interface blocks (see
"`<<interface-blocks,Interface Blocks>>`"), which are then referred to as
shader storage blocks.
It is a compile-time error to declare buffer variables outside a block.

[source,glsl]
----
// use buffer to create a buffer block (shader storage block)
buffer BufferName { // externally visible name of buffer
    int count;      // typed, shared memory...
    ...             // ...
    vec4 v[];       // last member may be an array that is not sized
                    // until after link time (dynamically sized)
} Name;             // name of block within the shader
----

There are implementation-dependent limits on the number of shader storage
blocks used for each type of shader, the combined number of shader storage
blocks used for a program, and the amount of storage required by each
individual shader storage block.
If any of these limits are exceeded, it will cause a compile-time or
link-time error.

If multiple shaders are linked together, then they will share a single
global buffer variable name space.
Hence, the types of all declared buffer variables with the same name must
match across all shaders that are linked into a single program.

ifdef::ESSL[]
Precision qualifiers for such variables need not match.
endif::ESSL[]

[[shared-variables]]
=== Shared Variables

The *shared* qualifier is used to declare global variables that have storage
shared between all work items in a compute shader workgroup.
Variables declared as *shared* may only be used in compute shaders (see
"`<<compute-processor,Compute Processor>>`").
Any other declaration of a *shared* variable is {compiletimeerror}.
Shared variables are implicitly coherent (see
"`<<memory-qualifiers,Memory Qualifiers>>`").

Variables declared as *shared* may not have initializers and their contents
are undefined at the beginning of shader execution.
Any data written to *shared* variables will be visible to other work items
(executing the same shader) within the same workgroup.

In the absence of synchronization, the order of reads and writes to the same
*shared* variable by different invocations of a shader is not defined.

In order to achieve ordering with respect to reads and writes to *shared*
variables, control flow barriers must be employed using the *barrier*() function
(see "`<<shader-invocation-control-functions,Shader Invocation Control
Functions>>`").

There is a limit to the total size of all variables declared as *shared* in a
single program.
This limit, expressed in units of basic machine units may be determined by
using the {apiname} API to query the value of
MAX_COMPUTE_SHARED_MEMORY_SIZE.


[[interface-blocks]]
=== Interface Blocks

Input, output, uniform, and buffer variable declarations can be grouped into
named interface blocks to provide coarser granularity backing than is
achievable with individual declarations.
They can have an optional instance name, used in the shader to reference
their members.
An output block of one programmable stage is backed by a corresponding input
block in the subsequent programmable stage.
A _uniform block_ is backed by the application with a buffer object.
A _buffer block_, also known as a _shader storage block_, is also backed
by the application with a buffer object.
It is a compile-time error to have an input block in a vertex shader or an
output block in a fragment shader.
These uses are reserved for future use.

An interface block declaration is defined in the grammar as follows:

[role="bnf"]
--
_interface-block_ : ::
    _type_qualifier_ _block-name_ *{* _member-list_ *}* _instance-name~opt~_ *;*

_block-name_ : ::
    _identifier_

_member-list_ : ::
    _member-declaration_ +
    _member-declaration_ _member-list_

_member-declaration_ : ::
    _layout-qualifier~opt~_ _qualifiers~opt~_ _type_ _declarators_ *;*

// Note: Qualifiers can be in any order.

_instance-name_ : ::
    _identifier_ +
    _identifier_ _array-specifier_ +
--

Each of the above elements is discussed below.

First, an example,

[source,glsl]
----
uniform Transform {
    mat4 ModelViewMatrix;
    mat4 ModelViewProjectionMatrix;
    uniform mat3 NormalMatrix;      // allowed restatement of qualifier
    float Deformation;
};
----

The above establishes a uniform block named "`Transform`" with four uniforms
grouped inside it.

_type-qualifier_ determines the interface of which the block will be a part
and, optionally, additional qualifiers that are applied to the block.
It is a compile-time error if it does not include one of the storage qualifiers
*in*, *out*, *uniform* or *buffer*.
It may optionally include <<layout-qualifiers,layout qualifiers>>, the
<<storage-qualifiers,auxiliary storage qualifier>> *patch*, and the
<<the-precise-qualifier,precise qualifier>>.
*buffer* blocks may additionally include <<memory-qualifiers>>.
It is a compile-time error to include any other qualifiers.

_member-list_ declares the variables that are to be grouped into the block.
Types and declarators are the same as for other input, output, uniform, and
buffer variable declarations outside blocks, with these exceptions:

  * Initializers are not allowed
  * Opaque types are not allowed
  * Structure definitions cannot be nested inside a block
ifdef::ESSL[]
  * Arrays of arrays of blocks are not allowed, except for the cases in the
    tessellation and geometry stages where the declaration is a
    per-vertex-array of arrays of blocks.
endif::ESSL[]

ifdef::GLSL[]
Any of these would result in a compile-time error.
endif::GLSL[]

If no optional qualifier is used in a member-declaration, the qualification
of the member includes all *in*, *out*, *patch*, *uniform*, or *buffer* as
determined by _interface-qualifier_.
If optional qualifiers are used, they can include interpolation qualifiers,
auxiliary storage qualifiers, precision qualifiers,
and storage qualifiers and they must declare
an input, output, or uniform member consistent with the interface qualifier
of the block: Input variables, output variables, uniform variables, and
*buffer* members can only be in *in* blocks, *out* blocks, *uniform* blocks,
and shader storage blocks, respectively.

Repeating the *in*, *out*, *patch*, *uniform*, or *buffer* interface
qualifier for a member's storage qualifier is optional.
For example,

[source,glsl]
----
in Material {
    smooth in vec4 Color1; // legal, input inside in block
    smooth vec4 Color2;    // legal, 'in' inherited from 'in Material'
    vec2 TexCoord;         // legal, TexCoord is an input
    uniform float Atten;   // illegal, mismatched storage qualifier
};
----

Members of *uniform* or *buffer* storage blocks are
always represented in memory as *highp*, regardless of any precision
qualifier associated with the declaration. When values are read from
or written to such variables they are converted to or from the declared
precision as described in
<<conversion-between-precisions,Conversion Between Precisions>>.
Operations on the values within the shader will take place using the declared
precision as normal.

A _shader interface_ is defined to be one of these:

  * All the uniform variables and uniform blocks declared in a program.
    This spans all compilation units linked together within one program.
  * All the *buffer* blocks declared in a program.
  * The boundary between adjacent programmable pipeline stages: This spans
    all the outputs declared in all compilation units of the first stage and
    all the inputs declared in all compilation units of the second stage.
    Note that for the purposes of this definition, the fragment shader and
    the preceding shader are considered to have a shared boundary even
    though in practice, all values passed to the fragment shader first pass
    through the rasterizer and interpolator.

The block name (_block-name_) is used to match within shader interfaces: an
output block of one pipeline stage will be matched to an input block with
the same name in the subsequent pipeline stage.
For uniform or shader storage blocks, the application uses the block name to
identify the block.
Block names have no other use within a shader beyond interface matching; it
is {compiletimeerror}
to use a block name at global scope for anything other than as a
block name (e.g. use of a block name for a global variable name or function
name is currently reserved).
It is a compile-time error to use the same block name for more than one
block declaration in the same shader interface (as defined above) within one
shader, even if the block contents are identical.

Matched block names within a shader interface (as defined above) must match
in terms of having the same number of declarations with the same sequence of
types and the same sequence of member names, as well as having matching
member-wise layout qualification
ifdef::GLSL[]
(see next section).
endif::GLSL[]
ifdef::ESSL[]
as defined in "`<<matching-of-qualifiers,Matching of Qualifiers>>`".
endif::ESSL[]
Matched uniform or shader storage block names (but not input or output block
names) must also either all be lacking an instance name or all having an
instance name, putting their members at the same scoping level.
When instance names are present on matched block names, it is allowed for
the instance names to differ; they need not match for the blocks to match.
Furthermore, if a matching block is declared as an array, then the array
sizes must also match (or follow array matching rules for the shader
interface between consecutive shader stages).
Any mismatch will generate a link-time error.
A block name is allowed to have different definitions in different shader
interfaces within the same shader, allowing, for example, an input block and
output block to have the same name.

If an instance name (_instance-name_) is not used, the names declared inside
the block are scoped at the global level and accessed as if they were
declared outside the block.
If an instance name (_instance-name_) is used, then it puts all the members
inside a scope within its own name space, accessed with the field selector
(*.*) operator (analogously to structures).
For example,

[source,glsl]
----
in Light {
    vec4 LightPos;
    vec3 LightColor;
};
in ColoredTexture {
    vec4 Color;
    vec2 TexCoord;
} Material;           // instance name
vec3 Color;           // different Color than Material.Color
vec4 LightPos;        // illegal, already defined
...
... = LightPos;       // accessing LightPos
... = Material.Color; // accessing Color in ColoredTexture block
----

Outside the shading language (i.e., in the API), members are similarly
identified except the block name is always used in place of the instance
name (API accesses are to shader interfaces, not to shaders).
If there is no instance name, then the API does not use the block name to
access a member, just the member name.

Within a shader interface, all declarations of the same global name must be
for the same object and must match in type and in whether they declare a
variable or member of a block with no instance name.
The API also needs this name to uniquely identify an object in the shader
interface.
It is a link-time error if any particular shader interface contains

  * two different blocks, each having no instance name, and each having a
    member of the same name, or
  * a variable outside a block, and a block with no instance name, where the
    variable has the same name as a member in the block.

[source,glsl]
----
out Vertex {
    vec4 Position;  // API transform/feedback will use "Vertex.Position"
    vec2 Texture;
} Coords;           // shader will use "Coords.Position"
out Vertex2 {
    vec4 Color;     // API will use "Color"
    float Color2;
};

// in same program as Vertex2 above:
out Vertex3 {
    float Intensity;
    vec4 Color;     // ERROR, name collision with Color in Vertex2
};
float Color2;       // ERROR, collides with Color2 in Vertex2
----

For blocks declared as arrays, the array index must also be included when
accessing members, as in this example

ifdef::GLSL[]
[source,glsl]
----
uniform Transform { // API uses "Transform[2]" to refer to instance 2
    mat4 ModelViewMatrix;
    mat4 ModelViewProjectionMatrix;
    vec4 a[]; // array will get implicitly sized
    float Deformation;
} transforms[4];
...
... = transforms[2].ModelViewMatrix; // shader access of instance 2
// API uses "Transform.ModelViewMatrix" to query an offset or other query
transforms[x].a.length(); // same length for 'a' for all x
Transform[x];             // illegal, must use 'transforms'
Transform.a.length();     // illegal, must use 'transforms'
...transforms[2].a[3]...  // if these are the only two dereferences of 'a',
...transforms[3].a[7]...  // then 'a' must be size 8, for all
transforms[x]
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
uniform Transform { // API uses "Transform[2]" to refer to instance 2
    mat4 ModelViewMatrix;
    mat4 ModelViewProjectionMatrix;
    float Deformation;
} transforms[4];
...
... = transforms[2].ModelViewMatrix; // shader access of instance 2
// API uses "Transform.ModelViewMatrix" to query an offset or other query
----
endif::ESSL[]

For uniform or shader storage blocks declared as an array, each individual
array element corresponds to a separate buffer object bind range, backing
one instance of the block.
As the array size indicates the number of buffer objects needed, uniform and
shader storage block array declarations must specify an array size.
ifdef::ESSL[]
All indices used to index a shader storage block array must be constant
integral expressions.
endif::ESSL[]
A uniform
ifdef::GLSL[or shader storage]
block array can only be indexed with a
dynamically uniform integral expression, otherwise results are undefined.

When using {apiname} API entry points to identify the name of an individual
block in an array of blocks, the name string may include an array index
(e.g. _Transform[2]_).
When using {apiname} API entry points to refer to offsets or other
characteristics of a block member, an array index must not be specified
(e.g. _Transform.ModelViewMatrix_).
ifdef::ESSL[]
See section 7.3.1 "`Program Interfaces`" of the <<references,{apispec}>> for
details.
endif::ESSL[]

Tessellation control, tessellation evaluation and geometry shader input
blocks must be declared as arrays and follow the array declaration and
linking rules for all shader inputs for the respective stages.
All other input and output block arrays must specify an array size.

There are implementation-dependent limits on the number of uniform blocks
and the number of shader storage blocks that can be used per stage.
If either limit is exceeded, it will cause a link-time error.


[[layout-qualifiers]]
== Layout Qualifiers

Layout qualifiers can appear in several forms of declaration.
They can appear as part of an interface block definition or block member, as
shown in the grammar in the previous section.
They can also appear with just an _interface-qualifier_ to establish layouts
of other declarations made with that qualifier:

[role="bnf"]
--
_layout-qualifier_ _interface-qualifier_ *;*
--

Or, they can appear with an individual variable declared with an interface
qualifier:

[role="bnf"]
--
_layout-qualifier_ _interface-qualifier_ _declaration_ *;*
--

Declarations of layouts can only be made at global scope or block members,
and only where indicated in the following subsections; their details are
specific to what the interface qualifier is, and are discussed individually.

The _layout-qualifier_ expands to:

[role="bnf"]
--
_layout-qualifier_ : ::
    *layout* *(* _layout-qualifier-id-list_ *)*

_layout-qualifier-id-list_ : ::
    _layout-qualifier-id_ +
    _layout-qualifier-id_ *,* _layout-qualifier-id-list_

_layout-qualifier-id_ : ::
    _layout-qualifier-name_ +
    _layout-qualifier-name_ *=* _layout-qualifier-value_ +
    *shared*
--

ifdef::GLSL[]
[role="bnf"]
--
_layout-qualifier-value_ : ::
    _integer-constant-expression_
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_layout-qualifier-value_ : ::
    _integer-constant_
--
endif::ESSL[]

The tokens used for _layout-qualifier-name_ are identifiers, not keywords,
however, the *shared* keyword is allowed as a _layout-qualifier-id_.
Generally, they can be listed in any order.
Order-dependent meanings exist only if explicitly called out below.
ifdef::GLSL[]
Similarly, these identifiers are not case sensitive, unless explicitly noted
otherwise.
endif::GLSL[]
ifdef::ESSL[]
As for other identifiers, they are case sensitive.
endif::ESSL[]

ifdef::GLSL[]
More than one layout qualifier may appear in a single declaration.
Additionally, the same _layout-qualifier-name_ can occur multiple times
within a layout qualifier or across multiple layout qualifiers in the same
declaration.
When the same _layout-qualifier-name_ occurs multiple times, in a single
declaration, the last occurrence overrides the former occurrence(s).
Further, if such a _layout-qualifier-name_ will affect subsequent
declarations or other observable behavior, it is only the last occurrence
that will have any effect, behaving as if the earlier occurrence(s) within
the declaration are not present.
This is also true for overriding _layout-qualifier-name_, where one
overrides the other (e.g. *row_major* vs.
*column_major*); only the last occurrence has any effect.
endif::GLSL[]
ifdef::ESSL[]
The set of allowed layout qualifiers depends on the shader, the interface
and the variable type as specified in the following sections.
For example, a sampler in the default uniform block in a fragment shader can
have *location* and *binding* layout qualifiers but no others.
Invalid use of layout qualifiers is an error.
endif::ESSL[]

ifdef::GLSL[]
_integer-constant-expression_ is defined in
"`<<constant-expressions, Constant Expressions>>`" as _constant integral
expression_, with it being a compile-time error for
_integer-constant-expression_ to be a specialization constant.
endif::GLSL[]

The following table summarizes the use of layout qualifiers.
It shows for each one what kinds of declarations it may be applied to.
These are all discussed in detail in the following sections.

[cols="<.^,^.^,^.^,^.^,^.^,<.^", options="header"]
|====
| Layout Qualifier        | Qualifier Only    | Individual Variable   | Block | Block Member  | Allowed Interfaces
| *shared* +
  *packed* +
  *std140* +
  *std430*                | X                 |                       | X     |            .5+| *uniform* / *buffer*
| *row_major* +
  *column_major*          | X                 |                       | X     | X
| *binding* =             |                   | opaque types only     | X     |
ifdef::GLSL[]
| *offset* =              |                   | atomic counters only  |       | X
| *align* =               |                   |                       | X     | X
endif::GLSL[]
ifdef::ESSL[]
| *offset* =              |                   | atomic counters only  |       | Vulkan only
| *align* =               |                   |                 | Vulkan only | Vulkan only
endif::ESSL[]
| *set* =                 |                   | opaque types only     | X     |               | *uniform* / *buffer* (Vulkan only)
| *push_constant*         |                   |                       | X     |               | *uniform* (Vulkan only)
| *input_attachment_index* = |                | subpass types only    |       |               | *uniform* (Vulkan only)
ifdef::GLSL[]
| *location* =            |                   | X                     |       |               | *uniform* / *buffer* and subroutine variables
| *location* =            |                   | X                     | X     | X^1^       .2+| all *in* / *out*, except for compute
| *component* =           |                   | X                     |       | X
| *index* =               |                   | X                     |       |               | fragment *out* and subroutine functions
endif::GLSL[]
ifdef::ESSL[]
| *location* =            |                   | X                     |       |               | *uniform* / *buffer*
| *location* =            |                   | X                     | X     | X^1^          | all *in* / *out*, except for compute
endif::ESSL[]
| *triangles* +
  *quads* +
  *isolines*              | X                 |                       |       |               | tessellation evaluation *in*
| *equal_spacing* +
  *fractional_even_spacing* +
  *fractional_odd_spacing*| X                 |                       |       |               | tessellation evaluation *in*
| *cw* +
  *ccw*                   | X                 |                       |       |               | tessellation evaluation *in*
| *point_mode*            | X                 |                       |       |               | tessellation evaluation *in*
| *points*                | X                 |                       |       |               | geometry *in*/*out*
| [ *points* ] +
  *lines* +
  *lines_adjacency* +
  *triangles* +
  *triangles_adjacency*   | X                 |                       |       |               | geometry *in*
| *invocations* =         | X                 |                       |       |               | geometry *in*
ifdef::GLSL[]
| *origin_upper_left* +
  *pixel_center_integer*  |                   | _gl_FragCoord_ only   |       |            .2+| fragment *in*
| *early_fragment_tests*  | X                 |                       |       |
endif::GLSL[]
ifdef::ESSL[]
| *early_fragment_tests*  | X                 |                       |       |               | fragment *in*
endif::ESSL[]
| *local_size_x* = +
  *local_size_y* = +
  *local_size_z* =        | X                 |                       |       |               | compute *in*
| *local_size_x_id* = +
  *local_size_y_id* = +
  *local_size_z_id* =     | X                 |                       |       |               | compute *in* (SPIR-V only)
ifdef::GLSL[]
| *xfb_buffer* = +
  *xfb_stride* =          | X                 | X                     | X     | X          .2+| vertex, tessellation, and geometry *out*
| *xfb_offset* =          |                   | X                     | X     | X
endif::GLSL[]
| *vertices* =            | X                 |                       |       |               | tessellation control *out*
| [ *points* ] +
  *line_strip* +
ifdef::GLSL[]
  *triangle_strip*        | X                 |                       |       |            .3+| geometry *out*
endif::GLSL[]

ifdef::ESSL[]
  *triangle_strip*        | X                 |                       |       |            .2+| geometry *out*
endif::ESSL[]
| *max_vertices* =        | X                 |                       |       |
ifdef::GLSL[]
| *stream* =              | X                 | X                     | X     | X
| *depth_any* +
  *depth_greater* +
  *depth_less* +
  *depth_unchanged*       |                   | _gl_FragDepth_ only   |       |               | fragment *out*
endif::GLSL[]

| *constant_id* =         |                   | scalar only           |       |               | *const* (SPIR-V only)
| *rgba32f* +
  *rgba16f* +
ifdef::GLSL[]
  *rg32f* +
  *rg16f* +
  *r11f_g11f_b10f* +
endif::GLSL[]
  *r32f* +
ifdef::GLSL[]
  *r16f* +
  *rgba16* +
  *rgb10_a2* +
endif::GLSL[]
  *rgba8* +
ifdef::GLSL[]
  *rg16* +
  *rg8* +
  *r16* +
  *r8* +
  *rgba16_snorm* +
endif::GLSL[]
  *rgba8_snorm* +
ifdef::GLSL[]
  *rg16_snorm* +
  *rg8_snorm* +
  *r16_snorm* +
  *r8_snorm* +
endif::GLSL[]
  *rgba32i* +
  *rgba16i* +
  *rgba8i* +
ifdef::GLSL[]
  *rg32i* +
  *rg16i* +
  *rg8i* +
endif::GLSL[]
  *r32i* +
ifdef::GLSL[]
  *r16i* +
  *r8i* +
endif::GLSL[]
  *rgba32ui* +
  *rgba16ui* +
ifdef::GLSL[*rgb10_a2ui* +]
  *rgba8ui* +
ifdef::GLSL[]
  *rg32ui* +
  *rg16ui* +
  *rg8ui* +
  *r32ui* +
  *r16ui* +
  *r8ui*                  |                   | image types only      |       |               | *uniform*
endif::GLSL[]
ifdef::ESSL[]
  *r32ui*                 |                   | image types only      |       |               | *uniform*
| *blend_support_multiply* +
  *blend_support_screen* +
  *blend_support_overlay* +
  *blend_support_darken* +
  *blend_support_lighten* +
  *blend_support_colordodge blend_support_colorburn* +
  *blend_support_hardlight* +
  *blend_support_softlight* +
  *blend_support_difference* +
  *blend_support_exclusion* +
  *blend_support_hsl_hue* +
  *blend_support_hsl_saturation* +
  *blend_support_hsl_color blend_support_hsl_luminosity* +
  *blend_support_all_equations*
                          | X                 |                       |       |               | fragment *out*
endif::ESSL[]
|====

1::
    Location qualifiers are not allowed for members of an arrayed block,
    except for per-vertex-arrays (see "`<<interface-blocks, Interface
    Blocks>>`").


[[input-layout-qualifiers]]
=== Input Layout Qualifiers

Layout qualifiers specific to a particular shader language are discussed in
separate sections below.

All shaders except compute shaders allow *location* layout qualifiers on
input variable declarations, input block declarations, and input block
member declarations.
ifdef::GLSL[]
Of these, variables and block members (but not blocks) additionally allow
the *component* layout qualifier.
endif::GLSL[]

ifdef::GLSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *location* *=* _layout-qualifier-value_ +
    *component* *=* _layout-qualifier-value_
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *location* *=* _layout-qualifier-value_
--
endif::ESSL[]

For example,

ifdef::GLSL[]
[source,glsl]
----
layout(location = 3) in vec4 normal;
const int start = 6;
layout(location = start + 2) in vec4 v;
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
layout(location = 3) in vec4 normal;
----
endif::ESSL[]

will establish that the shader input _normal_ is assigned to vector location
number
ifdef::ESSL[3.]
ifdef::GLSL[3 and _v_ is assigned location number 8.]
For vertex shader inputs, the location specifies the number of the
vertex attribute from which input values are taken.
For inputs of all other shader types, the location specifies a vector number
that can be used to match against outputs from a previous shader stage, even
if that shader is in a different program object.

The following language describes how many locations are consumed by a given
type.
However, geometry shader inputs, tessellation control shader inputs and
outputs, and tessellation evaluation inputs all have an additional level of
arrayness relative to other shader inputs and outputs.
This outer array level is removed from the type before considering how many
locations the type consumes.

ifdef::GLSL[]
Except when targeting Vulkan,
if a vertex shader input is any scalar or vector type, it will consume a
single location.
If a non-vertex shader input, or any stage input when targeting Vulkan,
is a scalar or vector type other than *dvec3*
or *dvec4*, it will consume a single location, while types *dvec3* or
*dvec4* will consume two consecutive locations.
endif::GLSL[]
ifdef::ESSL[]
If a shader input is any scalar or vector type, it will consume a single
location.
endif::ESSL[]

If the declared input (after potentially removing an outer array level as
just described above) is an array of size _n_ and each of the elements takes
_m_ locations, it will be assigned _m_ * _n_ consecutive locations starting
with the location specified.
For example,

[source,glsl]
----
layout(location = 6) in vec4 colors[3];
----

will establish that the shader input _colors_ is assigned to vector location
numbers 6, 7, and 8.

If the declared input is an _n_ {times} _m_
matrix, it will be assigned multiple locations starting with the location
specified.
The number of locations assigned for each matrix will be the same as for an
_n_-element array of _m_-component vectors.
For example,

[source,glsl]
----
layout(location = 9) in mat4 transforms[2];
----

will establish that shader input _transforms_ is assigned to vector
locations 9-16, with _transforms[0]_ being assigned to locations 9-12, and
_transforms[1]_ being assigned to locations 13-16.

If the declared input is a structure or block, its members will be assigned
consecutive locations in their order of declaration, with the first member
assigned the location provided in the layout qualifier.
For a structure, this process applies to the entire structure.
It is a compile-time error to use a *location* qualifier on a member of a
structure.
For a block, this process applies to the entire block, or until the first
member is reached that has a *location* layout qualifier.

When a block member is declared with a *location* qualifier, its location
comes from that qualifier; the member's *location* qualifier overrides the
block-level declaration.
Subsequent members are again assigned consecutive locations, based on the
newest location, until the next member declared with a *location* qualifier.
The values used for locations do not have to be declared in increasing
order.

If a block has no block-level *location* layout qualifier, it is required
that either all or none of its members have a *location* layout qualifier,
or a compile-time error results.
For some blocks declared as arrays, the *location* can only be applied at
the block level: When a block is declared as an array where additional
locations are needed for each member for each block array element, it is a
compile-time error to specify locations on the block members.
For _arrayed_ interfaces (those generally having an extra level of arrayness
due to interface expansion), the outer array is stripped before applying
this rule.

When generating SPIR-V, all *in* and *out* qualified user-declared (non
built-in) variables and blocks (or all their members) must have a
shader-specified *location*.
Otherwise, a compile-time error is generated.

The locations consumed by block and structure members are determined by
applying the rules above recursively as though the structure member were
declared as an input variable of the same type.
For example:

[source,glsl]
----
layout(location = 3) in struct S
{
    vec3 a;                      // gets location 3
    mat2 b;                      // gets locations 4 and 5
    vec4 c[2];                   // gets locations 6 and 7
    layout(location = 8) vec2 A; // ERROR, can't use on struct member
} s;
layout(location = 4) in block
{
    vec4 d;                      // gets location 4
    vec4 e;                      // gets location 5
    layout(location = 7) vec4 f; // gets location 7
    vec4 g;                      // gets location 8
    layout(location = 1) vec4 h; // gets location 1
    vec4 i;                      // gets location 2
    vec4 j;                      // gets location 3
    vec4 k;                      // ERROR, location 4 already used
};
----

The number of input locations available to a shader is limited.
For vertex shaders, the limit is the advertised number of vertex attributes.
For all other shaders, the limit is implementation-dependent and must be no
less than one fourth of the advertised maximum input component count.

A program will fail to link if any attached shader uses a location greater
than or equal to the number of supported locations, unless device-dependent
optimizations are able to make the program fit within available hardware
resources.

A program will fail to link if explicit location assignments leave the
linker unable to find space for other variables without explicit
assignments.

For the purposes of determining if a non-vertex input matches an output from
a previous shader stage, the *location* layout qualifier (if any) must
match.

If a vertex shader input variable with no location assigned in the shader
text has a location specified through the {apiname} API, the API-assigned
location will be used.
Otherwise, such variables will be assigned a location by the linker.
See section 11.1.1 "`Vertex Attributes`" of the <<references,{apispec}>> for
more details.
ifdef::GLSL[]
A link-time error will occur if an input variable is declared in multiple
shaders of the same language with conflicting locations.
endif::GLSL[]
ifdef::ESSL[]

It is an error if more than one input or element of a matrix input is bound
to the same location.
endif::ESSL[]

ifdef::GLSL[]
The *component* qualifier allows the location to be more finely specified
for scalars and vectors, down to the individual components within a location
that are consumed.
It is a compile-time error to use *component* without also specifying the
*location* qualifier (order does not matter).
The components within a location are 0, 1, 2, and 3.
A variable or block member starting at component _N_ will consume components
_N_, _N+1_, _N+2_, ...
up through its size.
It is a compile-time error if this sequence of components gets larger than
3.
A scalar *double* will consume two of these components, and a *dvec2* will
consume all four components available within a location.
A *dvec3* or *dvec4* can only be declared without specifying a *component*.
A *dvec3* will consume all four components of the first location and
components 0 and 1 of the second location.
This leaves components 2 and 3 available for other component-qualified
declarations.

For example:

[source,glsl]
----
// a consumes components 2 and 3 of location 4
layout(location = 4, component = 2) in vec2 a;

// b consumes component 1 of location 4
layout(location = 4, component = 1) in float b;

// ERROR: c overflows component 3
layout(location = 3, component = 2) in vec3 c;

// d consumes components 2 and 3 of location 5
layout(location = 5, component = 2) in double d;

// ERROR: e overflows component 3 of location 6
layout(location = 6, component = 2) in dvec2 e;

// ERROR: f overlaps with g
layout(location = 7, component = 0) in vec2 f;
layout(location = 7, component = 1) in float g;

layout(location = 8) in dvec3 h; // components 0,1,2 and 3 of location 8
                                 // and components 0 and 1 of location 9
layout(location = 9, component = 2) in double i; // okay, compts 2 and 3
----

If the variable is an array, each element of the array, in order, is
assigned to consecutive locations, but all at the same specified component
within each location.
For example:

[source,glsl]
----
// component 3 is consumed in each of 6 locations
layout(location = 2, component = 3) in float d[6];
----

That is, location 2 component 3 will hold _d[0]_, location 3 component 3
will hold _d[1]_, ..., up through location 7 component 3 holding _d[5]_.

This allows packing of two arrays into the same set of locations:

[source,glsl]
----
// e consumes beginning (components 0, 1 and 2) of each of 6 slots
layout(location = 0, component = 0) in vec3 e[6];

// f consumes last component of the same 6 slots
layout(location = 0, component = 3) in float f[6];
----

If applying this to an array of arrays, all levels of arrayness are removed
to get to the elements that are assigned per location to the specified
component.
These non-arrayed elements will fill the locations in the order specified
for arrays of arrays in "`<<arrays, Arrays>>`".

It is a compile-time error to apply the *component* qualifier to a matrix, a
structure, a block, or an array containing any of these.
It is a compile-time error to use *component* 1 or 3 as the beginning of a
*double* or *dvec2*.
It is a link-time error to specify different components for the same
variable within a program.

_Location aliasing_ is causing two variables or block members to have the
same location number.
_Component aliasing_ is assigning the same (or overlapping) component
numbers for two location aliases.
(Recall if *component* is not used, components are assigned starting with
0.)
With one exception, location aliasing is allowed only if it does not
cause component aliasing; it is a compile-time or link-time error to cause
component aliasing.
Further, when location aliasing, the aliases sharing the location must have
the same underlying numerical type and bit width  (floating-point or integer,
32-bit versus 64-bit, etc.) and the same
auxiliary storage and interpolation qualification.
The one exception where component aliasing is permitted is
when targeting {apiname} for two input
variables (not block members) to a vertex shader, which are allowed to have
component aliasing.
This vertex-variable component aliasing is intended only to support vertex
shaders where each execution path accesses at most one input per
aliased component.
Implementations are permitted, but not required, to generate link-time
errors if they detect that every path through the vertex shader executable
accesses multiple inputs aliased to any single component.
endif::GLSL[]


[[tessellation-evaluation-inputs]]
==== Tessellation Evaluation Inputs

Additional input layout qualifier identifiers allowed for tessellation
evaluation shaders are described below.

[role="bnf"]
--
_layout-qualifier-id_ : ::
    _primitive_mode_ +
    _vertex_spacing_ +
    _ordering_ +
    _point_mode_
--

The *primitive-mode* is used to specify a tessellation primitive mode to be
used by the tessellation primitive generator.

[role="bnf"]
--
_primitive-mode_: ::
    *triangles* +
    *quads* +
    *isolines*
--

If present, the _primitive-mode_ specifies that the tessellation primitive
generator should subdivide a triangle into smaller triangles, a quad into
triangles, or a quad into a collection of lines, respectively.

A second group of layout identifiers, _vertex spacing_, is used to specify
the spacing used by the tessellation primitive generator when subdividing an
edge.

[role="bnf"]
--
_vertex-spacing_: ::
    *equal_spacing* +
    *fractional_even_spacing* +
    *fractional_odd_spacing*
--

*equal_spacing* specifies that edges should be divided into a collection of
equal-sized segments;

*fractional_even_spacing* specifies that edges should be divided into an
even number of equal-length segments plus two additional shorter
"`fractional`" segments; or

*fractional_odd_spacing* specifies that edges should be divided into an odd
number of equal-length segments plus two additional shorter "`fractional`"
segments.

A third group of layout identifiers, _ordering_, specifies whether the
tessellation primitive generator produces triangles in clockwise or
counter-clockwise order, according to the coordinate system depicted in the
<<references,{apispec}>>.

[role="bnf"]
--
_ordering_: ::
    *cw* +
    *ccw*
--

The identifiers *cw* and *ccw* indicate clockwise and counter-clockwise
triangles, respectively.
If the tessellation primitive generator does not produce triangles, the
order is ignored.

Finally, _point mode_ indicates that the tessellation primitive generator
should produce one point for each distinct vertex in the subdivided
primitive, rather than generating lines or triangles.

[role="bnf"]
--
_point-mode_: ::
    *point_mode*
--

Any or all of these identifiers may be specified one or more times in a
single input layout declaration.
ifdef::GLSL[]
If primitive mode, vertex spacing, or ordering is declared more than once in
the tessellation evaluation shaders of a program, all such declarations must
use the same identifier.

At least one tessellation evaluation shader (compilation unit) in a program
must declare a primitive mode in its input layout.
endif::GLSL[]
ifdef::ESSL[]
The tessellation evaluation shader object in a program must declare a
primitive mode in its input layout.
endif::ESSL[]
Declaring vertex spacing, ordering, or point mode identifiers is optional.
ifdef::GLSL[]
It is not required that all tessellation evaluation shaders in a program
declare a primitive mode.
endif::GLSL[]
If spacing or vertex ordering declarations are omitted, the tessellation
primitive generator will use equal spacing or counter-clockwise vertex
ordering, respectively.
If a point mode declaration is omitted, the tessellation primitive generator
will produce lines or triangles according to the primitive mode.


[[geometry-shader-inputs]]
==== Geometry Shader Inputs

Additional layout qualifier identifiers for geometry shader inputs include
_primitive_ identifiers and an _invocation count_ identifier:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *points* +
    *lines* +
    *lines_adjacency* +
    *triangles* +
    *triangles_adjacency* +
    *invocations* *=* _layout-qualifier-value_
--

The identifiers *points*, *lines*, *lines_adjacency*, *triangles*, and
*triangles_adjacency* are used to specify the type of input primitive
accepted by the geometry shader, and only one of these is accepted.
ifdef::GLSL[]
At least one geometry shader (compilation unit) in a program must declare
this input primitive layout, and all geometry shader input layout
declarations in a program must declare the same layout.
It is not required that all geometry shaders in a program declare an input
primitive layout.
endif::GLSL[]
ifdef::ESSL[]
The geometry shader must declare this input primitive layout.
endif::ESSL[]

The identifier *invocations* is used to specify the number of times the
geometry shader executable is invoked for each input primitive received.
Invocation count declarations are optional.
ifdef::GLSL[]
If no invocation count is declared in any geometry shader in a program, the
geometry shader will be run once for each input primitive.
endif::GLSL[]
ifdef::ESSL[]
If no invocation count is declared in the geometry shader, it will be run
once for each input primitive.
endif::ESSL[]
If an invocation count is declared, all such declarations must specify the
same count.
If a shader specifies an invocation count greater than the
implementation-dependent maximum, or less than or equal to zero,
a compile-time error results.

For example,

[source,glsl]
----
layout(triangles, invocations = 6) in;
----

will establish that all inputs to the geometry shader are triangles and that
the geometry shader executable is run six times for each triangle processed.

All geometry shader input unsized array declarations will be sized by an
earlier input primitive layout qualifier, when present, as per the following
table.

[options="header"]
|====
| Layout                | Size of Input Arrays
| *points*              | 1
| *lines*               | 2
| *lines_adjacency*     | 4
| *triangles*           | 3
| *triangles_adjacency* | 6
|====

The intrinsically declared input array _gl_in[]_ will also be sized by any
input primitive-layout declaration.
Hence, the expression

[source,glsl]
----
gl_in.length()
----

will return the value from the table above.

ifdef::GLSL[]
For inputs declared without an array size, including intrinsically declared
inputs (i.e., _gl_in_), a layout must be declared before any use of the
method *length*() or other any array use that requires the array size to be
known.
endif::GLSL[]
ifdef::ESSL[]
An input can be declared without an array size if there is a previous layout
which specifies the size.
For built-in inputs (e.g. _gl_in[]_), a layout must be declared before any
use.
endif::ESSL[]

It is a compile-time error if a layout declaration's array size (from the
table above) does not match all the explicit array sizes specified in
declarations of an input variables in the same shader.
The following includes examples of compile-time errors:

[source,glsl]
----
// code sequence within one shader...
ifdef::GLSL[]
in vec4 Color1[];     // legal, size still unknown
endif::GLSL[]
in vec4 Color2[2];    // legal, size is 2
in vec4 Color3[3];    // illegal, input sizes are inconsistent
layout(lines) in;     // legal for Color2, input size is 2, matching Color2
in vec4 Color4[3];    // illegal, contradicts layout of lines
layout(lines) in;     // legal, matches other layout() declaration
layout(triangles) in; // illegal, does not match earlier layout() declaration
----

It is a link-time error if not all provided sizes (sized input arrays and
ifdef::GLSL[layout size) match across all geometry shaders in a program.]
ifdef::ESSL[layout size) match in the geometry shader of a program.]


[[fragment-shader-inputs]]
==== Fragment Shader Inputs

ifdef::GLSL[]
Additional fragment layout qualifier identifiers include the following for
_gl_FragCoord_ :

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *origin_upper_left* +
    *pixel_center_integer*
--

By default, _gl_FragCoord_ in {apiname} assumes a lower-left origin for window
coordinates and assumes pixel centers are located at half-pixel coordinates.
For example, the (_x, y_) location (0.5, 0.5) is returned for the
lower-left-most pixel in a window.
The origin can be changed by redeclaring _gl_FragCoord_ with the
*origin_upper_left* qualifier, moving the origin of _gl_FragCoord_ to the
upper left of the window, with _y_ increasing in value toward the bottom of
the window.
The values returned can also be shifted by half a pixel in both _x_ and _y_
by *pixel_center_integer* so it appears the pixels are centered at whole
number pixel offsets.
This moves the (_x_, _y_) value returned by _gl_FragCoord_ of (0.5, 0.5) by
default, to (0.0, 0.0) with *pixel_center_integer*.

Targeting Vulkan will assume and require an upper-left origin for _gl_FragCoord_
with pixel centers located at half-pixel coordinates.
This origin can be explicitly set by redeclaring _gl_FragCoord_ with the
*origin_upper_left* identifier.

Redeclarations are done as follows

[source,glsl]
----
in vec4 gl_FragCoord; // redeclaration that changes nothing is allowed

// All the following are allowed redeclaration that change behavior
layout(origin_upper_left) in vec4 gl_FragCoord;
layout(pixel_center_integer) in vec4 gl_FragCoord;
layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;
----

If _gl_FragCoord_ is redeclared in any fragment shader in a program, it must
be redeclared in all the fragment shaders in that program that have a static
use _gl_FragCoord_.
All redeclarations of _gl_FragCoord_ in all fragment shaders in a single
program must have the same set of qualifiers.
Within any shader, the first redeclarations of _gl_FragCoord_ must appear
before any use of _gl_FragCoord_.
The built-in _gl_FragCoord_ is only predeclared in fragment shaders, so
redeclaring it in any other shader language results in a compile-time error.

Redeclaring _glFragCoord_ with *origin_upper_left* and/or
*pixel_center_integer* qualifiers only affects _gl_FragCoord.x_ and
_gl_FragCoord.y_.
It has no effect on rasterization, transformation, or any other part of the
API pipeline or language features.
endif::GLSL[]

Fragment shaders allow the following layout qualifier on *in* only (not with
variable declarations):

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *early_fragment_tests*
--

to request that fragment tests be performed before fragment shader
ifdef::GLSL[]
execution, as described in section 15.2.4 "`Early Fragment Tests`" of the
endif::GLSL[]
ifdef::ESSL[]
execution, as described in section 13.8.4 "`Early Fragment Tests`" of the
endif::ESSL[]
<<references,{apispec}>>.

For example,

[source,glsl]
----
layout(early_fragment_tests) in;
----

Specifying this will make per-fragment tests be performed before fragment
shader execution.
ifdef::ESSL[]
In addition it is an error to statically write to _gl_FragDepth_ in the
fragment shader.
endif::ESSL[]
If this is not declared, per-fragment tests will be performed after fragment
shader execution.
ifdef::GLSL[]
Only one fragment shader (compilation unit) need declare this, though more
than one can.
If at least one declares this, then it is enabled.
endif::GLSL[]


[[compute-shader-inputs]]
==== Compute Shader Inputs

There are no layout location qualifiers for compute shader inputs.

Layout qualifier identifiers for compute shader inputs are the workgroup
size qualifiers:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *local_size_x* *=* _layout-qualifier-value_ +
    *local_size_y* *=* _layout-qualifier-value_ +
    *local_size_z* *=* _layout-qualifier-value_
--

The *local_size_x*, *local_size_y*, and *local_size_z* qualifiers are used
to declare a fixed workgroup size by the compute shader in the first,
second, and third dimension, respectively.
If a shader does not specify a size for one of the dimensions, that
dimension will have a size of 1.

For example, the following declaration in a compute shader

[source,glsl]
----
layout(local_size_x = 32, local_size_y = 32) in;
----

is used to declare a two-dimensional compute shader with a workgroup size of 32
X 32 elements, which is equivalent to a three-dimensional compute shader
where the third dimension has size one.

As another example, the declaration

[source,glsl]
----
layout(local_size_x = 8) in;
----

effectively specifies that a one-dimensional compute shader is being
compiled, and its size is 8 elements.

If the fixed workgroup size of the shader in any dimension is less than
or equal to zero or greater than the maximum size supported by the
implementation for that dimension, a compile-time error results.
Also, if such a layout qualifier is declared more than once in the same
shader, all those declarations must set the same set of workgroup
sizes and set them to the same values; otherwise a compile-time error
results.
ifdef::GLSL[]
If multiple compute shaders attached to a single program object declare a
fixed workgroup size, the declarations must be identical; otherwise a
link-time error results.

Furthermore, if a program object contains any compute shaders, at least one
must contain an input layout qualifier specifying a fixed workgroup size
for the program, or a link-time error will occur.
endif::GLSL[]
ifdef::ESSL[]

Furthermore, if a program object contains a compute shader, that shader must
contain an input layout qualifier specifying a fixed workgroup size for
the program, or a link-time error will occur.
endif::ESSL[]


[[output-layout-qualifiers]]
=== Output Layout Qualifiers

Some output layout qualifiers apply to all shader stages and some apply only
to specific stages.
The latter are discussed in separate sections below.

As with input layout qualifiers, all shaders except compute shaders allow
*location* layout qualifiers on output variable declarations, output block
declarations, and output block member declarations.
ifdef::GLSL[]
Of these, variables and block members (but not blocks) additionally allow
the *component* layout qualifier.
endif::GLSL[]

ifdef::GLSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *location* *=* _layout-qualifier-value_ +
    *component* *=* _layout-qualifier-value_
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *location* *=* _layout-qualifier-value_
--
endif::ESSL[]

The usage and rules for applying the *location* qualifier
ifdef::GLSL[and the *component* qualifier]
to blocks and structures are exactly as described in
"`<<input-layout-qualifiers,Input Layout Qualifiers>>`".
ifdef::GLSL[]
No component aliasing of output variables or members is allowed.

Fragment shaders allow an additional *index* output layout qualifier:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *index* *=* _layout-qualifier-value_
--

Each of these qualifiers may appear at most once.
If *index* is specified, *location* must also be specified.
If *index* is not specified, the value 0 is used.
endif::GLSL[]
ifdef::ESSL[]
The qualifier may appear at most once within a declaration.
endif::ESSL[]
For example, in a fragment shader,

[source,glsl]
----
layout(location = 3) out vec4 color;
----

will establish that the fragment shader output _color_ is assigned to
ifdef::GLSL[]
fragment color 3 as the first (index zero) input to the blend equation.
endif::GLSL[]
ifdef::ESSL[]
fragment color 3.
endif::ESSL[]
ifdef::GLSL[]
And,

[source,glsl]
----
layout(location = 3, index = 1) out vec4 factor;
----

will establish that the fragment shader output _factor_ is assigned to
fragment color 3 as the second (index one) input to the blend equation.
endif::GLSL[]

For fragment shader outputs, the location
ifdef::GLSL[and index specify]
ifdef::ESSL[specifies]
the color output number
ifdef::GLSL[and index]
receiving the values of the output.
For outputs of all other shader stages, the location specifies a vector
number that can be used to match against inputs in a subsequent shader
stage, even if that shader is in a different program object.

ifdef::GLSL[]
If a declared output is a scalar or vector type other than *dvec3* or
*dvec4*, it will consume a single location.
Outputs of type *dvec3* or *dvec4* will consume two consecutive locations.
Outputs of type *double* and *dvec2* will consume only a single location, in
all stages.
endif::GLSL[]
ifdef::ESSL[]
Declared outputs of scalar or vector type consume a single location.
endif::ESSL[]

If the declared output is an array, it will be assigned consecutive
locations starting with the location specified.
For example,

[source,glsl]
----
layout(location = 2) out vec4 colors[3];
----

will establish that _colors_ is assigned to vector location numbers 2, 3,
and 4.

If the declared output is an _n_ {times} _m_
matrix, it will be assigned multiple locations starting with the location
specified.
The number of locations assigned will be the same as for an _n_-element
array of _m_-component vectors.

If the declared output is a structure, its members will be assigned
consecutive locations in the order of declaration, with the first member
assigned the location specified for the structure.
The number of locations consumed by a structure member is determined by
applying the rules above recursively as though the structure member were
declared as an output variable of the same type.

*location* layout qualifiers may be used on output variables declared as
structures.
However, it is a compile-time error to use a *location* qualifier on a
structure member.
Location layout qualifiers may be used on output blocks and output block
members.

ifdef::ESSL[]
If an output is declared as an array of blocks, excluding per-vertex-arrays
as required for tessellation, it is an error to declare a member of the
block with a *location* qualifier.
endif::ESSL[]

The number of output locations available to a shader is limited.
For fragment shaders, the limit is the advertised number of draw buffers.

For all other shaders, the limit is implementation-dependent and must be no
less than one fourth of the advertised maximum output component count
(compute shaders have no outputs).
A program will fail to link if any attached shader uses a location greater
than or equal to the number of supported locations, unless device-dependent
optimizations are able to make the program fit within available hardware
resources.

Compile-time errors may also be given if at compile time it is known the
link will fail.
A negative output location will result in {compiletimeerror}.
ifdef::GLSL[]
It is also a compile-time error if a fragment shader sets a layout index to
less than 0 or greater than 1.
endif::GLSL[]

It is a compile-time or link-time error if any of the following occur:

  * any two fragment shader output variables are assigned to the same
ifdef::GLSL[]
    location and index.
endif::GLSL[]
ifdef::ESSL[]
    location.
endif::ESSL[]
  * if any two output variables from the same vertex, tessellation or
    geometry shader stage are assigned to the same location.

ifdef::GLSL[]
For fragment shader outputs, locations can be assigned using either a
*layout* qualifier or via the {apiname} API.
endif::GLSL[]

For all shader types, a program will fail to link if explicit location
assignments leave the linker unable to find space for other variables
without explicit assignments.

ifdef::GLSL[]
If an output variable with no location or index assigned in the shader text
has a location specified through the {apiname} API, the API-assigned
location will be used.
Otherwise, such variables will be assigned a location by the linker.
All such assignments will have a color index of zero.
See section 15.2 "`Shader Execution`" of the <<references,{apispec}>> for
more details.
A link-time error will occur if an output variable is declared in multiple
shaders of the same language with conflicting location or index values.
endif::GLSL[]
ifdef::ESSL[]
If an output variable has no location assigned in the shader text, it will
be assigned a location by the linker.
See section 11.1.3 "`Shader Execution`" of the <<references,{apispec}>> for
more details.

If there is only a single output, the location does not need to be
specified, in which case it defaults to zero.
This applies for all output types, including arrays.
If there is more than one fragment output, the location must be specified
for all outputs.
endif::ESSL[]

For the purposes of determining if a non-fragment output matches an input
from a subsequent shader stage, the *location* layout qualifier (if any)
must match.


ifdef::GLSL[]
[[transform-feedback-layout-qualifiers]]
==== Transform Feedback Layout Qualifiers

The vertex, tessellation, and geometry stages allow shaders to control
transform feedback.
When doing this, shaders will dictate which transform feedback buffers are
in use, which output variables will be written to which buffers, and how
each buffer is laid out.
To accomplish this, shaders allow the following layout qualifier identifiers
on output declarations:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *xfb_buffer* *=* _layout-qualifier-value_ +
    *xfb_offset* *=* _layout-qualifier-value_ +
    *xfb_stride* *=* _layout-qualifier-value_
--

Any shader making any static use (after preprocessing) of any of these
*xfb_* qualifiers will cause the shader to be in a transform feedback
capturing mode and hence responsible for describing the transform feedback
setup.
This mode will capture any output selected by *xfb_offset*, directly or
indirectly, to a transform feedback buffer.

The *xfb_buffer* qualifier specifies which transform feedback buffer will
capture outputs selected with *xfb_offset*.
The *xfb_buffer* qualifier can be applied to the qualifier *out*, to output
variables, to output blocks, and to output block members.
Shaders in the transform feedback capturing mode have an initial global
default of

[source,glsl]
----
layout(xfb_buffer = 0) out;
----

This default can be changed by declaring a different buffer with
*xfb_buffer* on the interface qualifier *out*.
This is the only way the global default can be changed.
When a variable or output block is declared without an *xfb_buffer*
qualifier, it inherits the global default buffer.
When a variable or output block is declared with an *xfb_buffer* qualifier,
it has that declared buffer.
All members of a block inherit the block's buffer.
A member is allowed to declare an *xfb_buffer*, but it must match the buffer
inherited from its block, or a compile-time error results.

[source,glsl]
----
layout(xfb_buffer=2, xfb_offset=0) out block { // block's buffer is 2
    layout(xfb_buffer = 2) vec4 v; // okay, matches the inherited 2
    layout(xfb_buffer = 3) vec4 u; // ERROR, mismatched buffer
    vec4 w; // inherited
};
layout(xfb_offset=16) out vec4 t;  // initial default is buffer 0
layout(xfb_buffer=1) out;          // new global default of 1
out block {                        // block has buffer 1
    vec4 x;                        // x has buffer 1 (not captured)
    layout(xfb_buffer = 1) vec4 y; // okay (not captured)
    layout(xfb_buffer = 0) vec4 z; // ERROR, mismatched buffer
};
layout(xfb_offset=0) out vec4 g;   // g has buffer 1
layout(xfb_buffer=2) out vec4 h;   // does not change global default
layout(xfb_offset=16) out vec4 j;  // j has buffer 1
----

Note this means all members of a block that go to a transform feedback
buffer will go to the same buffer.

When a block is declared as an array, all members of block array-element 0
are captured, as previously described, by the declared or inherited
*xfb_buffer*.
Generally, an array of size _N_ of blocks is captured by _N_ consecutive
buffers, with all members of block array-element _E_ captured by buffer _B_,
where _B_ equals the declared or inherited *xfb_buffer* plus _E_.

It is a compile-time or link-time error to specify an *xfb_buffer*,
including any additional buffers needed to capture an arrays of blocks, that
is less than zero or greater than or equal to the implementation-dependent
constant _gl_MaxTransformFeedbackBuffers_.

The *xfb_offset* qualifier assigns a byte offset within a transform feedback
buffer.
Only variables, block members, or blocks can be qualified with *xfb_offset*.
If a block is qualified with *xfb_offset*, all its members are assigned
transform feedback buffer offsets.
If a block is not qualified with *xfb_offset*, any members of that block not
qualified with an *xfb_offset* will not be assigned transform feedback
buffer offsets.
Only variables and block members that are assigned offsets will be captured
(thus, a proper subset of a block can be captured).
Each time such a variable or block member is written in a shader, the
written value is captured at the assigned offset.
If such a block member or variable is not written during a shader
invocation, the buffer contents at the assigned offset will be undefined.
Even if there are no static writes to a variable or member that is assigned
a transform feedback offset, the space is still allocated in the buffer and
still affects the stride.

Variables and block members qualified with *xfb_offset* can be scalars,
vectors, matrices, structures, and (sized) arrays of these.
The offset must be a multiple of the size of the first component of the
first qualified variable or block member, or a compile-time error results.
Further, if applied to an aggregate containing a *double*, the offset must
also be a multiple of 8, and the space taken in the buffer will be a
multiple of 8.
The given offset applies to the first component of the first member of the
qualified entity.
Then, within the qualified entity, subsequent components are each assigned,
in order, to the next available offset aligned to a multiple of that
component's size.
Aggregate types are flattened down to the component level to get this
sequence of components.
It is a compile-time error to apply *xfb_offset* to the declaration of an
unsized array.

No aliasing in output buffers is allowed: It is a compile-time or link-time
error to specify variables with overlapping transform feedback offsets.

The *xfb_stride* qualifier specifies how many bytes are consumed by each
captured vertex.
It applies to the transform feedback buffer for that declaration, whether it
is inherited or explicitly declared.
It can be applied to variables, blocks, block members, or just the qualifier
*out*.
If the buffer is capturing any outputs with double-precision components, the
stride must be a multiple of 8, otherwise it must be a multiple of 4, or a
compile-time or link-time error results.
It is a compile-time or link-time error to have any *xfb_offset* that
overflows *xfb_stride*, whether stated on declarations before or after the
*xfb_stride*, or in different compilation units.
While *xfb_stride* can be declared multiple times for the same buffer, it is
a compile-time or link-time error to have different values specified for the
stride for the same buffer.

For example:

[source,glsl]
----
// buffer 1 has 32-byte stride
layout(xfb_buffer = 1, xfb_stride = 32) out;

// same as previous example; order within layout does not matter
layout(xfb_stride = 32, xfb_buffer = 1) out;

// everything in this block goes to buffer 0
layout(xfb_buffer = 0, xfb_stride = 32) out block1 {
    layout(xfb_offset = 0) vec4 a;  // a goes to byte offset 0 of buffer 0
    layout(xfb_offset = 16) vec4 b; // b goes to offset 16 of buffer 0
};

layout(xfb_buffer = 3, xfb_offset = 12) out block2 {
    vec4 v;  // v will be written to byte offsets 12 through 27 of buffer
    float u; // u will be written to offset 28
    layout(xfb_offset = 40) vec4 w;
    vec4 x;  // x will be written to offset 56, the next available offset
};

layout(xfb_buffer = 2, xfb_stride = 32) out block3 {
    layout(xfb_offset = 12) vec3 c;
    layout(xfb_offset = 24) vec3 d; // ERROR, requires stride of 36
    layout(xfb_offset = 0) vec3 g;  // okay, increasing order not required
};
----

When no *xfb_stride* is specified for a buffer, the stride of the buffer
will be the smallest needed to hold the variable placed at the highest
offset, including any required padding.
For example:

[source,glsl]
----
// if there no other declarations for buffer 3, it has stride 32
layout(xfb_buffer = 3) out block4 {
    layout(xfb_offset = 0) vec4 e;
    layout(xfb_offset = 16) vec4 f;
};
----

The resulting stride (implicit or explicit), when divided by 4, must be less
than or equal to the implementation-dependent constant
_gl_MaxTransformFeedbackInterleavedComponents_.
endif::GLSL[]


[[tessellation-control-outputs]]
==== Tessellation Control Outputs

ifdef::GLSL[]
Other than for the transform feedback layout qualifiers, tessellation
control shaders allow output layout qualifiers only on the interface
endif::GLSL[]
ifdef::ESSL[]
Tessellation control shaders allow output layout qualifiers only on the
interface
endif::ESSL[]
qualifier *out*, not on an output block, block member, or variable
declaration.
The output layout qualifier identifiers allowed for tessellation control
shaders are:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *vertices* *=* _layout-qualifier-value_
--

The identifier *vertices* specifies the number of vertices in the output
patch produced by the tessellation control shader, which also specifies the
number of times the tessellation control shader is invoked.
It is a compile- or link-time error for the output vertex count to be less
than or equal to zero, or greater than the implementation-dependent maximum
patch size.

The intrinsically declared tessellation control output array _gl_out[]_ will
also be sized by any output layout declaration.
Hence, the expression

[source,glsl]
----
gl_out.length()
----

will return the output patch vertex count specified in a previous output
layout qualifier.
For outputs declared without an array size, including intrinsically declared
outputs (i.e., _gl_out_), a layout must be declared before any use of the
method *length*() or other array use that requires its size to be known.

It is a compile-time error if the output patch vertex count specified in an
output layout qualifier does not match the array size specified in any
output variable declaration in the same shader.

All tessellation control shader layout declarations in a program must
specify the same output patch vertex count.
There must be at least one layout qualifier specifying an output patch
ifdef::GLSL[]
vertex count in any program containing tessellation control shaders;
however, such a declaration is not required in all tessellation control
shaders.
endif::GLSL[]
ifdef::ESSL[]
vertex count in any program containing a tessellation control shader.
endif::ESSL[]


[[geometry-outputs]]
==== Geometry Outputs

ifdef::GLSL[]
Geometry shaders can have three additional types of output layout
identifiers: an output _primitive type_, a maximum output _vertex count_,
and per-output _stream_ numbers.
endif::GLSL[]
ifdef::ESSL[]
Geometry shaders can have two additional types of output layout identifiers:
an output primitive type and a maximum output vertex count.
endif::ESSL[]
The primitive type and vertex count identifiers are allowed only on the
interface qualifier *out*, not on an output block, block member, or variable
declaration.
ifdef::GLSL[]
The stream identifier is allowed on the interface qualifier *out*, on output
blocks, and on variable declarations.
endif::GLSL[]

The layout qualifier identifiers for geometry shader outputs are

ifdef::GLSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *points* +
    *line_strip* +
    *triangle_strip* +
    *max_vertices* *=* _layout-qualifier-value_ +
    *stream* *=* _layout-qualifier-value_
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *points* +
    *line_strip* +
    *triangle_strip* +
    *max_vertices* *=* _layout-qualifier-value_
--
endif::ESSL[]

The primitive type identifiers *points*, *line_strip*, and *triangle_strip*
are used to specify the type of output primitive produced by the geometry
shader, and only one of these is accepted.
ifdef::GLSL[]
At least one geometry shader (compilation unit) in a program must declare an
output primitive type, and all geometry shader output primitive type
declarations in a program must declare the same primitive type.
It is not required that all geometry shaders in a program declare an output
primitive type.
endif::GLSL[]
ifdef::ESSL[]
The geometry shader object in a program must declare an output primitive
type, and all geometry shader output primitive type declarations in a
program must declare the same primitive type.
endif::ESSL[]

The vertex count identifier *max_vertices* is used to specify the maximum
number of vertices the shader will ever emit in a single invocation.
ifdef::GLSL[]
At least one geometry shader (compilation unit) in a program must declare a
maximum output vertex count, and all geometry shader output vertex count
declarations in a program must declare the same count.
It is not required that all geometry shaders in a program declare a count.
endif::GLSL[]
ifdef::ESSL[]
The geometry shader object in a program must declare a maximum output vertex
count, and all geometry shader output vertex count declarations in a program
must declare the same count.
endif::ESSL[]

In this example,

[source,glsl]
----
layout(triangle_strip, max_vertices = 60) out; // order does not matter
layout(max_vertices = 60) out;  // redeclaration okay
layout(triangle_strip) out;     // redeclaration okay
layout(points) out;             // error, contradicts triangle_strip
layout(max_vertices = 30) out;  // error, contradicts 60
----

all outputs from the geometry shader are triangles and at most 60 vertices
will be emitted by the shader.
It is an error for the maximum number of vertices to be greater than
_gl_MaxGeometryOutputVertices_.

ifdef::GLSL[]
The identifier *stream* is used to specify that a geometry shader output
variable or block is associated with a particular vertex stream (numbered
beginning with zero).
A default stream number may be declared at global scope by qualifying
interface qualifier *out* as in this example:

[source,glsl]
----
layout(stream = 1) out;
----

The stream number specified in such a declaration replaces any previous
default and applies to all subsequent block and variable declarations until
a new default is established.
The initial default stream number is zero.

Each output block or non-block output variable is associated with a vertex
stream.
If the block or variable is declared with the stream identifier, it is
associated with the specified stream; otherwise, it is associated with the
current default stream.
A block member may be declared with a stream identifier, but the specified
stream must match the stream associated with the containing block.
One example:

[source,glsl]
----
layout(stream=1) out;           // default is now stream 1
out vec4 var1;                  // var1 gets default stream (1)
layout(stream=2) out Block1 {   // "Block1" belongs to stream 2
    layout(stream=2) vec4 var2; // redundant block member stream decl
    layout(stream=3) vec2 var3; // ILLEGAL (must match block stream)
    vec3 var4;                  // belongs to stream 2
};
layout(stream=0) out;           // default is now stream 0
out vec4 var5;                  // var5 gets default stream (0)
out Block2 {                    // "Block2" gets default stream (0)
    vec4 var6;
};
layout(stream=3) out vec4 var7; // var7 belongs to stream 3
----

Each vertex emitted by the geometry shader is assigned to a specific stream,
and the attributes of the emitted vertex are taken from the set of output
blocks and variables assigned to the targeted stream.
After each vertex is emitted, the values of all output variables become
undefined.
Additionally, the output variables associated with each vertex stream may
share storage.
Writing to an output variable associated with one stream may overwrite
output variables associated with any other stream.
When emitting each vertex, a geometry shader should write to all outputs
associated with the stream to which the vertex will be emitted and to no
outputs associated with any other stream.

If a geometry shader output block or variable is declared more than once,
all such declarations must associate the variable with the same vertex
stream.
If any stream declaration specifies a non-existent stream number, the shader
will fail to compile.

Built-in geometry shader outputs are always associated with vertex stream
zero.
endif::GLSL[]

All geometry shader output layout declarations in a program must declare the
same layout and same value for *max_vertices*.
If geometry shaders are in a program, there must be at least one geometry
output layout declaration somewhere in that
ifdef::GLSL[]
program, but not all geometry
shaders (compilation units) are required to declare it.
endif::GLSL[]
ifdef::ESSL[program.]


[[fragment-outputs]]
==== Fragment Outputs

ifdef::ESSL[]
Fragment shaders can have an output layout for redeclaring the built-in
variable _gl_FragDepth_:
endif::ESSL[]
ifdef::GLSL[]
The built-in fragment shader variable _gl_FragDepth_ may be redeclared using
one of the following layout qualifiers.

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *depth_any* +
    *depth_greater* +
    *depth_less* +
    *depth_unchanged*
--

The layout qualifier for _gl_FragDepth_ constrains intentions of the final
value of _gl_FragDepth_ written by any shader invocation.
GL implementations are allowed to perform optimizations assuming that the
depth test fails (or passes) for a given fragment if all values of
_gl_FragDepth_ consistent with the layout qualifier would fail (or pass).
This potentially includes skipping shader execution if the fragment is
discarded because it is occluded and the shader has no side effects.
If the final value of _gl_FragDepth_ is inconsistent with its layout
qualifier, the result of the depth test for the corresponding fragment is
undefined.
However, no error will be generated in this case.
If the depth test passes and depth writes are enabled, the value written to
the depth buffer is always the value of _gl_FragDepth_, whether or not it is
consistent with the layout qualifier.

By default, _gl_FragDepth_ is qualified as _depth_any_.
When the layout qualifier for _gl_FragDepth_ is _depth_any_, the shader
compiler will note any assignment to _gl_FragDepth_ modifying it in an
unknown way, and depth testing will always be performed after the shader has
executed.
When the layout qualifier is _depth_greater_, the GL can assume that the
final value of _gl_FragDepth_ is greater than or equal to the fragment's
interpolated depth value, as given by the _z_ component of _gl_FragCoord_.
When the layout qualifier is _depth_less_, the GL can assume that any
modification of _gl_FragDepth_ will only decrease its value.
When the layout qualifier is _depth_unchanged_, the shader compiler will
honor any modification to _gl_FragDepth_, but the rest of the GL can assume
that _gl_FragDepth_ is not assigned a new value.

Redeclarations of _gl_FragDepth_ are performed as follows:
endif::GLSL[]

ifdef::ESSL[]
[source,glsl]
----
// redeclaration that changes nothing is allowed
out float gl_FragDepth;
----
endif::ESSL[]
ifdef::GLSL[]
[source,glsl]
----
// redeclaration that changes nothing is allowed
out float gl_FragDepth;

// assume it may be modified in any way
layout(depth_any) out float gl_FragDepth;

// assume it may be modified such that its value will only increase
layout(depth_greater) out float gl_FragDepth;

// assume it may be modified such that its value will only decrease
layout(depth_less) out float gl_FragDepth;

// assume it will not be modified
layout(depth_unchanged) out float gl_FragDepth;
----

If _gl_FragDepth_ is redeclared in any fragment shader in a program, it must
be redeclared in all fragment shaders in that program that have static
assignments to _gl_FragDepth_.
All redeclarations of _gl_FragDepth_ in all fragment shaders in a single
program must have the same set of qualifiers.
Within any shader, the first redeclarations of _gl_FragDepth_ must appear
before any use of _gl_FragDepth_.
endif::GLSL[]
The built-in _gl_FragDepth_ is only predeclared in fragment shaders, so
redeclaring it in any other shader language results in {compiletimeerror}.

ifdef::ESSL[]
Fragment shaders additionally support layout qualifiers specifying a set of
advanced blend equations supported when the fragment shader is used.
These layout qualifiers are only permitted on the interface qualifier *out*,
and use the identifiers specified in the "`Layout Qualifier`" column of the
table below.

If a layout qualifier in the table below is specified in the fragment
shader, the fragment shader may be used with the corresponding advanced
blend equation in the "`Blend Equation(s) Supported`" column.
Additionally, the special qualifier *blend_support_all_equations* indicates
that the shader may be used with any advanced blending equation supported by
the <<references,{apispec}>>.
It is not an error to specify more than one of these identifiers in any
fragment shader.
Specifying more than one qualifier or *blend_support_all_equations* means
that the fragment shader may be used with multiple advanced blend equations.
Additionally, it is not an error to specify any single one of these layout
qualifiers more than once.

[cols="",]
|====
| Layout Qualifier                      | Blend Equations(s) Supported
| *blend_support_multiply*              | MULTIPLY
| *blend_support_screen*                | SCREEN
| *blend_support_overlay*               | OVERLAY
| *blend_support_darken*                | DARKEN
| *blend_support_lighten*               | LIGHTEN
| *blend_support_colordodge*            | COLORDODGE
| *blend_support_colorburn*             | COLORBURN
| *blend_support_hardlight*             | HARDLIGHT
| *blend_support_softlight*             | SOFTLIGHT
| *blend_support_difference*            | DIFFERENCE
| *blend_support_exclusion*             | EXCLUSION
| *blend_support_hsl_hue*               | HSL_HUE
| *blend_support_hsl_saturation*        | HSL_SATURATION
| *blend_support_hsl_color*             | HSL_COLOR
| *blend_support_hsl_luminosity*        | HSL_LUMINOSITY
| *blend_support_all_equations*         | all blend equations
|====
endif::ESSL[]


[[uniform-variable-layout-qualifiers]]
=== Uniform Variable Layout Qualifiers

ifdef::GLSL[]
Layout qualifiers can be used for uniform variables and subroutine uniforms.
The layout qualifier identifiers for uniform variables and subroutine
uniforms are:
endif::GLSL[]
ifdef::ESSL[]
The following layout qualifier can be used for all default-block uniform
variables but not for variables in uniform or shader storage blocks.
The layout qualifier identifier for uniform variables is:
endif::ESSL[]

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *location* *=* _layout-qualifier-value_
--

ifdef::GLSL[]
The location identifier can be used with default-block uniform variables and
subroutine uniforms.
endif::GLSL[]
The location specifies the location by which the API can reference
the uniform and update its value.
Individual elements of a uniform array are assigned consecutive locations
with the first element taking location *location*.
Default-block uniform variable declarations sharing the same location
linked in the program have to match by name, type, qualifiers and arrayness.
For arrays their array dimensionality and array sizes must match.
For structs this rule applies recursively to all members.
ifdef::GLSL[]
No two subroutine uniform variables can have the same location in the same
shader stage, otherwise a compile-time or link-time error will be generated.
endif::GLSL[]
Valid locations for default-block uniform variable locations are in the
range of 0 to the implementation-defined maximum number of uniform locations
minus one.
ifdef::GLSL[]
Valid locations for subroutine uniforms are in the range of 0 to the
implementation-defined per-stage maximum number of subroutine uniform
locations minus one.
endif::GLSL[]

Locations can be assigned to default-block uniform arrays and structures.
The first inner-most scalar, vector or matrix member or element takes the
specified *location* and the compiler assigns the next inner-most member or
element the next incremental location value.
Each subsequent inner-most member or element gets incremental locations for
the entire structure or array.
This rule applies to nested structures and arrays and gives each inner-most
scalar, vector, or matrix member a unique location.
ifdef::GLSL[]
For arrays without an explicit size, the size is calculated based on its
static usage.
endif::GLSL[]
When the linker generates locations for uniforms without an explicit
location, it assumes for all uniforms with an explicit location all their
array elements and structure members are used and the linker will not
generate a conflicting location, even if that element or member is deemed
unused.

ifdef::GLSL[]
When generating SPIR-V for API's that accept individual (default block)
non-opaque uniform variables, it is a compile-time error to not
include a location when declaring them.
endif::GLSL[]

When targeting Vulkan, the *push_constant* qualifier is used to
declare an entire block, and represents a set of _push constants_, as defined
by the Vulkan API.
It is {compiletimeerror} to apply this to anything other than a uniform block
declaration, or when not targeting Vulkan.
The values in the block will be initialized as per the Vulkan API specification.
A block declared with `layout(push_constant)` may optionally include an
_instance-name_.
There can be only one *push_constant* block per stage, or a compile-time or
link-time error will result.
A push-constant array can only be indexed with dynamically uniform indices.
Uniform blocks declared with *push_constant* use different resources
than those without; and are accounted for separately.

ifdef::GLSL[]
[[subroutine-function-layout-qualifiers]]
=== Subroutine Function Layout Qualifiers

Layout qualifiers can be used for subroutine functions.
The layout qualifier identifiers for subroutine functions are:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *index* *=* _layout-qualifier-value_
--

Each subroutine with an index qualifier in the shader must be given a unique
index, otherwise a compile- or link-time error will be generated.
The indices must be in the range of 0 to the implementation defined maximum
number of subroutines minus one.
It is recommended, but not required, that the shader assigns a range of
tightly packed _index_ values starting from zero so that the {apiname}
subroutine function enumeration API returns a non-empty name for all active
indices.
endif::GLSL[]


[[uniform-and-shader-storage-block-layout-qualifiers]]
=== Uniform and Shader Storage Block Layout Qualifiers

Layout qualifiers can be used for uniform and shader storage blocks, but not
for non-block uniform declarations.
The layout qualifier identifiers (and *shared* keyword) for uniform and
shader storage blocks are:

ifdef::GLSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *shared* +
    *packed* +
    *std140* +
    *std430* +
    *row_major* +
    *column_major* +
    *binding* *=* _layout-qualifier-value_ +
    *offset* *=* _layout-qualifier-value_ +
    *align* *=* _layout-qualifier-value_
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *shared* +
    *packed* +
    *std140* +
    *std430* +
    *row_major* +
    *column_major* +
    *binding* *=* _layout-qualifier-value_ +
    *offset* *=* _layout-qualifier-value_   // Vulkan only +
    *align* *=* _layout-qualifier-value_    // Vulkan only
--
endif::ESSL[]

None of these have any semantic effect at all on the usage of the variables
being declared; they only describe how data is laid out in memory.
For example, matrix semantics are always column-based, as described in the
rest of this specification, no matter what layout qualifiers are being used.

Uniform and shader storage block layout qualifiers can be declared for
global scope, on a single uniform or shader storage block, or on a single
block member declaration.

Default layouts are established at global scope for uniform blocks as:

[source,glsl]
----
layout(layout-qualifier-id-list) uniform;
----

and for shader storage blocks as:

[source,glsl]
----
layout(layout-qualifier-id-list) buffer;
----

When this is done, the previous default qualification is first inherited and
then overridden as per the override rules listed below for each qualifier
listed in the declaration.
The result becomes the new default qualification scoped to subsequent
uniform or shader storage block definitions.

The initial state of compilation when generating SPIR-V is as if the
following were declared:

[source,glsl]
----
layout(std140, column_major) uniform;
layout(std430, column_major) buffer;
----

However, when *push_constant* is declared, the default layout of the
buffer will be *std430*. There is no method to globally set this default.

The initial state of compilation when not generating SPIR-V is as if the
following were declared:

[source,glsl]
----
layout(shared, column_major) uniform;
layout(shared, column_major) buffer;
----

Uniform and shader storage blocks can be declared with optional layout
qualifiers, and so can their individual member declarations.
Such block layout qualification is scoped only to the content of the block.
As with global layout declarations, block layout qualification first
inherits from the current default qualification and then overrides it.
Similarly, individual member layout qualification is scoped just to the
member declaration, and inherits from and overrides the block's
qualification.

The *shared* qualifier overrides only the *std140*, *std430*, and *packed*
qualifiers; other qualifiers are inherited.
The compiler/linker will ensure that multiple programs and programmable
stages containing this definition will share the same memory layout for this
ifdef::GLSL[]
block, as long as all arrays are declared with explicit sizes and all
matrices have matching *row_major* and/or *column_major* qualifications
(which may come from a declaration outside the block definition).
endif::GLSL[]
ifdef::ESSL[]
block, as long as they also matched in their *row_major* and/or
*column_major* qualifications.
endif::ESSL[]
This allows use of the same buffer to back the same block definition across
different programs.
It is a compile-time error to use the *shared* qualifier when generating
SPIR-V.

The *packed* qualifier overrides only *std140*, *std430*, and *shared*;
other qualifiers are inherited.
When *packed* is used, no shareable layout is guaranteed.
The compiler and linker can optimize memory use based on what variables
actively get used and on other criteria.
Offsets must be queried, as there is no other way of guaranteeing where (and
which) variables reside within the block.

It is a link-time error to access the same packed uniform or shader storage
block in multiple stages within a program.
Attempts to access the same packed uniform or shader storage block across
programs can result in conflicting member offsets and in undefined values
being read.
However, implementations may aid application management of packed blocks by
using canonical layouts for packed blocks.
It is a compile-time error to use the *packed* qualifier when generating
SPIR-V.

The *std140* and *std430* qualifiers override only the *packed*, *shared*,
*std140*, and *std430* qualifiers; other qualifiers are inherited.
The *std430* qualifier is supported only for shader storage blocks; a shader
using the *std430* qualifier on a uniform block will result in
{compiletimeerror}, unless it is also declared with *push_constant*.

The layout is explicitly determined by this, as described in section 7.6.2.2
"`Standard Uniform Block Layout`" of the <<references,{apispec}>>.
Hence, as in *shared* above, the resulting layout is shareable across
programs.

Layout qualifiers on member declarations cannot use the *shared*, *packed*,
*std140*, or *std430* qualifiers.
These can only be used at global scope (without an object) or on a block
declaration, or {compiletimeerror} results.

The *row_major* and *column_major* qualifiers only affect the layout of
matrices, including all matrices contained in structures and arrays they are
applied to, to all depths of nesting.
These qualifiers can be applied to other types, but will have no effect.

The *row_major* qualifier overrides only the *column_major* qualifier; other
qualifiers are inherited.
Elements within a matrix row will be contiguous in memory.

The *column_major* qualifier overrides only the *row_major* qualifier; other
qualifiers are inherited.
Elements within a matrix column will be contiguous in memory.

The *binding* qualifier specifies the uniform buffer binding point
corresponding to the uniform or shader storage block, which will be used to
obtain the values of the member variables of the block.
It is a compile-time error to specify the *binding* qualifier for the global
scope or for block member declarations.
Any uniform or shader storage block declared without a *binding* qualifier
is initially assigned to block binding point zero.
After a program is linked, the binding points used for uniform
ifdef::GLSL[and shader storage blocks]
ifdef::ESSL[(but not shader storage) blocks]
declared with or without a *binding* qualifier can be updated
by the API.

When used with {apiname},
if the *binding* qualifier is used with a uniform block or shader storage
block instanced as an array, the first element of the array takes the
specified block binding and each subsequent element takes the next
consecutive binding point.
For an array of arrays, each element (e.g. 6 elements for a[2][3]) gets a
binding point, and they are ordered per the array of array ordering
described in "`<<arrays, Arrays.>>`"

When targeting Vulkan,
if the *binding* qualifier is used with a uniform block or buffer block
instanced as an array, the entire array takes only the provided binding
number.
The next consecutive binding number is available for a different
object.
For an array of arrays, descriptor set array element numbers used
in descriptor set accesses are ordered per the array-of-array ordering
described in "`<<arrays,Arrays.>>`"

If the binding point for any uniform or shader storage block instance is
less than zero, or greater than or equal to the corresponding
implementation-dependent maximum number of buffer bindings, a compile-time
error will occur.
When the *binding* qualifier is used with a uniform or shader storage block
instanced as an array of size _N_, all elements of the array from *binding*
through _binding + N - 1_ must be within this range.
ifdef::GLSL[]
It is a compile-time or link-time error to use the same binding number for
more than one uniform block or for more than one buffer block.
endif::GLSL[]

The *set* qualifier is only available when targeting Vulkan.
It specifies the descriptor set this object belongs to.
It is {compiletimeerror} to apply *set* to a standalone qualifier, to
a member of a block, or when not targeting an API that supports descriptor sets.
It is {compiletimeerror} to apply *set* to a block qualified as *push_constant*.
By default, any non-push-constant uniform or shader storage block declared
without a *set* identifier is assigned to descriptor set 0.
Similarly, any sampler, texture, or subpass-input type declared as a uniform
without a *set* identifier is also assigned to descriptor set 0.

If applied to an object declared as an array, all elements of the array
belong to the specified *set*.

When generating SPIR-V, it is {compiletimeerror} for either the *set* or
*binding* value to exceed a front-end-configuration supplied maximum value.

When multiple arguments are listed in a *layout* declaration, the effect
will be the same as if they were declared one at a time, in order from left
to right, each in turn inheriting from and overriding the result from the
previous qualification.

For example

[source,glsl]
----
layout(row_major, column_major)
----

results in the qualification being *column_major*.
Other examples:

[source,glsl]
----
layout(shared, row_major) uniform; // default is now shared and row_major

layout(std140) uniform Transform { // layout of this block is std140
    mat4 M1;                       // row major
    layout(column_major) mat4 M2;  // column major
    mat3 N1;                       // row major
};

uniform T2 {                       // layout of this block is shared
    ...
};

layout(column_major) uniform T3 {  // shared and column major
    mat4 M3;                       // column major
    layout(row_major) mat4 m4;     // row major
    mat3 N2;                       // column major
};
----

When targeting Vulkan, the *offset* and *align* qualifiers for blocks and
block members can only be used with *uniform* and *buffer* blocks.
ifdef::GLSL[]
When not targeting Vulkan, they can only be used with blocks declared with
*std140* or *std430* layouts.
endif::GLSL[]
ifdef::ESSL[]
When not targeting Vulkan, they cannot be used with blocks or block members.
endif::ESSL[]

The *offset* qualifier can only be used on block members.
The *offset* qualifier forces the qualified member to start at or after the
specified _layout-qualifier-value_, which will be its byte offset from
the beginning of the buffer.
It is a compile-time error to have any offset, explicit or assigned, that
lies within another member of the block.
ifdef::GLSL[]
When not generating SPIR-V, it is a compile-time error to specify an offset
that is smaller than the offset of the previous member in the block.
endif::GLSL[]
Two blocks linked together in the same program with the same block name must
have the exact same set of members qualified with *offset* and their
_layout-qualifier-value_ values must be the same, or a link-time error
results.
The specified offset must be a multiple of the base alignment of the type of
the block member it qualifies, or a compile-time error results.

The *align* qualifier makes the start of each block member have a minimum
byte alignment.
It does not affect the internal layout within each member, which will still
follow the *std140* or *std430* rules.
The specified alignment must be greater than 0 and a power of 2, or a
compile-time error results.

The _actual alignment_ of a member will be the greater of the specified
*align* alignment and the standard (e.g. *std140*) base alignment for the
member's type.
The _actual offset_ of a member is computed as follows: If *offset* was
declared, start with that offset, otherwise start with the offset immediately
following the preceding member (in declaration order).
If the resulting offset is not a multiple of the _actual alignment_,
increase it to the first offset that is a multiple of the _actual
alignment_.
This results in the _actual offset_ the member will have.

When *align* is applied to an array, it affects only the start of the array,
not the array's internal stride.
Both an *offset* and an *align* qualifier can be specified on a declaration.

The *align* qualifier, when used on a block, has the same effect as
qualifying each member with the same *align* value as declared on the block,
and gets the same compile-time results and errors as if this had been done.
As described in general earlier, an individual member can specify its own
*align*, which overrides the block-level *align*, but just for that member.

Examples:

[source,glsl]
----
layout(std140) uniform block {
 vec4 a;                         // a takes offsets 0-15
 layout(offset = 32) vec3 b;     // b takes offsets 32-43
 layout(offset = 40) vec2 c;     // ERROR, lies within previous member
 layout(offset = 48) vec2 d;     // d takes offsets 48-55
 layout(align = 16) float e;     // e takes offsets 64-67
 layout(align = 2) double f;     // f takes offsets 72-79
 layout(align = 6) double g;     // ERROR, 6 is not a power of 2
 layout(offset = 80) float h;    // h takes offsets 80-83
 layout(align = 64) dvec3 i;     // i takes offsets 128-151
 layout(offset = 164, align = 8)
 float j;                        // j takes offsets 168-171
};
----


[[opaque-uniform-layout-qualifiers]]
=== Opaque Uniform Layout Qualifiers

Opaque uniform variables can take the uniform layout qualifier for binding:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *binding* *=* _layout-qualifier-value_
--

The *binding* qualifier specifies the point where the variable will be bound.
Any opaque variable declared without a binding qualifier has a default binding
of zero.

When used with {apiname},
if the *binding* qualifier is used with an array, the first element of the
array takes the specified binding point and each subsequent element takes the
next consecutive binding point.
For an array of arrays, each element (e.g. 6 elements for a[2][3]) gets a
binding point, and they are ordered per the array of array ordering
described in "`<<arrays, Arrays.>>`"

When targeting Vulkan,
if the *binding* qualifier is used with an array, the entire array
takes only the provided binding number. The next consecutive binding
number is available for a different object.

If the *binding* is less than zero, or greater than or equal to the
implementation-dependent maximum supported number of binding points,
a compile-time error will occur.
When the *binding* qualifier is used with an array of size _N_, all elements
of the array from *binding* through _binding + N - 1_ must be within this
range.
ifdef::GLSL[]
It is a compile-time or link-time error to use the same *binding* number for
more than one atomic counter, unless the _offset_ for the atomic counters
sharing the same binding are all different.
endif::GLSL[]

A link-time error will result if two shaders in a program specify different
_layout-qualifier-value_ bindings for the same opaque-uniform name.
However, it is not an error to specify a binding on some but not all
declarations for the same name, as shown in the examples below.

[source,glsl]
----
// in one shader...
layout(binding=3) uniform sampler2D s; // s bound to point 3

// in another shader...
uniform sampler2D s;                   // okay, s still bound at 3

// in another shader...
layout(binding=4) uniform sampler2D s; // ERROR: contradictory bindings
----


[[atomic-counter-layout-qualifiers]]
=== Atomic Counter Layout Qualifiers

Atomic counters are not available when targeting Vulkan.

Atomic counter layout qualifiers can be used on atomic counter declarations or
at global scope to establish defaults.
The atomic counter qualifiers are:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *binding* *=* _layout-qualifier-value_ +
    *offset* *=* _layout-qualifier-value_
--

Each binding has a default offset that is initially 0 and is updated following
each declaration containing the type *atomic_uint*. If such a declaration does
not declare a variable then it establishes a default for the named binding. It
is a compile-time error if any such declaration does not include a _binding_
layout qualifier.

If a declaration contains an _offset_ qualifier then that offset is used in the
declaration, otherwise the default offset for the named binding is used. Each
atomic counter that is declared is assigned to the named buffer binding point,
at the current offset, and then the offset is increased by 4. Arrays of atomic
counters assign one such offset to each member, and if multiple variables are
declared in the same statement then they will have offsets assigned in order
from left to right. Having assigned offsets to variables, if any, the
binding's default offset will be set to the current offset value.

For example,

[source,glsl]
----
layout(binding = 2, offset = 4) uniform atomic_uint a;
----

will establish that the opaque handle to the atomic counter _a_ will be
bound to atomic counter buffer binding point 2 at an offset of 4 basic
machine units into that buffer.
The default _offset_ for binding point 2 will be post incremented by 4 (the
size of an atomic counter).

It is a compile-time error to bind an atomic counter with a binding value
greater than or equal to _gl_MaxAtomicCounterBindings_.
It is a compile-time error to declare an atomic counter whose offset is such
that the buffer containing it would be larger than _gl_MaxAtomicCounterBufferSize_.
It is a compile-time error to declare an atomic counter whose offset is not
aligned to a multiple of 4.
ifdef::GLSL[]
It is a compile-time error to declare an unsized array of *atomic_uint*.
endif::GLSL[]
It is a compile- or link-time error to declare two atomic counters with the same
binding and the same offset.

Examples of atomic declarations:

[source,glsl]
----
layout(binding = 2, offset = 4)  uniform atomic_uint;      // Sets binding's default
                                                           // offset = 4
layout(binding = 2)              uniform atomic_uint a;    // offset 4
layout(binding = 2)              uniform atomic_uint b;    // offset 8
layout(binding = 3)              uniform atomic_uint c[2]; // offsets 0, 4
layout(binding = 2)              uniform atomic_uint d;    // offset 12
layout(binding = 4, offset = 16) uniform atomic_uint e;    // offset 16
layout(binding = 4)              uniform atomic_uint f;    // offset 20

layout(offset = 8)              uniform atomic_uint ea;  // error, no binding
                                                         // specified
layout(binding = 2, offset = 6) uniform atomic_uint eb;  // error, offset not aligned
layout(binding = 3, offset = 4) uniform atomic_uint ec;  // error, overlaps c[1]
layout(binding = 3, offset = 4) uniform atomic_uint;     // OK, no counter declared
layout(binding = 3)             uniform atomic_uint ed;  // error, overlaps c[1]
----


[[format-layout-qualifiers]]
=== Format Layout Qualifiers

Format layout qualifiers can be used on image variable declarations (those
declared with a basic type having "`*image*`" in its keyword).
The format layout qualifier identifiers for image variable declarations are:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    _float-image-format-qualifier_ +
    _int-image-format-qualifier_ +
    _uint-image-format-qualifier_ +
    *binding* *=* _layout-qualifier-value_
--

ifdef::GLSL[]
[role="bnf"]
--
_float-image-format-qualifier_ : ::
    *rgba32f* +
    *rgba16f* +
    *rg32f* +
    *rg16f* +
    *r11f_g11f_b10f* +
    *r32f* +
    *r16f* +
    *rgba16* +
    *rgb10_a2* +
    *rgba8* +
    *rg16* +
    *rg8* +
    *r16* +
    *r8* +
    *rgba16_snorm* +
    *rgba8_snorm* +
    *rg16_snorm* +
    *rg8_snorm* +
    *r16_snorm* +
    *r8_snorm*

_int-image-format-qualifier_ : ::
    *rgba32i* +
    *rgba16i* +
    *rgba8i* +
    *rg32i* +
    *rg16i* +
    *rg8i* +
    *r32i* +
    *r16i* +
    *r8i*

_uint-image-format-qualifier_ : ::
    *rgba32ui* +
    *rgba16ui* +
    *rgb10_a2ui* +
    *rgba8ui* +
    *rg32ui* +
    *rg16ui* +
    *rg8ui* +
    *r32ui* +
    *r16ui* +
    *r8ui*
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_float-image-format-qualifier_ : ::
    *rgba32f* +
    *rgba16f* +
    *r32f* +
    *rgba8* +
    *rgba8_snorm*

_int-image-format-qualifier_ : ::
    *rgba32i* +
    *rgba16i* +
    *rgba8i* +
    *r32i*

_uint-image-format-qualifier_ : ::
    *rgba32ui* +
    *rgba16ui* +
    *rgba8ui* +
    *r32ui*
--
endif::ESSL[]

A format layout qualifier specifies the image format associated with a
declared image variable.
Only one format qualifier may be specified for any image variable
declaration.
For image variables with floating-point component types (keywords starting
with "`*image*`"), signed integer component types (keywords starting with
"`*iimage*`"), or unsigned integer component types (keywords starting with
"`*uimage*`"), the format qualifier used must match the
_float-image-format-qualifier_, _int-image-format-qualifier_, or
_uint-image-format-qualifier_ grammar rules, respectively.
It is {compiletimeerror} to declare an image variable where the format
qualifier does not match the image variable type.

ifdef::GLSL[]
Any image variable used for image loads or atomic operations must specify a
format layout qualifier; it is a compile-time error to pass an image uniform
variable or function parameter declared without a format layout qualifier to
an image load or atomic function.

Uniforms not qualified with *writeonly* must have a format layout qualifier.
Note that an image variable passed to a function for read access cannot be
declared as *writeonly* and hence must have been declared with a format
layout qualifier.
endif::GLSL[]
ifdef::ESSL[]
Any image variable must specify a format layout qualifier.
endif::ESSL[]

The *binding* qualifier was described in
"`<<opaque-uniform-layout-qualifiers,Opaque Uniform Layout Qualifiers>>`".

=== Subpass Input Qualifier

Subpass inputs are only available when targeting Vulkan.

Subpass inputs are declared with the basic *subpassInput* types.
They must be declared with the layout qualifier
*input_attachment_index*, or {compiletimeerror} results.
For example:

[source,glsl]
----
layout(input_attachment_index = 2) uniform subpassInput t;
----

This selects which subpass input is being read from. The value assigned
to *input_attachment_index*, say _i_ (`input_attachment_index = i`), selects
that entry (_i_ th entry) in the input list for the pass.  See the API
documentation for more detail about passes and the input list.

If an array of size _N_ is declared, it consumes _N_ consecutive
*input_attachment_index* values, starting with the one provided.

It is a compile-time or link-time error to have different variables
declared with the same *input_attachment_index*.
This includes any overlap in the implicit *input_attachment_index* consumed by
array declarations.

It is {compiletimeerror} if the value assigned to an *input_attachment_index*
is greater than or equal to _gl_MaxInputAttachments_.

[[interpolation-qualifiers]]
== Interpolation Qualifiers

Inputs and outputs that could be interpolated can be further qualified by at
most one of the following interpolation qualifiers:

[options="header"]
|====
| Qualifier       | Meaning
| *smooth*        | perspective correct interpolation
| *flat*          | no interpolation
ifdef::GLSL[]
| *noperspective* | linear interpolation
endif::GLSL[]
|====

The presence of and type of interpolation is controlled by the above
interpolation qualifiers as well as the auxiliary storage qualifiers
*centroid* and *sample*.
When no interpolation qualifier is present, smooth interpolation is used.
It is a compile-time error to use more than one interpolation qualifier.
The auxiliary storage qualifier *patch* is not used for interpolation; it is
a compile-time error to use interpolation qualifiers with *patch*.

A variable qualified as *flat* will not be interpolated.
Instead, it will have the same value for every fragment within a primitive.
This value will come from a single provoking vertex, as described by the
<<references, API>>.
A variable qualified as *flat* may also be qualified as *centroid* or
*sample*, which will mean the same thing as qualifying it only as *flat*.

A variable qualified as *smooth* will be interpolated in a
perspective-correct manner over the primitive being rendered.
ifdef::GLSL[]
Interpolation in a perspective correct manner is specified in equation 14.7
of the <<references,{apispec}>>, section 14.5 "`Line Segments`".

A variable qualified as *noperspective* must be interpolated linearly in
screen space, as described in equation 3.7 of the <<references,{apispec}>>,
section 3.5 "`Line Segments`".
endif::GLSL[]
ifdef::ESSL[]
Interpolation in a perspective correct manner is specified in equations 13.4
of the <<references,{apispec}>>, section 13.4.1 "`Line Segments`" and
equation 13.7, section 13.5.1 "`Polygon Interpolation`".
endif::ESSL[]

When multisample rasterization is disabled, or for fragment shader input
variables qualified with neither *centroid* nor *sample*, the value of the
assigned variable may be interpolated anywhere within the pixel and a single
value may be assigned to each sample within the pixel, to the extent
permitted by the <<references,{apispec}>>.

When multisample rasterization is enabled, *centroid* and *sample* may be
used to control the location and frequency of the sampling of the qualified
fragment shader input.
If a fragment shader input is qualified with *centroid*, a single value may
be assigned to that variable for all samples in the pixel, but that value
must be interpolated at a location that lies in both the pixel and in the
primitive being rendered, including any of the pixel's samples covered by
the primitive.
Because the location at which the variable is interpolated may be different
in neighboring pixels, and derivatives may be computed by computing
differences between neighboring pixels, derivatives of centroid-sampled
inputs may be less accurate than those for non-centroid interpolated
variables.
If a fragment shader input is qualified with *sample*, a separate value must
be assigned to that variable for each covered sample in the pixel, and that
value must be sampled at the location of the individual sample.

ifdef::GLSL[]
It is a link-time error if, within the same stage, the interpolation
qualifiers of variables of the same name do not match.


[[redeclaring-built-in-interpolation-variables-in-the-compatibility-profile]]
=== Redeclaring Built-In Interpolation Variables in the Compatibility Profile

The following predeclared variables can be redeclared with an interpolation
qualifier when using the compatibility profile:

Vertex, tessellation control, tessellation evaluation, and geometry
languages:

[source,glsl]
----
gl_FrontColor
gl_BackColor
gl_FrontSecondaryColor
gl_BackSecondaryColor
----

Fragment language:

[source,glsl]
----
gl_Color
gl_SecondaryColor
----

For example,

[source,glsl]
----
in vec4 gl_Color;            // predeclared by the fragment language
flat in vec4 gl_Color;       // redeclared by user to be flat
flat in vec4 gl_FrontColor;  // input to geometry shader, no "gl_in[]"
flat out vec4 gl_FrontColor; // output from geometry shader
----

Ideally, these are redeclared as part of the redeclaration of an interface
block, as described in
"`<<compatibility-profile-built-in-language-variables,Compatibility Profile
Built-In Language Variables>>`".
However, for the above purpose, they can be redeclared as individual
variables at global scope, outside an interface block.
Such redeclarations also allow adding the transform-feedback qualifiers
*xfb_buffer*, *xfb_stride*, and *xfb_offset* to output variables.
(Using *xfb_buffer* on a variable does not change the global default
buffer.) A compile-time error will result if a shader has both an interface
block redeclaration and a separate redeclaration of a member of that
interface block outside the interface block redeclaration.

If _gl_Color_ is redeclared with an interpolation qualifier, then
_gl_FrontColor_ and _gl_BackColor_ (if they are written to) must also be
redeclared with the same interpolation qualifier, and vice versa.
If _gl_SecondaryColor_ is redeclared with an interpolation qualifier, then
_gl_FrontSecondaryColor_ and _gl_BackSecondaryColor _(if they are written
to) must also be redeclared with the same interpolation qualifier, and vice
versa.
This qualifier matching on predeclared variables is only required for
variables that are statically used within the shaders in a program.
endif::GLSL[]


[[parameter-qualifiers]]
== Parameter Qualifiers

In addition to precision qualifiers and memory qualifiers, parameters can
have these parameter qualifiers.

[options="header"]
|====
| Qualifier      | Meaning
|<none: default> | same as *in*
ifdef::GLSL[]
| *const*        | for function parameters that cannot be written to
endif::GLSL[]
| *in*           | for function parameters passed into a function
| *out*          | for function parameters passed back out of a function,
                   but not initialized for use when passed in
| *inout*        | for function parameters passed both into and out of a
                   function
|====

Parameter qualifiers are discussed in more detail in
"`<<function-calling-conventions,Function Calling Conventions>>`".


[[precision-and-precision-qualifiers]]
== Precision and Precision Qualifiers

ifdef::GLSL[]
When not targeting Vulkan:
Precision qualifiers are added for code portability with OpenGL ES, not for
functionality.
They have the same syntax as in OpenGL ES, as described below, but they have
no semantic meaning, which includes no effect on the precision used to store
or operate on variables.
If an extension adds in the same semantics and functionality in the OpenGL
ES 2.0 specification for precision qualifiers, then the extension is allowed
to reuse the keywords below for that purpose.
endif::GLSL[]

When targeting Vulkan:
For interface matching, uniform variables and uniform and buffer block
members must have the same precision qualification.
Global variables declared in different compilation units linked into the
same shader stage must be declared with the same precision qualification.

For the purposes of determining if an output from one shader stage matches
an input of the next stage, the precision qualifier need not match.

This specification only governs the minimum required precision for storage and
operations on values.
Implementations are free to calculate and/or store any results at higher
precisions.
If necessary, this variance can be controlled using the invariance qualifier.

[[range-and-precision]]
=== Range and Precision

The precision of *highp*
ifdef::GLSL[single- and double-precision]
floating-point variables is defined by the IEEE 754 standard for
32-bit
ifdef::GLSL[and 64-bit]
floating-point numbers.

This includes support for NaNs (Not a Number) and Infs (positive or negative
infinities) and positive and negative zeros.

The following rules apply to *highp*
ifdef::GLSL[for both single and double-precision]
operations:
Signed infinities and zeros are generated as dictated by IEEE, but subject
to the precisions allowed in the following table.
Any subnormal (denormalized) value input into a shader or potentially
generated by any operation in a shader can be flushed to 0.
The rounding mode cannot be set and is undefined but must not affect the
result by more than 1 ULP.
NaNs are not required to be generated.
Support for signaling NaNs is not required and exceptions are never raised.
Operations including built-in functions that operate on a NaN are not
required to return a NaN as the result.
However if NaNs are generated, *isnan*() must return the correct value.

Precisions are expressed in terms of maximum relative error in units of ULP
(units in the last place), unless otherwise noted.

For single precision operations, precisions are required as follows:

[options="header"]
|====
| Operation                       | Precision
| _a_ + _b_, _a_ - _b_, _a_ * _b_ | Correctly rounded.
| <, \<=, ==, >, >=               | Correct result.
| _a_ / _b_, 1.0 / _b_            | 2.5 ULP for [eq]#{vbar}b{vbar}# in the range [eq]#[2^-126^, 2^126^]#.
| _a_ * _b_ + _c_                 | Correctly rounded single operation or
                                    sequence of two correctly rounded operations.
| *fma*()                         | Inherited from _a_ * _b_ + _c_.
| *pow*(_x_, _y_)                 | Inherited from *exp2*(_y_ * *log2*(_x_)).
| *exp*(_x_), *exp2*(_x_)         | [eq]#(3 + 2 {cdot} {vert}x{vert})# ULP.
| *log*(), *log2*()               | 3 ULP outside the range [eq]#[0.5,2.0]#. +
                                    Absolute error < 2^-21^ inside the range
                                    [eq]#[0.5,2.0]#.
| *sqrt*()                        | Inherited from 1.0 / *inversesqrt*().
| *inversesqrt*()                 | 2 ULP.
| implicit and explicit
  conversions between types       | Correctly rounded.
|====

Built-in functions defined in the specification with an equation built from
the above operations inherit the above errors.
These include, for example, the geometric functions, the common functions,
and many of the matrix functions.
Built-in functions not listed above and not defined as equations of the
above have undefined precision.
These include, for example, the trigonometric functions and determinant.

ifdef::GLSL[]
The precision of double-precision operations is at least that of single
precision.
endif::GLSL[]
ifdef::ESSL[]
Storage requirements are declared through use of _precision qualifiers_.
The precision of operations must preserve the storage precisions of the
variables involved.

*highp* floating-point values are stored in IEEE 754 single precision
floating-point format.
*mediump* and *lowp* floating-point values have minimum range and precision
requirements as detailed below and have maximum range and precision as
defined by IEEE 754.

All integral types are assumed to be implemented as integers and so may not
be emulated by floating-point values.
*highp* signed integers are represented as twos-complement 32-bit signed
integers.
*highp* unsigned integers are represented as unsigned 32-bit integers.
*mediump* integers (signed and unsigned) must be represented as an integer
with between 16 and 32 bits inclusive.
*lowp* integers (signed and unsigned) must be represented as an integer with
between 9 and 32 bits inclusive.

The required ranges and precisions for precision qualifiers are:

[options="header"]
|====
| Qualifier | Floating-Point Range | Floating-Point Magnitude Range | Floating-Point Precision | Signed Integer Range | Unsigned Integer Range
| *highp*
    | Subset of IEEE-754 +
      [eq]#(-2^128^,2^128^)#
    | Subset of IEEE-754 +
      0.0, [eq]#[2^-126^,2^128^)#
    | Subset of IEEE-754 relative: +
      [eq]#2^-23^#
    | [eq]#[-2^31^,2^31^-1]#
    | [eq]#[0,2^32^-1]#
| *mediump* (minimum requirements)
    | [eq]#(-2^14^,2^14^)#
    | 0.0, [eq]#[2^-14^,2^14^)#
    | Relative: +
      [eq]#2^-10^#
    | [eq]#[-2^15^,2^15^-1]#
    | [eq]#[0,2^16^-1]#
| *lowp* (minimum requirements)
    | [eq]#(-2,2)#
    | [eq]#(2^-8^,2)#
    | Absolute: +
      [eq]#2^-8^#
    | [eq]#[-2^8^,2^8^-1]#
    | [eq]#[0,2^9^-1]#
|====

The semi-open interval notation used for the magnitude ranges means that the
lower end of the interval is included, but the upper end is excluded. Thus the
largest required magnitude is half of the relative precision less than the
value given. The largest required value for highp, for example, is [eq]#2^128^
{times} (1 - 2^-24^)#.

_Relative precision_ is defined as the worst case (i.e. largest) ratio of
the smallest step in relation to the value for all non-zero values in the
required ranges, above:

[latexmath]
++++
\begin{aligned}
    \mathit{Precision}_{relative} = {
        \left| {
            { \left| v_1 - v_2 \right| }_{min} } \over { v_1 }
        \right|
    }_{max}, &
    v_1,v_2 \neq 0, v_1 \neq v_2
\end{aligned}
++++

It is therefore twice the maximum rounding error when converting from a real
number.
Subnormal numbers may be supported and may have lower relative precision.

In addition, the range and precision of a *mediump* floating-point value
must be the same as or greater than the range and precision of a *lowp*
floating-point value.
The range and precision of a *highp* floating-point value must be the same
as or greater than the range and precision of a *mediump* floating-point
value.

The range of a *mediump* integer value must be the same as or greater than
the range of a *lowp* integer value.
The range of a *highp* integer value must be the same as or greater than the
range of a *mediump* integer value.

The actual ranges and precisions provided by an implementation can be
queried through the API.
See the <<references, normative references>> for details on how to do
this.
endif::ESSL[]


[[conversion-between-precisions]]
=== Conversion between precisions

Within the same type, conversion from a lower to a higher precision must be
exact.
When converting from a higher precision to a lower precision, if the value
is representable by the implementation of the target precision, the
conversion must also be exact.
If the value is not representable, the behavior is dependent on the type:

  * For signed and unsigned integers, the value is truncated; bits in
    positions not present in the target precision are set to zero.
    (Positions start at zero and the least significant bit is considered to
    be position zero for this purpose.)
  * For floating-point values, the value should either clamp to +Inf or
    -Inf, or to the maximum or minimum value that the implementation
    supports.
    While this behavior is implementation-dependent, it should be consistent
    for a given implementation.


[[precision-qualifiers]]
=== Precision Qualifiers

Any
ifdef::GLSL[single-precision]
floating-point, integer, or opaque-type declaration can have the type
preceded by one of these precision qualifiers:

ifdef::GLSL[]
[options="header"]
|====
| Qualifier | Meaning
| *highp*   | 32-bit two's complement for integers,
              32-bit IEEE 754 floating-point for *float*
| *mediump* | SPIR-V *RelaxedPrecision* when targeting Vulkan, otherwise none.
| *lowp*    | SPIR-V *RelaxedPrecision* when targeting Vulkan, otherwise none.
|====
endif::GLSL[]
ifdef::ESSL[]
[cols="",]
|====
| Qualifier | Meaning
| *highp*   | The variable satisfies the minimum requirements for *highp*
              described above. *highp* variables have the maximum range and
              precision available but may cause operations to run more
              slowly on some implementations.
| *mediump* | SPIR-V *RelaxedPrecision* when targeting Vulkan, otherwise
              the variable satisfies the minimum requirements for *mediump*
              described above. *mediump* variables may typically be used to
              store high dynamic range colors and low precision geometry.
| *lowp*    | SPIR-V *RelaxedPrecision* when targeting Vulkan, otherwise
              the variable satisfies the minimum requirements for *lowp*
              described above. *lowp* variables may typically be used to
              store 8-bit color values.
|====
endif::ESSL[]

For example:

[source,glsl]
----
lowp float color;
out mediump vec2 P;
lowp ivec2 foo(lowp mat3);
highp mat4 m;
----

Literal constants do not have precision qualifiers.
Neither do Boolean variables.

For this paragraph, "`operation`" includes operators, built-in functions,
and constructors, and "`operand`" includes function arguments and
constructor arguments.
The precision qualification associated with any operation is the highest
precision qualification of the operands consumed by the operation, if any
operand has an associated precision.
In cases where no operand has a precision qualifier, the precision
qualifications of the operands of the next consuming operation in the
expression will be used.
This rule can be applied recursively until a precision qualified operand is
found.
If necessary, it will also include the precision qualification of l-values
for assignments, of the declared variable for initializers, of formal
parameters for function call arguments, or of function return types for
function return values.
If the precision cannot be determined by this method e.g. if an entire
expression is composed only of operands with no precision qualifier, and the
result is not assigned or passed as an argument, then it is evaluated at the
default precision of the type or greater.
When this occurs in the fragment shader, the default precision must be
defined.

For example, consider the statements:

[source,glsl]
----
uniform highp float h1;
highp float h2 = 2.3 * 4.7; // operation and result are highp
precision
mediump float m;
m = 3.7 * h1 * h2; // all operations are highp precision
h2 = m * h1; // operation is highp precision
m = h2 - h1; // operation is highp precision
h2 = m + m; // addition and result at mediump precision
void f(highp float p);
f(3.3); // 3.3 will be passed in at highp precision
----

Precision qualifiers, as with other qualifiers, do not affect the basic type
of the variable.
In particular, there are no constructors for precision conversions;
constructors only convert types.
Similarly, precision qualifiers, as with other qualifiers, do not contribute
to function overloading based on parameter types.
As discussed in "`<<function-calling-conventions,Function Calling
Conventions>>`", function input and output is done through copies, and
therefore qualifiers do not have to match.

ifdef::ESSL[]
Precision qualifiers for outputs in one shader matched to inputs in another
shader need not match when both shaders are linked into the same program.
When both shaders are in separate programs, mismatched precision qualifiers
will result in a program interface mismatch that will result in program
pipeline validation failures, as described in section 7.4.1 "`Shader
Interface Matching`" of the <<references,{apispec}>>.
endif::ESSL[]

The precision of a variable is determined when the variable is declared and
cannot be subsequently changed.

Where the precision of a constant integral or constant floating-point
expression is not specified, evaluation is performed at *highp*.
This rule does not affect the precision qualification of the expression.

The evaluation of constant expressions must be invariant and will usually be
performed at compile time.


[[default-precision-qualifiers]]
=== Default Precision Qualifiers

The precision statement

[source,glsl]
----
precision precision-qualifier type;
----

can be used to establish a default precision qualifier.
The _type_ field can be either *int*, *float*, or any of the opaque types,
and the _precision-qualifier_ can be *lowp*, *mediump*, or *highp*.

Any other types or qualifiers will result in {compiletimeerror}.
If _type_ is *float*, the directive applies to non-precision-qualified
ifdef::GLSL[single-precision]
floating-point type (scalar, vector, and matrix) declarations.
If _type_ is *int*, the directive applies to all non-precision-qualified
integer type (scalar, vector, signed, and unsigned) declarations.
This includes global variable declarations, function return declarations,
function parameter declarations, and local variable declarations.

Non-precision qualified declarations will use the precision qualifier
specified in the most recent *precision* statement that is still in scope.
The *precision* statement has the same scoping rules as variable
declarations.
If it is declared inside a compound statement, its effect stops at the end
of the inner-most statement it was declared in.
Precision statements in nested scopes override precision statements in outer
scopes.
Multiple precision statements for the same basic type can appear inside the
same scope, with later statements overriding earlier statements within that
scope.


ifdef::GLSL[]
For any type that accepts a precision qualifier,
the default precision qualification will be *highp*.
Because all types requiring a precision qualifier have a default precision,
there are no errors for omission of a precision qualifier.
endif::GLSL[]
ifdef::ESSL[]
All languages except for the fragment language have the following
predeclared globally scoped default precision statements:

[source,glsl]
----
precision highp float;
precision highp int;
precision lowp sampler2D;
precision lowp samplerCube;
precision highp atomic_uint;
----

The fragment language has the following predeclared globally scoped default
precision statements:

[source,glsl]
----
precision mediump int;
precision lowp sampler2D;
precision lowp samplerCube;
precision highp atomic_uint;
----

The fragment language has no default precision qualifier for floating-point
types.
Hence for *float*, floating-point vector and matrix variable declarations,
either the declaration must include a precision qualifier or the default
float precision must have been previously declared.
Similarly, there is no default precision qualifier in any of the languages
for any type not listed above.
endif::ESSL[]

[[available-precision-qualifiers]]
=== Available Precision Qualifiers

The built-in macro GL_FRAGMENT_PRECISION_HIGH is defined to one:

[source,glsl]
----
#define GL_FRAGMENT_PRECISION_HIGH 1
----

This macro is available in all languages except compute.


[[variance-and-the-invariant-qualifier]]
== Variance and the Invariant Qualifier

In this section, _variance_ refers to the possibility of getting different
values from the same expression in different programs.
For example, consider the situation where two vertex shaders, in different
programs, each set _gl_Position_ with the same expression, and the input
values into that expression are the same when both shaders run.
It is possible, due to independent compilation of the two shaders, that the
values assigned to _gl_Position_ are not exactly the same when the two
shaders run.
In this example, this can cause problems with alignment of geometry in a
multi-pass algorithm.

In general, such variance between shaders is allowed.
When such variance does not exist for a particular output variable, that
variable is said to be _invariant_.


[[the-invariant-qualifier]]
=== The Invariant Qualifier

To ensure that a particular output variable is invariant, it is necessary to
use the *invariant* qualifier.
It can either be used to qualify a previously declared variable as being
invariant:

[source,glsl]
----
invariant gl_Position; // make existing gl_Position be invariant
out vec3 Color;
invariant Color;       // make existing Color be invariant
----

or as part of a declaration when a variable is declared:

[source,glsl]
----
invariant centroid out vec3 Color;
----

Only variables output from a shader can be candidates for invariance.
This includes user-defined output variables and the built-in output
variables.
As only outputs can be declared as invariant, an output from one shader
stage will still match an input of a subsequent stage without the input
being declared as invariant.

ifdef::GLSL[]
Input or output instance names on blocks are not used when redeclaring
built-in variables.
endif::GLSL[]

The *invariant* keyword can be followed by a comma separated list of
previously declared identifiers.
All uses of *invariant* must be at global scope or on block
members, and before any use of the variables being declared as invariant.

To guarantee invariance of a particular output variable across two programs,
the following must also be true:

  * The output variable is declared as invariant in both programs.
  * The same values must be input to all shader input variables consumed by
    expressions and control flow contributing to the value assigned to the
    output variable.
  * The texture formats, texel values, and texture filtering are set the
    same way for any texture function calls contributing to the value of the
    output variable.
  * All input values are all operated on in the same way.
    All operations in the consuming expressions and any intermediate
    expressions must be the same, with the same order of operands and same
    associativity, to give the same order of evaluation.
    Intermediate variables and functions must be declared as the same type
    with the same explicit or implicit precision
ifdef::GLSL[qualifiers.]
ifdef::ESSL[qualifiers and the same constant qualifiers.]
    Any control flow affecting the output value must be the same, and any
    expressions consumed to determine this control flow must also follow
    these invariance rules.
  * All the data flow and control flow leading to setting the invariant
    output variable reside in a single compilation unit.

Essentially, all the data flow and control flow leading to an invariant
output must match.

Initially, by default, all output variables are allowed to be variant.
To force all output variables to be invariant, use the pragma

[source,glsl]
----
#pragma STDGL invariant(all)
----

before all declarations in a shader.
If this pragma is used after the declaration of any variables or functions,
then the set of outputs that behave as invariant is undefined.

Generally, invariance is ensured at the cost of flexibility in optimization,
so performance can be degraded by use of invariance.
Hence, use of this pragma is intended as a debug aid, to avoid individually
declaring all output variables as invariant.


ifdef::ESSL[]
[[invariance-within-a-shader]]
=== Invariance Within a Shader

When a value is stored in a variable, it is usually assumed it will remain
constant unless explicitly changed.
However, during the process of optimization, it is possible that the
compiler may choose to recompute a value rather than store it in a register.
Since the precision of operations is not completely specified (e.g. a low
precision operation may be done at medium or high precision), it would be
possible for the recomputed value to be different from the original value.

Values are allowed to be variant within a shader.
To prevent this, the invariant qualifier or invariant pragma must be used.

Within a shader, there is no invariance for values generated by different
non-constant expressions, even if those expressions are identical.

Example 1:

[source,glsl]
----
precision mediump;
vec4 col;
vec2 a = ...
...
col = texture(tex, a);// a has a value _a1 _
...
col = texture(tex, a); // a has a value a2 where possibly a1 != a2
----

To enforce invariance in this example use:

[source,glsl]
----
#pragma STDGL invariant(all)
----

Example 2:

[source,glsl]
----
vec2 m = ...;
vec2 n = ...;
vec2 a = m + n;
vec2 b = m + n; // a and b are not guaranteed to be exactly equal
----

There is no mechanism to enforce invariance between a and b.
endif::ESSL[]


[[invariance-of-constant-expressions]]
=== Invariance of Constant Expressions

Invariance must be guaranteed for constant expressions.
A particular constant expression must evaluate to the same result if it
appears again in the same shader or a different shader.
This includes the same expression appearing in two shaders of the same
language or shaders of two different languages.

Constant expressions must evaluate to the same result when operated on as
already described above for invariant variables.
ifdef::ESSL[]
Constant expressions are not invariant with respect to equivalent
non-constant expressions, even when the *invariant* qualifier or pragma is
used.


[[invariance-of-undefined-values]]
=== Invariance of Undefined Values

Undefined values are not invariant nor can they be made invariant by use of
the invariant qualifier or pragma.
In some implementations, undefined values may cause unexpected behavior if
they are used in control-flow expressions e.g. in the following case, one,
both or neither functions may be executed and this may not be consistent
over multiple invocations of the shader:

[source,glsl]
----
int x; // undefined value
if (x == 1)
{
    f(); // Undefined whether f() is executed
}
if (x == 2)
{
    g(); // Undefined whether g() is executed.
}
----

Note that an undefined value is a value that has not been specified.
A value that has been specified but has a potentially large error due to,
for example, lack of precision in an expression, is not undefined and so can
be made invariant.
endif::ESSL[]


[[the-precise-qualifier]]
== The Precise Qualifier

Some algorithms require floating-point computations to exactly follow the
order of operations specified in the source code and to treat all operations
consistently, even if the implementation supports optimizations that could
produce nearly equivalent results with higher performance.
For example, many GL implementations support a "`multiply-add`" instruction
that can compute a floating-point expression such as

[source,glsl]
----
result = (a * b) + (c * d);
----

in two operations instead of three operations; one multiply and one
multiply-add instead of two multiplies and one add.
The result of a floating-point multiply-add might not always be identical to
first doing a multiply yielding a floating-point result and then doing a
floating-point add.
Hence, in this example, the two multiply operations would not be treated
consistently; the two multiplies could effectively appear to have differing
precisions.

The key computation that needs to be made consistent appears when
tessellating, where intermediate points for subdivision are synthesized in
different directions, yet need to yield the same result, as shown in the
diagram below.

[[img-precise]]
image::images/precise.svg[]

ifdef::ESSL[]
As stated in "`<<evaluation-of-expressions,Evaluation of Expressions>>`",
the compiler may transform expressions even if this changes the resulting
value.
endif::ESSL[]
Without any qualifiers, implementations are permitted to perform
optimizations that effectively modify the order or number of operations used
to evaluate an expression, even if those optimizations may produce slightly
different results relative to unoptimized code.

The *precise* qualifier ensures that operations contributing to a
variable's value are done in their stated order and with operator consistency.
The order is determined by operator precedence and parentheses, as described in
"`<<operators,Operators>>`".
Operator consistency means that for each operator, its result is always
computed with the same precision.
Specifically, values computed by compiler-generated code must adhere to the
following identities:

  . a + b = b + a
  . a * b = b * a
  . a * b + c * d = b * a + c* d = d * c + b * a = <any other mathematically
    valid combination>

While the following are prevented:

  . a + (b + c) is not allowed to become (a + b) + c
  . a * (b * c) is not allowed to become (a * b) * c
  . a * b + c is not allowed to become a single operation *fma*(a, b, c)

Where _a_, _b_, _c_, and _d_, are scalars or vectors, not matrices.
(Matrix multiplication generally does not commute.) It is the shader
writer's responsibility to express the computation in terms of these rules
and the compiler's responsibility to follow these rules.
See the description of _gl_TessCoord_ for the rules the tessellation stages
are responsible for following, which in conjunction with the above allow
avoiding cracking when subdividing.

For example,

[source,glsl]
----
precise out vec4 position;
----

declares that operations used to produce the value of _position_ must be
performed in exactly the order specified in the source code and with all
operators being treated consistently.
As with the *invariant* qualifier (see "`<<the-invariant-qualifier,The
Invariant Qualifier>>`"), the *precise* qualifier may be used to qualify a
built-in or previously declared user-defined variable as being precise:

[source,glsl]
----
out vec3 Color;
precise Color; // make existing Color be precise
----

When applied to a block or a variable of structure type,
*precise* applies to each contained member, recursively.

This qualifier will affect the evaluation of an r-value in a particular
function if and only if the result is eventually consumed in the same
function by an l-value qualified as *precise*.
Any other expressions within a function are not affected, including return
values and output parameters not declared as *precise* but that are
eventually consumed outside the function by a variable qualified as
*precise*. Unaffected expressions also include the controlling expressions
in selection and iteration statements and the condition in ternary
operators (*?:*).

Some examples of the use of *precise*:

[source,glsl]
----
in vec4 a, b, c, d;
precise out vec4 v;

float func(float e, float f, float g, float h)
{
    return (e*f) + (g*h); // no constraint on order or operator consistency
}

float func2(float e, float f, float g, float h)
{
    precise float result = (e*f) + (g*h); // ensures same precision for the two multiplies
    return result;
}

float func3(float i, float j, precise out float k)
{
    k = i * i + j;        // precise, due to <k> declaration
}

void main()
{
    vec3 r = vec3(a * b);             // precise, used to compute v.xyz
    vec3 s = vec3(c * d);             // precise, used to compute v.xyz
    v.xyz = r + s;                    // precise
    v.w = (a.w * b.w) + (c.w * d.w);  // precise
    v.x = func(a.x, b.x, c.x, d.x);   // values computed in func() are NOT precise
    v.x = func2(a.x, b.x, c.x, d.x);  // precise!
    func3(a.x * b.x, c.x * d.x, v.x); // precise!
}
----

For the purposes of determining if an output from one shader stage matches
an input of the next stage, the *precise* qualifier need not match between
the input and the output.

All constant expressions are evaluated as if *precise* was present, whether
or not it is present.
However, as described in "`<<constant-expressions,Constant Expressions>>`",
there is no requirement that a compile-time constant expression evaluates to
the same value as a corresponding non-constant expression.


[[memory-qualifiers]]
== Memory Qualifiers

Shader storage blocks, variables declared within shader storage blocks and
variables declared as image types (the basic opaque types with "`*image*`"
in their keyword), can be further qualified with one or more of the
following memory qualifiers:

[options="header"]
|====
| Qualifier   | Meaning
| *coherent*  | memory variable where reads and writes are coherent with
                reads and writes from other shader invocations
| *volatile*  | memory variable whose underlying value may be changed at any
                point during shader execution by some source other than the
                current shader invocation
| *restrict*  | memory variable where use of that variable is the only way
                to read and write the underlying memory in the relevant
                shader stage
| *readonly*  | memory variable that can be used to read the underlying
                memory, but cannot be used to write the underlying memory
| *writeonly* | memory variable that can be used to write the underlying
                memory, but cannot be used to read the underlying memory
|====

Memory accesses to image variables declared using the *coherent* qualifier
are performed coherently with accesses to the same location from other
shader invocations.
ifdef::GLSL[]
In particular, when reading a variable declared as *coherent*, the values
returned will reflect the results of previously completed writes performed
by other shader invocations.
When writing a variable declared as *coherent*, the values written will be
reflected in subsequent coherent reads performed by other shader
invocations.
endif::GLSL[]

As described in section
ifdef::GLSL[7.12]
ifdef::ESSL[7.11]
"`Shader Memory Access`" of the
<<references,{apispec}>>, shader memory reads and writes complete in a
largely undefined order.
The built-in function *memoryBarrier*() can be used if needed to guarantee
the completion and relative ordering of memory accesses performed by a
single shader invocation.

When accessing memory using variables not declared as *coherent*, the memory
accessed by a shader may be cached by the implementation to service future
accesses to the same address.
Memory stores may be cached in such a way that the values written may not be
visible to other shader invocations accessing the same memory.
The implementation may cache the values fetched by memory reads and return
the same values to any shader invocation accessing the same memory, even if
the underlying memory has been modified since the first memory read.
While variables not declared as *coherent* may not be useful for
communicating between shader invocations, using non-coherent accesses may
result in higher performance.

Memory accesses to image variables declared using the *volatile* qualifier
must treat the underlying memory as though it could be read or written at
any point during shader execution by some source other than the executing
shader invocation.
When a volatile variable is read, its value must be re-fetched from the
underlying memory, even if the shader invocation performing the read had
previously fetched its value from the same memory.
When a volatile variable is written, its value must be written to the
underlying memory, even if the compiler can conclusively determine that its
value will be overwritten by a subsequent write.
Since the external source reading or writing a *volatile* variable may be
another shader invocation, variables declared as *volatile* are
automatically treated as coherent.

Memory accesses to image variables declared using the *restrict* qualifier
may be compiled assuming that the variable used to perform the memory access
is the only way to access the underlying memory using the shader stage in
question.
This allows the compiler to coalesce or reorder loads and stores using
**restrict**-qualified image variables in ways that wouldn't be permitted
for image variables not so qualified, because the compiler can assume that
the underlying image won't be read or written by other code.
Applications are responsible for ensuring that image memory referenced by
variables qualified with *restrict* will not be referenced using other
variables in the same scope; otherwise, accesses to **restrict**-qualified
variables will have undefined results.

Memory accesses to image variables declared using the *readonly* qualifier
may only read the underlying memory, which is treated as read-only memory
and cannot be written to.
It is {compiletimeerror} to pass an image variable qualified with
*readonly* to *imageStore*() or other built-in functions that modify image
memory.

Memory accesses to image variables declared using the *writeonly* qualifier
may only write the underlying memory; the underlying memory cannot be read.
It is {compiletimeerror} to pass an image variable qualified with
*writeonly* to *imageLoad*() or other built-in functions that read image
memory.

A variable could be qualified as both *readonly* and *writeonly*, disallowing
both read and write. Such variables can still be used with some queries, for
example *imageSize*() and *.length*().

ifdef::ESSL[]
Except for image variables qualified with the format qualifiers *r32f*,
*r32i*, and *r32ui*, image variables must specify a memory qualifier
(*readonly*, *writeonly*, or both).
endif::ESSL[]

The memory qualifiers *coherent*, *volatile*, *restrict*, *readonly*, and
*writeonly* may be used in the declaration of buffer variables (i.e.,
members of shader storage blocks).
When a buffer variable is declared with a memory qualifier, the behavior
specified for memory accesses involving image variables described above
applies identically to memory accesses involving that buffer variable.
It is a compile-time error to assign to a buffer variable qualified with
*readonly* or to read from a buffer variable qualified with *writeonly*.
The combination *readonly* *writeonly* is allowed.

Additionally, memory qualifiers may be used at the block-level declaration
of a shader storage block, including the combination *readonly* *writeonly*.
When a block declaration is qualified with a memory qualifier, it is as if
all of its members were declared with the same memory qualifier.
For example, the block declaration

[source,glsl]
----
coherent buffer Block {
    readonly vec4 member1;
    vec4 member2;
};
----

is equivalent to

[source,glsl]
----
buffer Block {
    coherent readonly vec4 member1;
    coherent vec4 member2;
};
----

Memory qualifiers are only supported in the declarations of image variables,
buffer variables, and shader storage blocks; it is an error to use such
qualifiers in any other declarations.

When calling user-defined functions, opaque-type variables qualified with
*coherent*, *volatile*, *readonly*, or *writeonly* may not be passed to
functions whose formal parameters lack such qualifiers.
(See "`<<function-definitions,Function Definitions>>`" for more detail on
function calling.) It is legal to have any additional memory qualifiers on a
formal parameter, but only *restrict* can be taken away from an opaque-type
calling argument, by a formal parameter that lacks the *restrict* qualifier.
For non-opaque argument types, where the values operated on by the called
function are copied-in/copied-out, memory qualifiers are not required match.

When a built-in function is called, the code generated is to be based on the
actual qualification of the calling argument, not on the list of memory
qualifiers specified on the formal parameter in the prototype.

[source,glsl]
----
vec4 funcA(restrict image2D a) { ... }
vec4 funcB(image2D a) { ... }
layout(rgba32f) uniform image2D img1;
layout(rgba32f) coherent uniform image2D img2;

funcA(img1);        // OK, adding "restrict" is allowed
funcB(img2);        // illegal, stripping "coherent" is not
----

Layout qualifiers cannot be used on formal function parameters, and layout
qualification is not included in parameter matching.

Note that the use of *const* in an image variable declaration is qualifying
the const-ness of the variable being declared, not the image it refers to.
The qualifier *readonly* qualifies the image memory (as accessed through
that variable) while *const* qualifies the variable itself.


[[specialization-constant-qualifier]]
== Specialization-Constant Qualifier

Specialization constants are used only for SPIR-V and declared using the
*constant_id* layout qualifier.
For example:

[source,glsl]
----
layout(constant_id = 17) const int arraySize = 12;
----

The above makes a specialization constant with a default value of 12.
The number 17 is an example author-chosen id by which the API or other tools
can later refer to this specific specialization constant.
If it is never changed before final lowering, it will retain the value of
12.
It is a compile-time error to use the *constant_id* qualifier on anything
but SPIR-V generation of a scalar *bool*, *int*, *uint*, *float*, or
*double*.

Built-in constants can be declared to be specialization constants.
For example:

[source,glsl]
----
layout(constant_id = 31) gl_MaxClipDistances; // add specialization_id
----

The declaration uses just the name of the previously declared built-in
variable, with a *constant_id* layout-qualifier declaration.
It is a compile-time error to do this after the constant has been used:
Constants are strictly either non-specialization constants or specialization
constants, not both.

The built-in constant vector _gl_WorkGroupSize_ can be specialized using the
*local_size_\{xyz}_id* qualifiers, to individually give the components an id.
For example:

[source,glsl]
----
layout(local_size_x_id = 18, local_size_z_id = 19) in;
----

This leaves _gl_WorkGroupSize.y_ as a non-specialization constant, with
_gl_WorkGroupSize_ being a partially specialized vector.
Its _x_ and _z_ components can be later specialized, after generating
SPIR-V, using the ids 18 and 19.
These ids are declared independently from declaring the workgroup size:

[source,glsl]
----
layout(local_size_x = 32, local_size_y = 32) in;   // size is (32,32,1)
layout(local_size_x_id = 18) in;                   // constant_id for x
layout(local_size_z_id = 19) in;                   // constant_id for z
----

Existing rules for declaring *local_size_x*, *local_size_y*, and
*local_size_z* are not changed.
For the local-size ids, it is a compile-time error to provide different id
values for the same local-size id, or to provide them after any use.
Otherwise, order, placement, number of statements, and replication do not
cause errors.

Two arrays sized with specialization constants are the same type only if
sized with the same symbol, and involving no operations.
For example:

[source,glsl]
----
layout(constant_id = 51) const int aSize = 20;
const int pad = 2;
const int total = aSize + pad; // specialization constant
int a[total], b[total];        // a and b have the same type
int c[22];                     // different type than a or b
int d[aSize + pad];            // different type than a, b, or c
int e[aSize + 2];              // different type than a, b, c, or d
----

Types containing arrays sized with a specialization constant cannot be
compared, assigned as aggregates, declared with an initializer, or used as
an initializer.
They can, however, be passed as arguments to functions having formal
parameters of the same type.
Only the outer-most dimension of a variable declared as an array of arrays
can be a specialization constant, otherwise a compile-time error results.

Arrays inside a block may be sized with a specialization constant, but the
block will have a static layout.
Changing the specialized size will not re-layout the block.
In the absence of explicit offsets, the layout will be based on the default
size of the array.


[[order-of-qualification]]
== Order and Repetition of Qualification

When multiple qualifiers are present in a declaration, they may appear in
any order, but they must all appear before the type.
The *layout* qualifier is the only qualifier that can appear more than once.
Further, a declaration can have at most one storage qualifier, at most one
auxiliary storage qualifier, and at most one interpolation qualifier.
ifdef::GLSL[If *inout* is used, neither *in* nor *out* may be used.]
Multiple memory qualifiers can be used.
Any violation of these rules will cause a compile-time error.


[[empty-declarations]]
== Empty Declarations

_Empty declarations_ are declarations without a variable name, meaning no
object is instantiated by the declaration.
Generally, empty declarations are allowed.
Some are useful when declaring structures, while many others have no effect.
For example:

[source,glsl]
----
int;               // No effect
struct S {int x;}; // Defines a struct S
----

The combinations of qualifiers that cause compile-time or link-time errors
are the same whether or not the declaration is empty, for example:

[source,glsl]
----
invariant in float x; // Error. An input cannot be invariant.
invariant in float;   // Error even though no variable is declared.
----
